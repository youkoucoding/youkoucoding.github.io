<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="frontend 每日一练"><title>毎日のフロントエンド 183</title><link rel=canonical href=https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-183/><link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="毎日のフロントエンド  183"><meta property="og:description" content="frontend 每日一练"><meta property="og:url" content="https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-183/"><meta property="og:site_name" content="技術の手帳"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:published_time" content="2022-03-21T15:15:07+09:00"><meta property="article:modified_time" content="2022-03-21T15:15:07+09:00"><meta name=twitter:title content="毎日のフロントエンド  183"><meta name=twitter:description content="frontend 每日一练"><link rel="shortcut icon" href=/img/site-icon.png></head><body class="article-page has-toc"><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex
extended"><div id=article-toolbar><a href=https://youkoucoding.github.io/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg><span>返回</span></a></div><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/html/>HTML</a>
<a href=/categories/css/>CSS</a>
<a href=/categories/tips/>Tips</a></header><h2 class=article-title><a href=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-183/>毎日のフロントエンド 183</a></h2><h3 class=article-subtitle>frontend 每日一练</h3><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Mar 21, 2022</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>阅读时长: 3 分钟</time></div></footer></div></header><section class=article-content><h2 id=html>HTML</h2><h3 id=output-标签><code>&lt;output></code> 标签</h3><ul><li><code>&lt;output></code> 标签表示计算或用户操作的结果。</li><li>属性<ul><li><code>for</code>其它影响计算结果的标签的 ID，可以多个。</li><li><code>form</code>与当前标签有关联的 form（从属的表单）。该属性的值必须是当前文档内的表单元素的 ID。如果未指明该属性，output 标签必须是一个 form 的后代标签。该属性的用处在于可以让 output 标签脱离 form 标签，存在于一个网页文档的任意位置。</li><li><code>name</code> 属性</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>form</span> <span class=na>oninput</span><span class=o>=</span><span class=s>&#34;result.value=parseInt(a.value)+parseInt(b.value)&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;</span><span class=nt>input</span> <span class=na>type</span><span class=o>=</span><span class=s>&#34;range&#34;</span> <span class=na>name</span><span class=o>=</span><span class=s>&#34;b&#34;</span> <span class=na>value</span><span class=o>=</span><span class=s>&#34;50&#34;</span> <span class=p>/&gt;</span> + <span class=p>&lt;</span><span class=nt>input</span> <span class=na>type</span><span class=o>=</span><span class=s>&#34;number&#34;</span> <span class=na>name</span><span class=o>=</span><span class=s>&#34;a&#34;</span> <span class=na>value</span><span class=o>=</span><span class=s>&#34;10&#34;</span> <span class=p>/&gt;</span> =
</span></span><span class=line><span class=cl>  <span class=p>&lt;</span><span class=nt>output</span> <span class=na>name</span><span class=o>=</span><span class=s>&#34;result&#34;</span><span class=p>&gt;&lt;/</span><span class=nt>output</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>form</span><span class=p>&gt;</span>
</span></span></code></pre></div><h2 id=css>CSS</h2><h3 id=去除图片自带的边距>去除图片自带的边距</h3><ul><li>图片以及所有其他 <code>inline-block</code> 元素之间都会有 4px 的间距，直接在父元素 <code>font-size: 0</code> 去除。</li></ul><h2 id=tips>Tips</h2><h3 id=函数返回多个值方法>函数返回多个值方法</h3><ul><li>函数 return expression, 这个表达式应该是一个具体的值,这个具体的值可以是一个承载多个值的复杂值, 诸如 Array,Object, Map,Set 等方式来实现</li></ul><h3 id=amdcmd和commonjs><code>AMD</code>、<code>CMD</code>和<code>CommonJS</code></h3><ul><li><p>AMD,CMD 和 CommonJs 是 es6 之前推出的模块化方案</p><ol><li>CommonJs 用在服务端</li><li>AMD,CMD 用在浏览器环境</li></ol></li><li><p>CommonJs 是由 node 推广使用的</p><ul><li>导出 <code>module.exports</code>，导入 <code>require</code></li></ul></li><li><p>AMD 是 RequireJS 在推广过程中对模块定义的规范化</p><ul><li>异步加载模块，模块的加载不影响后面语句的执行</li><li>所有依赖这些模块的语句，都定义到一个回调函数中，等依赖模块全部加载完成后，执行回调函数</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>define</span><span class=p>([</span><span class=s1>&#39;回调函数的依赖模块&#39;</span><span class=p>],</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 回调函数，依赖模块的语句
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>define</span><span class=p>([</span><span class=s1>&#39;./a&#39;</span><span class=p>,</span> <span class=s1>&#39;./b&#39;</span><span class=p>],</span> <span class=kd>function</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// 依赖刚开始就要去加载，加载依赖是异步加载
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// a b 依赖加载完成后，才去执行回调中语句
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>a</span><span class=p>.</span><span class=nx>doSomething</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=nx>b</span><span class=p>.</span><span class=nx>doSomething</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></div><ul><li>CMD 是<code>SeaJS</code>在推广过程中对模块定义的规范化<ul><li>采用就近依赖，同步加载。即在用到依赖的地方，才去加载依赖。</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>define</span><span class=p>(</span><span class=kd>function</span> <span class=p>(</span><span class=nx>require</span><span class=p>,</span> <span class=nx>exports</span><span class=p>,</span> <span class=nx>module</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nx>a</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;./a&#39;</span><span class=p>);</span> <span class=c1>// 依赖等用的时候才去加载，加载依赖是同步加载
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>a</span><span class=p>.</span><span class=nx>doSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nx>b</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;./b&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nx>b</span><span class=p>.</span><span class=nx>doSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>});</span>
</span></span></code></pre></div><h3 id=浏览器的同源策略same-origin-policy>浏览器的同源策略（Same Origin Policy）</h3><ul><li>源（Origin）是由 URL 中<strong>协议</strong>、<strong>主机名（域名 domain）</strong> 以及 <strong>端口</strong>共同组成的部分。</li></ul><blockquote><p>同源策略在保障安全的同时也带来了不少问题，比如 iframe 中的子页面与父页面无法通信，浏览器与其他服务端无法交互数据。所以我们需要一些跨域方案来解决这些问题。</p></blockquote><h4 id=请求跨域解决方案>请求跨域解决方案</h4><h5 id=1-跨域资源共享>1. 跨域资源共享</h5><ul><li>跨域资源共享（<code>CORS</code>，Cross-Origin Resource Sharing）是浏览器为 AJAX 请求设置的一种跨域机制，让其可以在服务端允许的情况下进行跨域访问。</li><li>主要通过 HTTP 响应头来告诉浏览器服务端是否允许当前域的脚本进行跨域访问。</li></ul><hr><ul><li><p>跨域资源共享将 AJAX 请求分成了两类：<strong>简单请求</strong>和<strong>非简单请求</strong></p><ul><li>其中简单请求符合下面 2 个特征：<ul><li>请求方法为 <code>GET</code>、<code>POST</code>、<code>HEAD</code></li><li><strong>请求头只能使用</strong>下面的字段：<code>Accept</code>（浏览器能够接受的响应内容类型）、<code>Accept-Language</code>（浏览器能够接受的自然语言列表）、<code>Content-Type</code> （请求对应的类型，只限于 text/plain、multipart/form-data、application/x-www-form-urlencoded）、<code>Content-Language</code>（浏览器希望采用的自然语言）、<code>Save-Data</code>（浏览器是否希望减少数据传输量）</li></ul></li><li><strong>任意一条要求不符合的即为非简单请求</strong></li></ul></li><li><p>简单请求，处理流程:</p><ul><li>浏览器发出简单请求的时候，会在请求头部增加一个 Origin 字段，对应的值为当前请求的源信息；</li><li>当服务端收到请求后，会根据请求头字段 Origin 做出判断后返回相应的内容</li><li>浏览器收到响应报文后会根据响应头部字段 <code>Access-Control-Allow-Origin</code> 进行判断，这个字段值为服务端允许跨域请求的源，其中通配符“*”表示允许所有跨域请求。如果头部信息没有包含 <code>Access-Control-Allow-Origin</code> 字段或者响应的头部字段 <code>Access-Control-Allow-Origin</code> 不允许当前源的请求，则会抛出错误。</li></ul></li><li><p>当处理非简单的请求时，浏览器会先发出一个预检请求（<code>Preflight</code>）。</p><ul><li>这个预检请求为 OPTIONS 方法，并会添加了 1 个请求头部字段 Access-Control-Request-Method，值为跨域请求所使用的请求方法。</li><li>在服务端收到预检请求后，除了在响应头部添加 <code>Access-Control-Allow-Origin</code> 字段之外，至少还会添加 <code>Access-Control-Allow-Methods</code> 字段来告诉浏览器服务端允许的请求方法，并返回 204(<code>No Content</code>) 状态码。</li><li>浏览器得到预检请求响应的头部字段之后，会判断当前请求服务端是否在服务端许可范围之内，如果在则继续发送跨域请求，反之则直接报错。</li></ul></li></ul><h5 id=2-jsonp>2. <code>JSONP</code></h5><blockquote><p><code>JSONP</code>（JSON with Padding）的大概意思就是用 JSON 数据来填充， 把 JSON 数据填充到一个回调函数中，依赖的是 <strong>script 标签跨域引用 js 文件不会受到浏览器同源策略的限制</strong>。</p></blockquote><p>具体实现方式</p><ol><li>全局声明一个用来处理返回值的函数 fn，该函数参数为请求的返回结果。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>fn</span><span class=p>(</span><span class=nx>result</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>result</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ol start=2><li>将函数名与其他参数一并写入 URL 中</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>var</span> <span class=nx>url</span> <span class=o>=</span> <span class=s1>&#39;http://www.b.com?callback=fn&amp;params=...&#39;</span><span class=p>;</span>
</span></span></code></pre></div><ol start=3><li>创建一个 script 标签，把 URL 赋值给 script 的 src</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>var</span> <span class=nx>script</span> <span class=o>=</span> <span class=nb>document</span><span class=p>.</span><span class=nx>createElement</span><span class=p>(</span><span class=s1>&#39;script&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>script</span><span class=p>.</span><span class=nx>setAttribute</span><span class=p>(</span><span class=s1>&#39;type&#39;</span><span class=p>,</span> <span class=s1>&#39;text/javascript&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>script</span><span class=p>.</span><span class=nx>src</span> <span class=o>=</span> <span class=nx>url</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nb>document</span><span class=p>.</span><span class=nx>body</span><span class=p>.</span><span class=nx>appendChild</span><span class=p>(</span><span class=nx>script</span><span class=p>);</span>
</span></span></code></pre></div><ol start=4><li>当服务器接收到请求后，解析 URL 参数并进行对应的逻辑处理，得到结果后将其写成回调函数的形式并返回给浏览器</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>fn</span><span class=p>({</span>
</span></span><span class=line><span class=cl>  <span class=nx>list</span><span class=o>:</span> <span class=p>[],</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></div><ol start=5><li>在浏览器收到请求返回的 js 脚本之后会立即执行文件内容，即在控制台打印传入的数据内容</li></ol><ul><li>JSONP 问题：<ul><li>只能发送 GET 请求，限制了参数大小和类型；</li><li>请求过程无法终止，导致弱网络下处理超时请求比较麻烦；</li><li>无法捕获服务端返回的异常信息。</li></ul></li></ul><h5 id=3-websocket>3. <code>Websocket</code></h5><blockquote><p>Websocket 是 HTML5 规范提出的一个应用层的全双工协议，适用于浏览器与服务器进行实时通信场景。</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// 在 a 网站直接创建一个 WebSocket 连接，连接到 b 网站即可
</span></span></span><span class=line><span class=cl><span class=c1>// 然后调用 WebScoket 实例 ws 的 send() 函数向服务端发送消息
</span></span></span><span class=line><span class=cl><span class=c1>// 监听实例 ws 的 onmessage 事件得到响应内容。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>ws</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>WebSocket</span><span class=p>(</span><span class=s1>&#39;ws://b.com&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>ws</span><span class=p>.</span><span class=nx>onopen</span> <span class=o>=</span> <span class=kd>function</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ws.send(...);
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=nx>ws</span><span class=p>.</span><span class=nx>onmessage</span> <span class=o>=</span> <span class=kd>function</span> <span class=p>(</span><span class=nx>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// console.log(e.data);
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><h5 id=4-代理转发>4. 代理转发</h5><ul><li><p>跨域是为了突破浏览器的同源策略限制，既然同源策略只存在于浏览器，在服务端进行跨域，比如设置代理转发。这种在服务端设置的代理称为“<strong>反向代理</strong>”，用户是无感知的。</p></li><li><p>另一种在客户端使用的代理称为“<strong>正向代理</strong>”，主要用来代理客户端发送请求，用户使用时必须配置代理服务器的网址，比如常用的 VPN 工具就属于正向代理。</p><ul><li>当浏览器发起前缀为 /api 的请求时都会被转发到 http://localhost:3000 这个网址，然后将响应结果返回给浏览器。对于浏览器而言还是请求当前网站，但实际上已经被服务端转发。</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// webpack.config.js
</span></span></span><span class=line><span class=cl><span class=c1>// webpack-dev-server 配置代理的示例代码
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>module</span><span class=p>.</span><span class=nx>exports</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>//...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>devServer</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>proxy</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=s1>&#39;/api&#39;</span><span class=o>:</span> <span class=s1>&#39;http://localhost:3000&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>or</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// 在 Nginx 服务器上配置同样的转发规则
</span></span></span><span class=line><span class=cl><span class=c1>// 通过 location 指令匹配路径，然后通过 proxy_pass 指令指向代理地址即可
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>location</span> <span class=o>/</span><span class=nx>api</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>proxy_pass</span>   <span class=nx>http</span><span class=o>:</span><span class=c1>//localhost:3000;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h4 id=页面跨域解决方案>页面跨域解决方案</h4><blockquote><p>除了浏览器请求跨域之外，页面之间也会有跨域需求，例如使用 iframe 时父子页面之间进行通信</p></blockquote><h5 id=1-postmessage>1. <code>postMessage</code></h5><ul><li><p>HTML5 新函数 <code>postMessage()</code> 用来实现父子页面之间通信，而且不论这两个页面是否同源</p></li><li><p>父页面向子页面发消息</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// https://example.com
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>child</span> <span class=o>=</span> <span class=nb>window</span><span class=p>.</span><span class=nx>open</span><span class=p>(</span><span class=s1>&#39;https://child.example.com&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>child</span><span class=p>.</span><span class=nx>postMessage</span><span class=p>(</span><span class=s1>&#39;hi&#39;</span><span class=p>,</span> <span class=s1>&#39;https://child.example.com&#39;</span><span class=p>);</span>
</span></span></code></pre></div><ul><li><p><code>window.open()</code> 函数打开了子页面，然后调用 <code>child.postMessage()</code> 函数发送了字符串数据“hi”给子页面</p></li><li><p>在子页面中，只需要监听“message”事件即可得到父页面的数据</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// https://child.example.com
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>window</span><span class=p>.</span><span class=nx>addEventListener</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=s1>&#39;message&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=kd>function</span> <span class=p>(</span><span class=nx>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>e</span><span class=p>.</span><span class=nx>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></div><ul><li>父页面也可以监听“message”事件来接收子页面发送的数据。子页面发送数据时则要通过 window.opener 对象来调用 postMessage() 函数</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// https://child.example.com
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>window</span><span class=p>.</span><span class=nx>opener</span><span class=p>.</span><span class=nx>postMessage</span><span class=p>(</span><span class=s1>&#39;hello&#39;</span><span class=p>,</span> <span class=s1>&#39;https://example.com&#39;</span><span class=p>);</span>
</span></span></code></pre></div><h5 id=2-改域>2. 改域</h5><ul><li>对于主域名相同，子域名不同的情况，可以通过修改 <code>document.domain</code> 的值来进行跨域。如果将其设置为其当前域的父域，则这个较短的父域将用于后续源检查。<ul><li>只能把 document.domain 设置成更高级的父域才有效果</li></ul></li></ul><h2 id=reference>Reference</h2><p><a class=link href=https://github.com/haizlin/fe-interview/blob/master/category/history.md target=_blank rel=noopener>haizlin/fe-interview</a></p><p><a class=link href=https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/output target=_blank rel=noopener><code>&lt;output></code> - HTML（超文本标记语言） | MDN</a></p><p><a class=link href=https://rxjs.dev/guide/overview target=_blank rel=noopener>RxJS - Introduction</a></p><p><a class=link href=https://requirejs.org/ target=_blank rel=noopener>RequireJS</a></p><p><a class=link href=https://github.com/seajs/seajs target=_blank rel=noopener>seajs/seajs: A Module Loader for the Web</a></p><p><a class=link href=https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage target=_blank rel=noopener>window.postMessage - Web API 接口参考 | MDN</a></p><p><a class=link href=https://developer.mozilla.org/zh-CN/docs/Web/API/Document/domain target=_blank rel=noopener>Document.domain - Web API 接口参考 | MDN</a></p></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title>相关文章</h2><div class=related-contents><div class="flex article-list--tile"><article><a href=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-200/><div class=article-details><h2 class=article-title>毎日のフロントエンド 200</h2></div></a></article><article><a href=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-195/><div class=article-details><h2 class=article-title>毎日のフロントエンド 195</h2></div></a></article><article><a href=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-193/><div class=article-details><h2 class=article-title>毎日のフロントエンド 193</h2></div></a></article><article><a href=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-189/><div class=article-details><h2 class=article-title>毎日のフロントエンド 189</h2></div></a></article><article><a href=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-188/><div class=article-details><h2 class=article-title>毎日のフロントエンド 188</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2021 -
2022 技術の手帳</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.2.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#html>HTML</a><ol><li><a href=#output-标签><code>&lt;output></code> 标签</a></li></ol></li><li><a href=#css>CSS</a><ol><li><a href=#去除图片自带的边距>去除图片自带的边距</a></li></ol></li><li><a href=#tips>Tips</a><ol><li><a href=#函数返回多个值方法>函数返回多个值方法</a></li><li><a href=#amdcmd和commonjs><code>AMD</code>、<code>CMD</code>和<code>CommonJS</code></a></li><li><a href=#浏览器的同源策略same-origin-policy>浏览器的同源策略（Same Origin Policy）</a><ol><li><a href=#请求跨域解决方案>请求跨域解决方案</a></li><li><a href=#页面跨域解决方案>页面跨域解决方案</a></li></ol></li></ol></li><li><a href=#reference>Reference</a></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>