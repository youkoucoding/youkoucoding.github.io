<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="frontend 每日一练"><title>毎日のフロントエンド 157</title><link rel=canonical href=https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-157/><link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="毎日のフロントエンド  157"><meta property="og:description" content="frontend 每日一练"><meta property="og:url" content="https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-157/"><meta property="og:site_name" content="技術の手帳"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:published_time" content="2022-02-20T11:26:21+09:00"><meta property="article:modified_time" content="2022-02-20T11:26:21+09:00"><meta name=twitter:title content="毎日のフロントエンド  157"><meta name=twitter:description content="frontend 每日一练"><link rel="shortcut icon" href=/img/site-icon.png></head><body class="article-page has-toc"><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex
extended"><div id=article-toolbar><a href=https://youkoucoding.github.io/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg><span>返回</span></a></div><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/html/>HTML</a>
<a href=/categories/css/>CSS</a>
<a href=/categories/tips/>Tips</a></header><h2 class=article-title><a href=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-157/>毎日のフロントエンド 157</a></h2><h3 class=article-subtitle>frontend 每日一练</h3><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Feb 20, 2022</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>阅读时长: 2 分钟</time></div></footer></div></header><section class=article-content><h1 id=第一百五十七日>第一百五十七日</h1><h2 id=html>HTML</h2><h3 id=bdo-标签>bdo 标签</h3><ul><li>将内部的文字反序输出<ul><li>属性是<code>dir</code><ul><li>默认是<code>ltr</code></li><li>需要倒叙就改成<code>rtl</code></li></ul></li></ul></li></ul><h2 id=css>CSS</h2><h3 id=外边距重叠>外边距重叠</h3><ol><li><p>外边距重叠是什么？</p><ul><li>外边距重叠指的是，当两个垂直外边距相遇时，它们将形成一个外边距。 重叠后的外边距的高度等于两个发生重叠的外边距的高度中的较大者。</li><li>发生的条件：属于同一个 BFC 的两个相邻元素上下 margin 会重叠。</li></ul></li><li><p>重叠的结果是什么？</p><ul><li>举例 1：当一个元素出现在另一个元素上面时，重叠后的外边距的高度等于两个发生重叠的外边距的高度中的较大者。</li><li>举例 2： 当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距也会发生重叠。如果这个外边距遇到另一个元素的外边距，它还会发生重叠。</li></ul></li><li><p>怎么防止外边距重叠？</p><ul><li>浮动元素、inline-block 元素、绝对定位元素的 margin 不会和垂直方向上其他元素的 margin 折叠（注意这里指的是上下相邻的元素）</li><li>外层元素 padding 代替</li><li>内层元素透明边框 border:1px solid transparent;</li><li>用同一方向的 margin，都设置为 top 或者 bottom。</li></ul></li></ol><h2 id=tips>Tips</h2><h3 id=浏览器的-eventloop>浏览器的 <code>Eventloop</code></h3><h4 id=1调用堆栈call-stack负责跟踪所有要执行的代码>1.调用堆栈（<code>call stack</code>）负责跟踪所有要执行的代码</h4><ul><li>每当一个函数执行完成时，就会从堆栈中弹出（pop）该执行完成函数</li><li>如果有代码需要进去执行的话，就进行 push 操作</li></ul><h4 id=2事件队列event-queue负责将新的-function-发送到队列中进行处理>2.事件队列（<code>event queue</code>）负责将新的 <code>function</code> 发送到队列中进行处理</h4><ul><li>遵循 queue 的数据结构特性，先进先出，在该顺序下发送所有操作以进行执行</li></ul><h4 id=3每当调用事件队列event-queue中的异步函数时都会将其发送到浏览器-api>3.每当调用事件队列（<code>event queue</code>）中的异步函数时，都会将其发送到浏览器 API</h4><ul><li>根据从调用堆栈收到的命令，API 开始自己的单线程操作</li><li>其中 <code>setTimeout</code> 方法就是一个比较典型的例子，在堆栈中处理 <code>setTimeout</code> 操作时，会将其发送到相应的 API，该 API 一直等到指定的时间将此操作送回进行处理</li><li>操作发送到 事件队列（event queue）</li></ul><h4 id=4javascript-语言本身是单线程的而浏览器-api-充当单独的线程>4.JavaScript 语言本身是单线程的，而浏览器 API 充当单独的线程</h4><ul><li>事件循环（Eventloop），会不断检查调用堆栈是否为空<ul><li>如果为空，则从事件队列中添加新的函数进入调用栈（call stack）；</li><li>如果不为空，则处理当前函数的调用。我们把整个过程串起来就是这样的一个循环执行流程</li></ul></li></ul><p><figure class=gallery-image style=flex-grow:153;flex-basis:367px><a href=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-157/event-loop.png data-size=1922x1254><img src=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-157/event-loop.png width=1922 height=1254 srcset="/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-157/event-loop_hu34c25599313582142125cbbb66d23507_477824_480x0_resize_box_3.png 480w, /p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-157/event-loop_hu34c25599313582142125cbbb66d23507_477824_1024x0_resize_box_3.png 1024w" loading=lazy alt=图解></a><figcaption>图解</figcaption></figure></p><h4 id=eventloop-的内部><code>Eventloop</code> 的内部</h4><ul><li>Eventloop 通过内部两个队列来实现 Event Queue 放进来的异步任务。<ul><li>以 <code>setTimeout</code> 为代表的任务被称为宏任务，放到宏任务队列（macrotask queue）中<ul><li><code>script</code>(整体代码),<code>setTimeout</code>,<code>setInterval</code>,<code>setImmediate</code>,<code>I/O</code>,<code>UI rendering</code>,<code>event listner</code></li></ul></li><li>以 <code>Promise</code> 为代表的任务被称为微任务，放到微任务队列（microtask queue）中<ul><li><code>process.nextTick</code>, <code>Promises</code>, <code>Object.observe</code>, <code>MutationObserver</code></li></ul></li></ul></li></ul><ol><li>JavaScript 引擎首先从宏任务队列（macrotask queue）中取出第一个任务；</li><li>执行完毕后，再将微任务（microtask queue）中的所有任务取出，按照顺序分别全部执行（这里包括不仅指开始执行时队列里的微任务），如果在这一步过程中产生新的微任务，也需要执行；</li><li>然后再从宏任务队列中取下一个，执行完毕后，再次将 microtask queue 中的全部取出，循环往复，直到两个 queue 中的任务都取完。</li></ol><blockquote><p>一次 <code>Eventloop</code> 循环会处理一个宏任务和所有这次循环中产生的微任务。</p></blockquote><h3 id=nodejs-的-eventloop><code>Node.js</code> 的 <code>Eventloop</code></h3><blockquote><p>When Node.js starts, it initializes the event loop, processes the provided input script (or drops into the REPL, which is not covered in this document) which may make async API calls, schedule timers, or call process.nextTick(), then begins processing the event loop.</p></blockquote><blockquote><p>当 Node.js 开始启动时，会初始化一个 Eventloop，处理输入的代码脚本，这些脚本会进行 API 异步调用，<code>process.nextTick()</code> 方法会开始处理事件循环</p></blockquote><p><figure class=gallery-image style=flex-grow:184;flex-basis:442px><a href=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-157/node-event-loop.png data-size=1886x1024><img src=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-157/node-event-loop.png width=1886 height=1024 srcset="/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-157/node-event-loop_hu4505a7fa79510efcbda331322f19032f_199449_480x0_resize_box_3.png 480w, /p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-157/node-event-loop_hu4505a7fa79510efcbda331322f19032f_199449_1024x0_resize_box_3.png 1024w" loading=lazy alt=nodejs-event-loop></a><figcaption>nodejs-event-loop</figcaption></figure></p><ul><li><p>整个流程分为六个阶段，当这六个阶段执行完一次之后，才可以算得上执行了一次 Eventloop 的循环过程:</p><ol><li><code>Timers</code> 阶段：这个阶段执行 setTimeout 和 setInterval。</li><li><code>I/O callbacks</code> 阶段：这个阶段主要执行系统级别的回调函数，比如 TCP 连接失败的回调。</li><li><code>idle，prepare</code> 阶段：只是 Node.js 内部闲置、准备，可以忽略。</li><li><code>poll</code> 阶段：poll 阶段是一个重要且复杂的阶段，几乎所有 I/O 相关的回调，都在这个阶段执行（除了 setTimeout、setInterval、setImmediate 以及一些因为 exception 意外关闭产生的回调）<figure class=gallery-image style=flex-grow:207;flex-basis:497px><a href=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-157/poll.png data-size=2360x1138><img src=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-157/poll.png width=2360 height=1138 srcset="/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-157/poll_hue37649cfe4f971c99fd593b62e1a31e1_385015_480x0_resize_box_3.png 480w, /p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-157/poll_hue37649cfe4f971c99fd593b62e1a31e1_385015_1024x0_resize_box_3.png 1024w" loading=lazy alt=poll></a><figcaption>poll</figcaption></figure></li><li><code>check</code> 阶段：执行 setImmediate() 设定的 callbacks。</li><li><code>close callbacks</code> 阶段：执行关闭请求的回调函数，比如 socket.on(&lsquo;close&rsquo;, &mldr;)</li></ol></li><li><p>node 引入了一个新的任务队列 <code>Process.nextTick()</code></p><ul><li><code>process.nextTick()</code>is not technically part of the event loop. Instead, thenextTickQueuewill be processed after the current operation is completed, regardless of the current phase of the event loop. Here, an operation is defined as a transition from the underlying C/C++ handler, and handling the JavaScript that needs to be executed.</li><li><code>Process.nextTick()</code> 会在上述各个阶段结束时，在进入下一个阶段之前立即执行（优先级甚至超过 microtask 队列）</li></ul></li></ul><hr><blockquote><p>Node.js 和浏览器端宏任务队列的另一个很重要的不同点是，浏览器端任务队列每轮事件循环仅出队一个回调函数接着去执行微任务队列；而 Node.js 端只要轮到执行某个宏任务队列，则会执行完队列中所有的当前任务，但是当前轮次新添加到队尾的任务则会等到下一轮次才会执行。</p></blockquote><h3 id=eventloop-对渲染的影响><code>EventLoop</code> 对渲染的影响</h3><ul><li>浏览器作为一个复杂的应用是多线程工作的，除了运行 JS 的线程外，还有渲染线程、定时器触发线程、HTTP 请求线程，等等。JS 线程可以读取并且修改 DOM，而渲染线程也需要读取 DOM，这是一个典型的多线程竞争临界资源的问题。所以浏览器就把这两个线程设计成互斥的，即同时只能有一个线程在执行</li></ul><p><a class=link href=https://developer.mozilla.org/zh-CN/docs/Web/API/window/requestAnimationFrame target=_blank rel=noopener>window.requestAnimationFrame - Web API 接口参考 | MDN</a></p><p><a class=link href=https://html.spec.whatwg.org/multipage/webappapis.html#rendering-opportunity target=_blank rel=noopener>HTML Standard</a></p><h2 id=reference>Reference</h2><p><a class=link href=https://github.com/haizlin/fe-interview/blob/master/category/history.md target=_blank rel=noopener>haizlin/fe-interview</a></p><p><a class=link href=https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/bdo target=_blank rel=noopener><code>&lt;bdo></code>: 双向文本替代元素 - HTML（超文本标记语言） | MDN</a></p></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title>相关文章</h2><div class=related-contents><div class="flex article-list--tile"><article><a href=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-358/><div class=article-details><h2 class=article-title>毎日のフロントエンド 358</h2></div></a></article><article><a href=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-241/><div class=article-details><h2 class=article-title>毎日のフロントエンド 241</h2></div></a></article><article><a href=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-232~240/><div class=article-details><h2 class=article-title>毎日のフロントエンド 232~240</h2></div></a></article><article><a href=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-222/><div class=article-details><h2 class=article-title>毎日のフロントエンド 222</h2></div></a></article><article><a href=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-221/><div class=article-details><h2 class=article-title>毎日のフロントエンド 221</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2021 -
2022 技術の手帳</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.2.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#html>HTML</a><ol><li><a href=#bdo-标签>bdo 标签</a></li></ol></li><li><a href=#css>CSS</a><ol><li><a href=#外边距重叠>外边距重叠</a></li></ol></li><li><a href=#tips>Tips</a><ol><li><a href=#浏览器的-eventloop>浏览器的 <code>Eventloop</code></a><ol><li><a href=#1调用堆栈call-stack负责跟踪所有要执行的代码>1.调用堆栈（<code>call stack</code>）负责跟踪所有要执行的代码</a></li><li><a href=#2事件队列event-queue负责将新的-function-发送到队列中进行处理>2.事件队列（<code>event queue</code>）负责将新的 <code>function</code> 发送到队列中进行处理</a></li><li><a href=#3每当调用事件队列event-queue中的异步函数时都会将其发送到浏览器-api>3.每当调用事件队列（<code>event queue</code>）中的异步函数时，都会将其发送到浏览器 API</a></li><li><a href=#4javascript-语言本身是单线程的而浏览器-api-充当单独的线程>4.JavaScript 语言本身是单线程的，而浏览器 API 充当单独的线程</a></li><li><a href=#eventloop-的内部><code>Eventloop</code> 的内部</a></li></ol></li><li><a href=#nodejs-的-eventloop><code>Node.js</code> 的 <code>Eventloop</code></a></li><li><a href=#eventloop-对渲染的影响><code>EventLoop</code> 对渲染的影响</a></li></ol></li><li><a href=#reference>Reference</a></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>