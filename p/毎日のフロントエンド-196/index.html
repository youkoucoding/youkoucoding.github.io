<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="frontend 每日一练"><title>毎日のフロントエンド 196</title><link rel=canonical href=https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-196/><link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="毎日のフロントエンド 196"><meta property="og:description" content="frontend 每日一练"><meta property="og:url" content="https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-196/"><meta property="og:site_name" content="技術の手帳"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:published_time" content="2022-04-03T14:27:21+09:00"><meta property="article:modified_time" content="2022-04-03T14:27:21+09:00"><meta name=twitter:title content="毎日のフロントエンド 196"><meta name=twitter:description content="frontend 每日一练"><link rel="shortcut icon" href=/img/site-icon.png></head><body class="article-page has-toc"><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex
extended"><div id=article-toolbar><a href=https://youkoucoding.github.io/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg><span>返回</span></a></div><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/html/>HTML</a>
<a href=/categories/tips/>Tips</a></header><h2 class=article-title><a href=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-196/>毎日のフロントエンド 196</a></h2><h3 class=article-subtitle>frontend 每日一练</h3><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Apr 03, 2022</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>阅读时长: 2 分钟</time></div></footer></div></header><section class=article-content><h2 id=html>HTML</h2><h3 id=引用标签>引用标签</h3><ul><li><p><code>&lt;blockquote></code>：块级引用元素</p><ul><li><code>&lt;blockquote></code> 元素（或者 HTML 块级引用元素），代表其中的文字是引用内容。通常在渲染时，这部分的内容会有一定的缩进（注 中说明了如何更改）</li><li>若引文来源于网络，则可以将原内容的出处 URL 地址设置到 cite 特性上，若要以文本的形式告知读者引文的出处时，可以通过 <code>&lt;cite></code> 元素</li></ul></li><li><p><code>&lt;q></code>标签, 短引用</p><ul><li>引用标签 (<code>&lt;q></code>) 表示一个封闭的并且是短的行内引用的文本。这个标签是用来引用短的文本，所以不要引入换行符; 对于长的文本的引用使用 <code>&lt;blockquote></code> 替代。</li><li><code>cite</code>这个属性的值是 URL，意在指出被引用的文本的源文档或者源信息。这个属性重在解释这个引用的参考或者是上下文。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>p</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  Everytime Kenny is killed, Stan will announce
</span></span><span class=line><span class=cl>  <span class=p>&lt;</span><span class=nt>q</span> <span class=na>cite</span><span class=o>=</span><span class=s>&#34;http://en.wikipedia.org/wiki/Kenny_McCormick#Cultural_impact&#34;</span><span class=p>&gt;</span> Oh my God, <span class=p>&lt;/</span><span class=nt>q</span><span class=p>&gt;</span>.
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>p</span><span class=p>&gt;</span>
</span></span></code></pre></div></li></ul><h2 id=tips---yarn>Tips - <code>Yarn</code></h2><blockquote><p>Yarn 是一个由 Facebook、Google、Exponent 和 Tilde 构建的新的 JavaScript 包管理器。它的出现是为了解决历史上 npm 的某些不足（比如 npm 对于依赖的完整性和一致性保障，以及 npm 安装速度过慢的问题等），虽然 npm 目前经过版本迭代汲取了 Yarn 一些优势特点（比如一致性安装校验算法等），但依然有必要关注 Yarn 的思想和理念。</p></blockquote><ul><li>当 npm 还处在 v3 时期时，一个叫作 Yarn 的包管理方案横空出世。2016 年，npm 还没有 <code>package-lock.json</code> 文件，安装速度很慢，稳定性也较差，而 Yarn 的理念很好地解决了以下问题。<ul><li>确定性：通过 yarn.lock 等机制，保证了确定性。即不管安装顺序如何，相同的依赖关系在任何机器和环境下，都可以以相同的方式被安装。（在 npm v5 之前，没有 package-lock.json 机制，只有默认并不会使用的 npm-shrinkwrap.json。）</li><li>采用模块扁平安装模式：将依赖包的不同版本，按照一定策略，归结为单个版本，以避免创建多个副本造成冗余（npm 目前也有相同的优化）。</li><li>网络性能更好：Yarn 采用了请求排队的理念，类似并发连接池，能够更好地利用网络资源；同时引入了更好的安装失败时的重试机制。</li><li>采用缓存机制，实现了离线模式（npm 目前也有类似实现）。</li></ul></li></ul><blockquote><p><a class=link href=https://github.com/imsnif/synp target=_blank rel=noopener>imsnif/synp: Convert yarn.lock to package-lock.json and vice versa</a></p></blockquote><ul><li><p><strong>Yarn 默认使用 prefer-online 模式，即优先使用网络数据。如果网络数据请求失败，再去请求缓存数据。</strong></p></li><li><p>Yarn 所独有的命令：</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>yarn import
</span></span><span class=line><span class=cl>yarn licenses
</span></span><span class=line><span class=cl>yarn pack
</span></span><span class=line><span class=cl>yarn why
</span></span><span class=line><span class=cl>yarn autoclean
</span></span></code></pre></div><ul><li>npm 独有的命令是：<code>npm rebuild</code></li></ul><h3 id=yarn-安装机制和背后思想>Yarn 安装机制和背后思想</h3><ul><li>Yarn 的安装过程主要有以下 5 大步骤：<ul><li>检测（checking）→ 解析包（Resolving Packages） → 获取包（Fetching Packages）→ 链接包（Linking Packages）→ 构建包（Building Packages）</li></ul></li></ul><h4 id=检测包checking>检测包（checking）</h4><ul><li>这一步主要是检测项目中是否存在一些 npm 相关文件，比如 package-lock.json 等。如果有，会提示用户注意：这些文件的存在可能会导致冲突。在这一步骤中，也会检查系统 OS、CPU 等信息。</li></ul><h4 id=解析包resolving-packages>解析包（Resolving Packages）</h4><ul><li>这一步会解析依赖树中每一个包的版本信息。</li><li>首先获取当前项目中 package.json 定义的 dependencies、devDependencies、optionalDependencies 的内容，这属于<strong>首层依赖</strong>。</li><li>接着采用<strong>遍历首层依赖</strong>的方式获取依赖包的版本信息，以及递归查找每个依赖下嵌套依赖的版本信息，并将解析过和正在解析的包用一个 <code>Set</code> 数据结构来存储，这样就能保证同一个版本范围内的包不会被重复解析。<ul><li>对于没有解析过的包 A，首次尝试从 yarn.lock 中获取到版本信息，并标记为已解析；</li><li>如果在 yarn.lock 中没有找到包 A，则向 Registry 发起请求获取满足版本范围的已知最高版本的包信息，获取后将当前包标记为已解析。</li></ul></li><li>在经过解析包这一步之后，我们就确定了所有依赖的具体版本信息以及下载地址。</li></ul><h4 id=获取包fetching-packages>获取包（Fetching Packages）</h4><ul><li><p>这一步首先需要检查缓存中是否存在当前的依赖包，同时将缓存中不存在的依赖包下载到缓存目录：</p></li><li><p>如何判断缓存中是否存在当前的依赖包？</p><ul><li>Yarn 会根据 <code>cacheFolder+slug+node_modules+pkg.name</code> 生成一个 path，判断系统中是否存在该 path，如果存在证明已经有缓存，不用重新下载。这个 path 也就是依赖包缓存的具体路径。</li><li>对于没有命中缓存的包，Yarn 会维护一个 fetch 队列，按照规则进行网络请求。</li><li>如果下载包地址是一个 file 协议，或者是相对路径，就说明其指向一个本地目录，此时调用 Fetch From Local 从离线缓存中获取包；</li><li>否则调用 Fetch From External 获取包。最终获取结果使用 fs.createWriteStream 写入到缓存目录下。</li></ul></li></ul><p><figure class=gallery-image style=flex-grow:581;flex-basis:1395px><a href=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-196/fetch-package.png data-size=1558x268><img src=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-196/fetch-package.png width=1558 height=268 srcset="/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-196/fetch-package_hu789557e4ceed312203bb1bc247cb45cf_153328_480x0_resize_box_3.png 480w, /p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-196/fetch-package_hu789557e4ceed312203bb1bc247cb45cf_153328_1024x0_resize_box_3.png 1024w" loading=lazy alt=获取包的流程></a><figcaption>获取包的流程</figcaption></figure></p><h4 id=链接包linking-packages>链接包（Linking Packages）</h4><ul><li>上一步是将依赖下载到缓存目录，这一步是将项目中的依赖复制到项目 node_modules 下，同时遵循扁平化原则。</li><li>在复制依赖前，Yarn 会先解析 peerDependencies，如果找不到符合 peerDependencies 的包，则进行 warning 提示，并最终拷贝依赖到项目中。</li></ul><p><figure class=gallery-image style=flex-grow:532;flex-basis:1278px><a href=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-196/link-package.png data-size=1534x288><img src=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-196/link-package.png width=1534 height=288 srcset="/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-196/link-package_hu2727eb15b436daf688a9a59f37ea80ab_121612_480x0_resize_box_3.png 480w, /p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-196/link-package_hu2727eb15b436daf688a9a59f37ea80ab_121612_1024x0_resize_box_3.png 1024w" loading=lazy alt=链接包的流程></a><figcaption>链接包的流程</figcaption></figure></p><h4 id=构建包building-packages>构建包（Building Packages）</h4><ul><li>如果依赖包中存在二进制包需要进行编译，会在这一步进行。</li></ul><hr><h3 id=依赖管理困境>依赖管理困境</h3><ul><li>项目依赖树的层级非常深，不利于调试和排查问题；</li><li>依赖树的不同分支里，可能存在同样版本的相同依赖。比如直接依赖 A 和 B，但 A 和 B 都依赖相同版本的模块 C，那么 C 会重复出现在 A 和 B 依赖的 node_modules 中</li></ul><blockquote><p>这种重复问题使得安装结果浪费了较大的空间资源，也使得安装过程过慢，甚至会因为目录层级太深导致文件路径太长，最终在 Windows 系统下删除 node_modules 文件夹出现失败情况。</p></blockquote><ul><li>npm v3 之后，node_modules 的结构改成了扁平结构</li></ul><p><figure class=gallery-image style=flex-grow:189;flex-basis:454px><a href=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-196/npm-version-change.png data-size=1120x592><img src=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-196/npm-version-change.png width=1120 height=592 srcset="/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-196/npm-version-change_hu4a345310e35e6fe23c2f021a273d7e38_85345_480x0_resize_box_3.png 480w, /p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-196/npm-version-change_hu4a345310e35e6fe23c2f021a273d7e38_85345_1024x0_resize_box_3.png 1024w" loading=lazy alt="npm 不同版本的安装结构图"></a><figcaption>npm 不同版本的安装结构图</figcaption></figure></p><ul><li>当项目新添加了 C 依赖，而它依赖另一个版本的 B v2.0。这时候版本要求不一致导致冲突，B v2.0 没办法放在项目平铺目录下的 node_moduls 文件当中，npm v3 会把 C 依赖的 B v2.0 安装在 C 的 node_modules 下：</li></ul><p><figure class=gallery-image style=flex-grow:249;flex-basis:598px><a href=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-196/npm-version-change-two.png data-size=1560x626><img src=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-196/npm-version-change-two.png width=1560 height=626 srcset="/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-196/npm-version-change-two_hu902793a3fb43f8f907430891b9c0db7f_131013_480x0_resize_box_3.png 480w, /p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-196/npm-version-change-two_hu902793a3fb43f8f907430891b9c0db7f_131013_1024x0_resize_box_3.png 1024w" loading=lazy alt="npm 不同版本的安装结构图"></a><figcaption>npm 不同版本的安装结构图</figcaption></figure></p><ul><li>B v1.0 出现在项目顶层 node_modules，而不是 B v2.0 出现在 node_modules 顶层<ul><li>这取决于模块 A 和 C 的安装顺序。因为 A 先安装，所以 A 的依赖 B v1.0 率先被安装在顶层 node_modules 中，接着 C 和 D 依次被安装，C 和 D 的依赖 B v2.0 就不得不安装在 C 和 D 的 node_modules 当中了。因此，<strong>模块的安装顺序可能影响 node_modules 内的文件结构</strong>。</li></ul></li></ul><p>&mldr;&mldr;</p><hr><ul><li><p><strong>明显看到出现了较多重复的依赖模块 B v2.0。我们可以删除 node_modules，重新安装，利用 npm 的依赖分析能力，得到一个更清爽的结构</strong></p></li><li><p><strong>更优雅的方式是使用 npm dedupe 命令</strong></p></li><li><p>实际上，Yarn 在安装依赖时会自动执行 <code>dedupe</code> 命令(删除重复)。整个优化的安装过程，就是上一讲提到的扁平化安装模式，也是需要掌握的<strong>关键内容</strong>。</p></li></ul><h2 id=reference>Reference</h2><p><a class=link href=https://github.com/haizlin/fe-interview/blob/master/category/history.md target=_blank rel=noopener>haizlin/fe-interview</a></p><p><a class=link href=https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/blockquote target=_blank rel=noopener><code>&lt;blockquote></code>：块级引用元素 - HTML（超文本标记语言） | MDN</a></p><p><a class=link href=https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/cite target=_blank rel=noopener><code>&lt;cite></code> - HTML（超文本标记语言） | MDN</a></p><p><a class=link href=https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/q target=_blank rel=noopener><code>&lt;q></code> - HTML（超文本标记语言） | MDN</a></p><p><a class=link href=https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes target=_blank rel=noopener>全局属性 - HTML（超文本标记语言） | MDN</a></p></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title>相关文章</h2><div class=related-contents><div class="flex article-list--tile"><article><a href=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-195/><div class=article-details><h2 class=article-title>毎日のフロントエンド 195</h2></div></a></article><article><a href=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-193/><div class=article-details><h2 class=article-title>毎日のフロントエンド 193</h2></div></a></article><article><a href=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-189/><div class=article-details><h2 class=article-title>毎日のフロントエンド 189</h2></div></a></article><article><a href=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-188/><div class=article-details><h2 class=article-title>毎日のフロントエンド 188</h2></div></a></article><article><a href=/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-184/><div class=article-details><h2 class=article-title>毎日のフロントエンド 184</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2021 -
2022 技術の手帳</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.2.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#html>HTML</a><ol><li><a href=#引用标签>引用标签</a></li></ol></li><li><a href=#tips---yarn>Tips - <code>Yarn</code></a><ol><li><a href=#yarn-安装机制和背后思想>Yarn 安装机制和背后思想</a><ol><li><a href=#检测包checking>检测包（checking）</a></li><li><a href=#解析包resolving-packages>解析包（Resolving Packages）</a></li><li><a href=#获取包fetching-packages>获取包（Fetching Packages）</a></li><li><a href=#链接包linking-packages>链接包（Linking Packages）</a></li><li><a href=#构建包building-packages>构建包（Building Packages）</a></li></ol></li><li><a href=#依赖管理困境>依赖管理困境</a></li></ol></li><li><a href=#reference>Reference</a></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>