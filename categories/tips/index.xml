<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tips on 技術の手帳</title><link>https://youkoucoding.github.io/categories/tips/</link><description>Recent content in Tips on 技術の手帳</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 12 Feb 2022 16:50:12 +0900</lastBuildDate><atom:link href="https://youkoucoding.github.io/categories/tips/index.xml" rel="self" type="application/rss+xml"/><item><title>毎日のフロントエンド 149</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-149/</link><pubDate>Sat, 12 Feb 2022 16:50:12 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-149/</guid><description>第一百四十日 HTML Question: 整个页面中的内容设置成只读，不可编辑的状态 body { pointer-events: none !important; } Tips 数组排序 比较类排序：通过比较来决定元素间的相对次序，其时间复杂度不能突破 O(nlogn)，因此也称为非线性时间比较类排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 排序的分类
冒泡排序 let a = [1, 3, 6, 3, 23, 76, 1, 34, 222, 6, 456, 221]; function bubbleSort(array) { const len = array.length; if (len &amp;lt; 2) return array; for (let i = 0; i &amp;lt; len; i++) { for (let j = 0; j &amp;lt; i; j++) { if (array[j] &amp;gt; array[i]) { const temp = array[j]; array[j] = array[i]; array[i] = temp; } } } return array; } bubbleSort(a); // [1, 1, 3, 3, 6, 6, 23, 34, 76, 221, 222, 456] 快速排序 最主要的思路是从数列中挑出一个元素，称为 “基准”（pivot）；然后重新排序数列，所有元素比基准值小的摆放在基准前面、比基准值大的摆在基准的后面；在这个区分搞定之后，该基准就处于数列的中间位置；然后把小于基准值元素的子数列（left）和大于基准值元素的子数列（right）递归地调用 quick 方法排序完成。 let a = [1, 3, 6, 3, 23, 76, 1, 34, 222, 6, 456, 221]; function quickSort(array) { let quick = function (arr) { if (arr.</description></item><item><title>毎日のフロントエンド 147</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-147/</link><pubDate>Thu, 10 Feb 2022 12:56:13 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-147/</guid><description>第一百四十六日 HTML Question: 本地存储的生命周期 cookie: expire 和 max-age 都能控制数据的存储时间。expire 是一个绝对的过期时间，max-age 是文档被访问之后的存活时间（是相对时间）。默认是 session (一次会话) sessionStorage: 当会话被关闭后（浏览器、标签页被关闭），就会被清除。与 localStorage 用法一样 localStorage: 除非被主动清除，不然永久储存在浏览器中 IndexedDB: 没有过期时间，除非主动清除 CSS Question: background-attachment属性 background-attachment: fixed / scroll / local： 设置背景图像是否固定或者随着页面的其余部分滚动。 fixed: 背景图片不会随着页面的滚动而滚动 scroll: 背景图片随着页面的滚动而滚动，默认 local: 背景图片会随着元素内容的滚动而滚动 inherit: 指定 background-attachment 的设置应该从父元素继承。 Tips 数组扁平化 数组的扁平化其实就是将一个嵌套多层的数组 array（嵌套可以是任何层数）转换为只有一层的数组。
方法一：普通的递归实现 // 方法1 // 在遍历过程中发现数组元素还是数组的时候进行递归操作， // 把数组的结果通过数组的 concat 方法拼接到最后要返回的 result 数组上，那么最后输出的结果就是扁平化后的数组。 var a = [1, [2, [3, 4, 5]]]; function flatten(arr) { let result = []; for (let i = 0; i &amp;lt; arr.</description></item><item><title>毎日のフロントエンド 146</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-146/</link><pubDate>Wed, 09 Feb 2022 11:17:27 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-146/</guid><description>第一百四十六日 HTML Question: viewport 是什么？在什么时候下使用 viewport 是用户网页的可视区域 多用于移动端，也可以用在支持类似“固定到边缘”等特性的桌面浏览器 移动端的浏览器是把页面放在一个虚拟的&amp;quot;窗口&amp;quot;（viewport）中，通常这个虚拟的&amp;quot;窗口&amp;quot;（viewport）比物理屏幕宽，这样就不用把每个网页挤到很小的窗口中（这样会破坏没有针对手机浏览器优化的网页的布局），用户可以通过平移和缩放来看网页的不同部分 visual viewport 尺寸所对应的并不是指屏幕区域里的物理像素，而是 CSS 像素。并且它所包含的 CSS 像素的数量也是随着用户缩放而有所改变 在 head 加入这行，把默认的 layout viewport 的宽度设为移动设备的屏幕宽度，也就是把当前的 viewport 宽度设置为设备物理屏幕的宽度，实现全屏的效果 &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no&amp;quot;&amp;gt; Tips 类数组 函数里面的参数对象 arguments 用 getElementsByTagName/ClassName/Name 获得的 HTMLCollection 用 querySelector 获得的 NodeList arguments对象 只定义在函数体中 有一个 length 属性 callee 属性(此函数自身) function foo(name, age, sex) { console.log(arguments); // [Arguments] { &amp;#39;0&amp;#39;: &amp;#39;jack&amp;#39;, &amp;#39;1&amp;#39;: &amp;#39;18&amp;#39;, &amp;#39;2&amp;#39;: &amp;#39;male&amp;#39; } console.</description></item><item><title>毎日のフロントエンド 145</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-145/</link><pubDate>Tue, 08 Feb 2022 20:47:08 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-145/</guid><description>第一百四十五日 HTML Question: 表单属性type=&amp;quot;hidden&amp;quot; &amp;lt;input type=&amp;quot;hidden&amp;quot;&amp;gt; &amp;ldquo;hidden&amp;rdquo; 类型的 &amp;lt;input&amp;gt; 元素允许 Web 开发者存放一些用户不可见、不可改的数据，在用户提交表单时，这些数据会一并发送出。比如，正被请求或编辑的内容的 ID，或是一个唯一的安全令牌。这些隐藏的 &amp;lt;input&amp;gt;元素在渲染完成的页面中完全不可见，而且没有方法可以使它重新变为可见。 隐藏域在页面中对于用户是不可见的，在表单中插入隐藏域的目的在于收集或发送信息，以利于被处理表单的程序所使用。浏览者单击发送按钮发送表单的时候，隐藏域的信息也被一起发送到服务器 有些时候要给用户一信息，在提交表单时一同提交,以确定用户身份，如 sessionkey 等．同样也可以用 cookie 实现，但使用隐藏域就简单的多了．兼容性好，且可以避免被禁用cookies 一个 form 里有多个提交按钮，怎样使程序能够分清楚到底用户是按那一个按钮提交上来的呢？ 这时可以添加隐藏域，然后在每一个按钮处加上 οnclick=&amp;ldquo;document.form.command.value=&amp;ldquo;xx&amp;rdquo;， 然后接到数据后先检查 command 的值就会知道用户是按的那个按钮提交上来的 一个网页中有多个 form，我们知道多个 form 是不能同时提交的，但有时这些 form 确实相互作用，我们就可以在 form 中添加隐藏域来使它们联系起来 JavaScript Question: 原生 Math 的方法有哪些 常用方法
Math.abs(num) // num绝对值 Math.ceil(num) // num向上取整 Math.floor(num) // num向下取整 Math.max(num1, num2 ...) // 取较大值 Math.min(num1, num2 ...) // 取较小值 Math.pow(num1, num2) // num1的num2次幂 Math.</description></item></channel></rss>