<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tips on 技術の手帳</title><link>https://youkoucoding.github.io/categories/tips/</link><description>Recent content in Tips on 技術の手帳</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 15 Mar 2022 11:28:16 +0900</lastBuildDate><atom:link href="https://youkoucoding.github.io/categories/tips/index.xml" rel="self" type="application/rss+xml"/><item><title>毎日のフロントエンド 177</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-177/</link><pubDate>Tue, 15 Mar 2022 11:28:16 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-177/</guid><description>HTML 网站首页有大量的图片，加载很慢，怎么优化 小图用 iconfont（svg）代替。 不能替代的用 base64。 去除 gif 图，用 video 代替。 工具压缩图片的大小。 优先使用 webp 格式 骨骼屏+ 懒加载。 CSS preload、preconnect、prefetch Preload: 在 &amp;lt;link&amp;gt; 标签中使用 preload 时，提前请求资源。主要用于获取当前路由中使用的高优先级资源。 元素的 rel 属性的属性值 preload 能够让你在你的 HTML 页面中元素内部书写一些声明式的资源获取请求，可以指明哪些资源是在页面加载完成后即刻需要的。 rel=&amp;quot;preolad&amp;quot;声明这是一个 preload href 指明资源的位置 as 指明资源类型（这是为了让浏览器精确设置优先级，设置正确的 CSP、Accept 头部） crossorigin 指明使用的跨域设置 添加 preload 声明之后，浏览器初次加载的资源变多了，但 preload 并不会阻塞 onload 事件的触发 Preconnect: 解决 DNS 和 TCP 握手问题, 使浏览器能够预先建立一个连接，等真正需要加载资源的时候就能够直接请求了 Prefetch: 提前获取资源将其置于缓存中，使用资源时从缓存中获取而不是发出另一个请求。 Tips debounce (TypeScript) 函数 debounce 添加类型，包括参数类型和返回值类型。参数类型使用泛型变量，在调用函数 debounce 的时候手动指定，泛型变量有 3 个：函数 T 、函数 T 的返回值 U 和 函数 T 的参数 V 变量 timeout ，当定时器存在时它的值为 number，定时器不存在时值为 null const debounce = &amp;lt;T extends Function, U, V extends any[]&amp;gt;(func: T, wait: number = 0) =&amp;gt; { let timeout: number | null = null; let args: V; function debounced(.</description></item><item><title>毎日のフロントエンド 176</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-176/</link><pubDate>Mon, 14 Mar 2022 17:25:38 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-176/</guid><description>JavaScript 模块化 ES6 模块 ES6 模块强制自动采用严格模式，所以说不管有没有“user strict”声明都是一样的，换言之，编写代码的时候不必再刻意声明了； 虽然大部分主流浏览器支持 ES6 模块，但是和引入普通 JS 的方式略有不同，需要在对应 script 标签中将属性 type 值设置为module才能被正确地解析为 ES6 模块； 在 Node.js 下使用 ES6 模块则需要将文件名后缀改为“.mjs”，用来和 Node.js 默认使用的 CommonJS 规范模块作区分 ES6 模块有两个重要特性
值引用 指 export 语句输出的接口，与其对应的值是动态绑定关系。即通过该接口，可以取到模块内部实时的值，可以简单地理解为变量浅拷贝。 静态分析 指不需要执行代码，只从字面量上对代码进行分析。 // 必须首部声明 let a = 1 import { app } from &amp;#39;./app&amp;#39;; // 不允许使用变量或表达式 import { &amp;#39;a&amp;#39; + &amp;#39;p&amp;#39; + &amp;#39;p&amp;#39; } from &amp;#39;./app&amp;#39;; // 不允许被嵌入语句逻辑 if (moduleName === &amp;#39;app&amp;#39;) { import { init } from &amp;#39;.</description></item><item><title>毎日のフロントエンド 175</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-175/</link><pubDate>Sun, 13 Mar 2022 17:19:01 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-175/</guid><description>CSS css 文件过大时， &amp;ldquo;异步加载 CSS&amp;rdquo; 利用媒体查询 &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;./index.css&amp;quot; media=&amp;quot;none&amp;quot; onload=&amp;quot;this.media='all'&amp;quot;&amp;gt;
OR
&amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;./index1.css&amp;#34; media=&amp;#34;screen and (max-width: 800px)&amp;#34; /&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;./index2.css&amp;#34; media=&amp;#34;screen and (min-width: 800px)&amp;#34; /&amp;gt; rel means relationship
提前加载资源 优先级最高，异步加载，不会阻塞 DOM 的渲染，浏览器支持度比较低。
&amp;lt;link rel=&amp;quot;preload&amp;quot; href=&amp;quot;./index.css&amp;quot; as=&amp;quot;style&amp;quot;&amp;gt;
该属性还可以应用于其他资源
当用到这些资源的时候，浏览器会从缓存中取得，不再次发送请求了
Here however, we will use a rel value of preload, which turns &amp;lt;link&amp;gt; into a preloader for any resource we want.</description></item><item><title>毎日のフロントエンド 173</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-173/</link><pubDate>Fri, 11 Mar 2022 15:40:11 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-173/</guid><description>HTML HTML 的标签区分大小写 DOCTYPE 声明, 不区分大小写
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;!doctype html&amp;gt; &amp;lt;!DOCTYPE HTML&amp;gt; &amp;lt;!Doctype html&amp;gt; HTML 文档中的标签名和属性名都是大小写不敏感的
HTML 中属性的名字是大小写不敏感的，而属性的值则默认是大小写敏感的
下述列表中的属性的值是大小写不敏感的: accept accept-charset align alink axis bgcolor charset checked clear codetype color compact declare defer dir direction disabled enctype face frame hreflang http-equiv lang language link media method multiple nohref noresize noshade nowrap readonly rel rev rules scope scrolling selected shape target text type (视情况而定) valign valuetype vlink XML 文档中的标签名和属性名都是大小写敏感的。</description></item><item><title>毎日のフロントエンド 172</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-172/</link><pubDate>Thu, 10 Mar 2022 20:42:49 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-172/</guid><description>Tips 函数为什么是一等公民 据类型与函数是很多高级语言中最重要的两个概念，前者用来存储数据，后者用来存储代码。JavaScript 中的函数相对于数据类型而言更加复杂，它可以有属性，也可以被赋值给一个变量，还可以作为参数被传递&amp;hellip;&amp;hellip;正是这些强大特性让它成了 JavaScript 的“一等公民”
this 关键字 this 指向的应该是一个对象，更具体地说是函数执行的“上下文对象” 这个对象指向的是“调用它”的对象，如果调用它的不是对象或对象不存在，则会指向全局对象（严格模式下为 undefined） function fn() { console.log(this); } function fn2() { fn(); } var obj = { fn2 }; obj.fn2(); // ? 调用函数 fn() 的是函数 fn2() 而不是 obj。虽然 fn2() 作为 obj 的属性调用，但 fn2()中的 this 指向并不会传递给函数 fn()， 所以答案也是 window（Node.js 下是 global） var dx = { arr: [1], }; dx.arr.forEach(function () { console.log(this); }); // ? forEach，它有两个参数，第一个是回调函数，第二个是 this 指向的对象，这里只传入了回调函数，第二个参数没有传入，默认为 undefined，所以正确答案应该是输出全局对象。 类似的，需要传入 this 指向的函数还有：every()、find()、findIndex()、map()、some() class B { fn() { console.</description></item><item><title>毎日のフロントエンド 161</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-161/</link><pubDate>Thu, 24 Feb 2022 16:52:49 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-161/</guid><description>HTML HTML 调用摄像头 window.navigator.getUserMedia()
接收三个参数，第一个是视频或者音频以及分辨率{video:true}第二个是成功回调，第三个是失败回调 window.navigator.mediaDevices.getUserMedia()
也是三个参数，参数格式和上文一样，区别在于这个 api 是基于 promise 实现的 JavaScript Nodejs Process.nextTick process.nextTick(callback[, ...args])
第一个参数是 callback 回调函数，第二个参数是 args 调用 callback 时额外传的参数，是可选参数 Process.nextTick 是微任务 也是异步 API 的一部分
Process.nextTick 的运行逻辑：
Process.nextTick 会将 callback 添加到“next tick queue”； “next tick queue”会在当前 JavaScript stack 执行完成后，下一次 event loop 开始执行前按照 FIFO 出队； 如果递归调用 Process.nextTick 可能会导致一个无限循环，需要去适时终止递归。 根据代码执行顺序，Process.</description></item><item><title>毎日のフロントエンド 160</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-160/</link><pubDate>Wed, 23 Feb 2022 17:07:08 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-160/</guid><description>CSS 第一行和第二行的颜色分别是什么 &amp;lt;style&amp;gt; .red { color: red; } .green { color: green; } &amp;lt;/style&amp;gt; &amp;lt;div class=&amp;#34;red green&amp;#34;&amp;gt;第一行：颜色是什么？&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;green red&amp;#34;&amp;gt;第二行：颜色是什么？&amp;lt;/div&amp;gt; 都是绿色。CSS 的覆盖顺序与标签内 class 定义的顺序无关，只与 style 中的顺序有关，后面的覆盖前面的属性 JavaScript 有些 js 库习惯在代码开头处添加分号有什么作用 js 文件结束 处是 没有 分号的。若几个 js 连在一起时，2 个 js 连接处 会发生语法上的混淆。 开头加; 用于分隔， 可以避免多文件压缩在一起时引起的错误。分号和分号放在一起也没问题，相当于 “空语句”。 可以用void ! + ~ 代替 宏任务和微任务 代码执行顺序 console.log(&amp;#39;begin&amp;#39;); setTimeout(() =&amp;gt; { console.log(&amp;#39;setTimeout&amp;#39;); }, 0); new Promise((resolve) =&amp;gt; { console.log(&amp;#39;promise&amp;#39;); resolve(); }) .</description></item><item><title>毎日のフロントエンド 159</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-159/</link><pubDate>Tue, 22 Feb 2022 23:06:50 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-159/</guid><description>第一百五十九日 HTML html 实现下拉提示 datalist - HTML（超文本标记语言） | MDN &amp;lt;label for=&amp;#34;favorite_team&amp;#34;&amp;gt;Favorite Team:&amp;lt;/label&amp;gt; &amp;lt;!-- 注意input的list属性与datalist的id属性进行绑定 --&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;team&amp;#34; id=&amp;#34;favorite_team&amp;#34; list=&amp;#34;team_list&amp;#34; autocomplete=&amp;#34;off&amp;#34;/&amp;gt; &amp;lt;datalist id=&amp;#34;team_list&amp;#34;&amp;gt; &amp;lt;!-- 指定了value值之后，value和innerHTML类似于标题与副标题之间的关系，选中后input的值是value --&amp;gt; &amp;lt;option value=&amp;#34;A&amp;#34;&amp;gt;Aus Tigers&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;B&amp;#34;&amp;gt;Detroit Lions&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;C&amp;#34;&amp;gt;Detroit Pistons&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;D&amp;#34;&amp;gt;Detroit Red Wings&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;E&amp;#34;&amp;gt;Detroit Tigers&amp;lt;/option&amp;gt; &amp;lt;/datalist&amp;gt; &amp;lt;/datalist&amp;gt; CSS 两端对齐 对于文字，利用 text-align-last:justify; or :before 模拟成多行然后 text-align: justify 子元素的两端对齐，用 float 或 flex 或 grid Tips attribute 和 property 区别 attribute</description></item><item><title>毎日のフロントエンド 158</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-158/</link><pubDate>Mon, 21 Feb 2022 21:20:02 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-158/</guid><description>第一百五十八日 Tips V8 引擎 V8 引擎执行 JS 代码都要经过哪些阶段 Parse 阶段：V8 引擎负责将 JS 代码转换成 AST（抽象语法树）； Ignition 阶段：解释器将 AST 转换为字节码，解析执行字节码也会为下一个阶段优化编译提供需要的信息； TurboFan 阶段：编译器利用上个阶段收集的信息，将字节码优化为可以执行的机器码； Orinoco 阶段：垃圾回收阶段，将程序中不再使用的内存空间进行回收。 生成 AST AST 抽象语法树的应用场景
JS 反编译，语法解析； Babel 编译 ES6 语法； 代码高亮； 关键字匹配； 代码压缩。 AST 分为两个阶段
词法分析： 这个阶段会将源代码拆成最小的、不可再分的词法单元，称为 token。比如这行代码 var a =1；通常会被分解成 var 、a、=、2、; 这五个词法单元。另外刚才代码中的空格在 JavaScript 中是直接忽略的。 语法分析 这个过程是将词法单元转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，这个树被称为抽象语法树。 // 第一段代码 var a = 1; // 第二段代码 function sum(a, b) { return a + b; } 分别转换成 AST 抽象语法树之后返回的 JSON 格式如下</description></item><item><title>毎日のフロントエンド 157</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-157/</link><pubDate>Sun, 20 Feb 2022 11:26:21 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-157/</guid><description>第一百五十七日 HTML bdo 标签 将内部的文字反序输出 属性是dir 默认是ltr 需要倒叙就改成rtl CSS 外边距重叠 外边距重叠是什么？
外边距重叠指的是，当两个垂直外边距相遇时，它们将形成一个外边距。 重叠后的外边距的高度等于两个发生重叠的外边距的高度中的较大者。 发生的条件：属于同一个 BFC 的两个相邻元素上下 margin 会重叠。 重叠的结果是什么？
举例 1：当一个元素出现在另一个元素上面时，重叠后的外边距的高度等于两个发生重叠的外边距的高度中的较大者。 举例 2： 当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距也会发生重叠。如果这个外边距遇到另一个元素的外边距，它还会发生重叠。 怎么防止外边距重叠？
浮动元素、inline-block 元素、绝对定位元素的 margin 不会和垂直方向上其他元素的 margin 折叠（注意这里指的是上下相邻的元素） 外层元素 padding 代替 内层元素透明边框 border:1px solid transparent; 用同一方向的 margin，都设置为 top 或者 bottom。 Tips 浏览器的 Eventloop 1.调用堆栈（call stack）负责跟踪所有要执行的代码 每当一个函数执行完成时，就会从堆栈中弹出（pop）该执行完成函数 如果有代码需要进去执行的话，就进行 push 操作 2.</description></item><item><title>毎日のフロントエンド 156</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-156/</link><pubDate>Sat, 19 Feb 2022 15:08:08 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-156/</guid><description>第一百五十六日 CSS border:none和border:0px区别 从border: 10px;过渡到border: none;，是不会有动画的 从border: 10px;过渡到border: 0px;，是可以有动画的 Tips JavaScript 的内存管理 基本类型：这些类型在内存中会占据固定的内存空间，它们的值都保存在栈空间中，直接可以通过值来访问这些； 引用类型：由于引用类型值大小不固定（比如上面的对象可以添加属性等），栈内存中存放地址指向堆内存中的对象，是通过引用来访问的 栈内存中的基本类型，可以通过操作系统直接处理；而堆内存中的引用类型，正是由于可以经常变化，大小不固定，因此需要 JavaScript 的引擎通过垃圾回收机制来处理。
Chrome 内存回收机制 Chrome 的 JavaScript 引擎 V8 将堆内存分为两类 新生代的回收机制和老生代的回收机制
内存泄漏与优化 内存泄漏的场景： 过多的缓存未释放 闭包太多未释放 定时器或者回调太多未释放 太多无效的 DOM 未释放 全局变量太多未被发现 减少不必要的全局变量，使用严格模式避免意外创建全局变量 function foo() { // 全局变量=&amp;gt; window.bar this.bar = &amp;#39;默认this指向全局&amp;#39;; // 没有声明变量，实际上是全局变量=&amp;gt;window.bar bar = &amp;#39;全局变量&amp;#39;; } foo(); 在你使用完数据后，及时解除引用（闭包中的变量，DOM 引用，定时器清除） var someResource = getData(); setInterval(function() { var node = document.</description></item><item><title>毎日のフロントエンド 155</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-155/</link><pubDate>Fri, 18 Feb 2022 10:51:40 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-155/</guid><description>第一百五十五日 HTML HTML5 有哪些存储类型 cookie: 最大 4k, 基本无兼容问题, 所有同源 tab 共享, 每次请求都携带, key-value 存储, value 只存字符串 sessionStorage 无大小限制, 只在当前 tab 有效, tab 关闭即失效, key-value 存储, value 只存字符串 localStorage 最大 5M-10M, 所有同源 tab 共享, 能持久化存储, key-value 存储, value 只存字符串 indexDB key-value 存储,value 可以任意类型, 同源, 支持事务, 最大 250M, 兼容 ie10 webSQL 支持版本,事务,支持 sql 语句, 不兼容 ie CSS CSS Guidelines (2.2.5) – High-level advice and guidelines for writing sane, manageable, scalable CSS</description></item><item><title>毎日のフロントエンド 154</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-154/</link><pubDate>Thu, 17 Feb 2022 16:45:01 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-154/</guid><description>第一百五十四日 JavaScript 并行和并发、同步和异步、阻塞和非阻塞 并发并行是处理任务的方式 并发是在一个时间段可以处理多个任务，但是在相同的时间内只能处理一个任务 并行是同时可以处理多个任务 同步异步是处理运行结果的方式 同步是在上一个返回结果还没返回的时候就不进行下一步的调用 异步是上一个结果还没返回就继续执行下一步，直到有返回结果了再调用对应的异步回调 阻塞和非阻塞是运行时的状态 阻塞是在上一个任务还在执行时，下一个任务处于无法执行的状态，需要继续等待，直到上一个任务执行完毕 非阻塞就是任务的执行状态一直是上一个执行了，下一个就继续执行，没有多余的等待时间 Tips EventEmitter(node) 常用的 EventEmitter 模块的 API
addListener 和 removeListener、on 和 off 方法对比 addListener 方法的作用是为指定事件添加一个监听器，其实和 on 方法实现的功能是一样的，on 其实就是 addListener 方法的一个别名。二者实现的作用是一样的 removeListener 方法的作用是为移除某个事件的监听器，同样 off 也是 removeListener 的别名 var events = require(&amp;#39;events&amp;#39;); var emitter = new events.EventEmitter(); function hello1(name) { console.log(&amp;#39;hello 1&amp;#39;, name); } function hello2(name) { console.</description></item><item><title>毎日のフロントエンド 153</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-153/</link><pubDate>Wed, 16 Feb 2022 16:56:17 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-153/</guid><description>第一百五十三日 HTML 单词标志缩写 &amp;lt;abbr&amp;gt; - HTML（超文本标记语言） | MDN CSS 背景裁剪 background-clip`: border-box: 默认,背景延伸至边框外沿,但是在边框的下层 padding-box: 背景延伸至 padding 的外沿 content-box: 背景延伸至内容的外沿 text: 背景剪裁成文字的样式 Tips 异步编程 什么是同步 所谓的同步就是在执行某段代码时，在该代码没有得到返回结果之前，其他代码暂时是无法执行的，但是一旦执行完成拿到返回值之后，就可以执行其他代码了。换句话说，在此段代码执行完未返回结果之前，会阻塞之后的代码执行，这样的情况称为同步。
什么是异步 所谓异步就是当某一代码执行异步过程调用发出后，这段代码不会立刻得到返回结果。而是在异步调用发出之后，一般通过回调函数处理这个调用之后拿到结果。异步调用发出后，不会影响阻塞后面的代码执行，这样的情形称为异步。
Promise function read(url) { return new Promise((resolve, reject) =&amp;gt; { fs.readFile(url, &amp;#39;utf8&amp;#39;, (err, data) =&amp;gt; { if (err) reject(err); resolve(data); }); }); } // 通过 Promise.all 可以实现多个异步并行执行，同一时刻获取最终结果的问题 Promise.all([read(A), read(B), read(C)]) .then((data) =&amp;gt; { console.log(data); }) .catch((err) =&amp;gt; console.</description></item><item><title>毎日のフロントエンド 152</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-152/</link><pubDate>Tue, 15 Feb 2022 17:28:33 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-152/</guid><description>第一百五十二日 HTML small标签 &amp;lt;small&amp;gt;元素將使文本的字体变小一号。(例如从大变成中等，从中等变成小，从小变成超小)。在 HTML5 中，除了它的样式含义，这个元素被重新定义为表示边注释和附属细则，包括版权和法律文本。 JavaScript CORS 预检请求 简单请求 同源策略是一个重要的安全策略，它用于限制一个 origin 的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。 当一个资源从与该资源本身所在的服务器不同的域、协议、端口请求一个资源时，资源会发起一个跨域 HTTP 请求。
出于安全原因，浏览器限制从脚本内发起的跨源 HTTP 请求，XMLHttpRequest 和 Fetch API，只能从加载应用程序的同一个域请求 HTTP 资源，除非使用 CORS 头文件 CORS 概述 跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。
另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。
服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）
cors-flow
简单请求 不会触发 CORS 预检的请求称为简单请求，满足以下所有条件的才会被视为简单请求: 使用GET、POST、HEAD其中一种方法 只使用了如下的安全首部字段，不得人为设置其他首部字段 Accept Accept-Language Content-Language Content-Type 仅限以下三种 text/plain multipart/form-data application/x-www-form-urlencoded HTML 头部 header field 字段：DPR、Download、Save-Data、Viewport-Width、Width 请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload对象可以使用 XMLHttpRequest.</description></item><item><title>毎日のフロントエンド 151</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-151/</link><pubDate>Mon, 14 Feb 2022 10:24:45 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-151/</guid><description>第一百五十一日 HTML Question: 在页面中添加数学公式 KaTeX – The fastest math typesetting library for the web MathJax | Beautiful math in all browsers. Tips 常用的数组方法底层实现 push 方法的底层实现 Array.prototype.push = function (...items) { let O = Object(this); // ecma 中提到的先转换为对象 // &amp;gt;&amp;gt;&amp;gt; 无符号右移 &amp;gt;&amp;gt;&amp;gt; 0 对非负数 取整; // 确保 ensure that the length property is a unsigned 32-bit integer. let len = this.length &amp;gt;&amp;gt;&amp;gt; 0; let argCount = items.</description></item><item><title>毎日のフロントエンド 150</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-150/</link><pubDate>Sun, 13 Feb 2022 15:12:49 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-150/</guid><description>第一百五十日 HTML Question: HTML5 如何使某个页面元素或整个页面可编辑 让某个元素可以编辑，可以使用 contenteditable 属性 让整个页面可编辑可以使用 document.designMode 属性 CSS Question: 什么时候用 transition？什么时候使用 animation transition 相当于是个过度动画，需要又过度效果才会触发。一般用来做元素的放大缩小、平移旋转等简单的操作 transition 只执行一次，当需要执行多次时，一般会利用 :hover 等时机或者使用 javaScript 改变类名进行控制。 animation 需要自己设定关键帧，可以做相对复杂的操作，比如延迟、循环播放等。一般在需要比较复杂的情况才会使用 animation Tips sort排序算法实现原理 arr.sort([compareFunction]) 数组已原地排序，并且不进行复制 compareFunction 用来指定按某种顺序进行排列的函数，如果省略不写，元素按照转换为字符串的各个字符的 Unicode 位点进行排序 const months = [&amp;#39;March&amp;#39;, &amp;#39;Jan&amp;#39;, &amp;#39;Feb&amp;#39;, &amp;#39;Dec&amp;#39;]; months.sort(); console.log(months); // [&amp;#34;Dec&amp;#34;, &amp;#34;Feb&amp;#34;, &amp;#34;Jan&amp;#34;, &amp;#34;March&amp;#34;] const array1 = [1, 30, 4, 21, 100000]; array1.sort(); console.log(array1); // [1, 100000, 21, 30, 4] 如果指明了 compareFunction 参数 ，那么数组会按照调用该函数的返回值排序，即 a 和 b 是两个将要被比较的元素： 如果 compareFunction（a, b)小于 0，那么 a 会被排列到 b 之前； 如果 compareFunction（a, b)等于 0，a 和 b 的相对位置不变； 如果 compareFunction（a, b)大于 0，b 会被排列到 a 之前。 sort 源码分析</description></item><item><title>毎日のフロントエンド 149</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-149/</link><pubDate>Sat, 12 Feb 2022 16:50:12 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-149/</guid><description>第一百四十九日 HTML Question: 整个页面中的内容设置成只读，不可编辑的状态 body { pointer-events: none !important; } Tips 数组排序 比较类排序：通过比较来决定元素间的相对次序，其时间复杂度不能突破 O(nlogn)，因此也称为非线性时间比较类排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 排序的分类
冒泡排序 let a = [1, 3, 6, 3, 23, 76, 1, 34, 222, 6, 456, 221]; function bubbleSort(array) { const len = array.length; if (len &amp;lt; 2) return array; for (let i = 0; i &amp;lt; len; i++) { for (let j = 0; j &amp;lt; i; j++) { if (array[j] &amp;gt; array[i]) { const temp = array[j]; array[j] = array[i]; array[i] = temp; } } } return array; } bubbleSort(a); // [1, 1, 3, 3, 6, 6, 23, 34, 76, 221, 222, 456] 快速排序 最主要的思路是从数列中挑出一个元素，称为 “基准”（pivot）；然后重新排序数列，所有元素比基准值小的摆放在基准前面、比基准值大的摆在基准的后面；在这个区分搞定之后，该基准就处于数列的中间位置；然后把小于基准值元素的子数列（left）和大于基准值元素的子数列（right）递归地调用 quick 方法排序完成。 let a = [1, 3, 6, 3, 23, 76, 1, 34, 222, 6, 456, 221]; function quickSort(array) { let quick = function (arr) { if (arr.</description></item><item><title>毎日のフロントエンド 147</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-147/</link><pubDate>Thu, 10 Feb 2022 12:56:13 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-147/</guid><description>第一百四十六日 HTML Question: 本地存储的生命周期 cookie: expire 和 max-age 都能控制数据的存储时间。expire 是一个绝对的过期时间，max-age 是文档被访问之后的存活时间（是相对时间）。默认是 session (一次会话) sessionStorage: 当会话被关闭后（浏览器、标签页被关闭），就会被清除。与 localStorage 用法一样 localStorage: 除非被主动清除，不然永久储存在浏览器中 IndexedDB: 没有过期时间，除非主动清除 CSS Question: background-attachment属性 background-attachment: fixed / scroll / local： 设置背景图像是否固定或者随着页面的其余部分滚动。 fixed: 背景图片不会随着页面的滚动而滚动 scroll: 背景图片随着页面的滚动而滚动，默认 local: 背景图片会随着元素内容的滚动而滚动 inherit: 指定 background-attachment 的设置应该从父元素继承。 Tips 数组扁平化 数组的扁平化其实就是将一个嵌套多层的数组 array（嵌套可以是任何层数）转换为只有一层的数组。
方法一：普通的递归实现 // 方法1 // 在遍历过程中发现数组元素还是数组的时候进行递归操作， // 把数组的结果通过数组的 concat 方法拼接到最后要返回的 result 数组上，那么最后输出的结果就是扁平化后的数组。 var a = [1, [2, [3, 4, 5]]]; function flatten(arr) { let result = []; for (let i = 0; i &amp;lt; arr.</description></item><item><title>毎日のフロントエンド 146</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-146/</link><pubDate>Wed, 09 Feb 2022 11:17:27 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-146/</guid><description>第一百四十六日 HTML Question: viewport 是什么？在什么时候下使用 viewport 是用户网页的可视区域 多用于移动端，也可以用在支持类似“固定到边缘”等特性的桌面浏览器 移动端的浏览器是把页面放在一个虚拟的&amp;quot;窗口&amp;quot;（viewport）中，通常这个虚拟的&amp;quot;窗口&amp;quot;（viewport）比物理屏幕宽，这样就不用把每个网页挤到很小的窗口中（这样会破坏没有针对手机浏览器优化的网页的布局），用户可以通过平移和缩放来看网页的不同部分 visual viewport 尺寸所对应的并不是指屏幕区域里的物理像素，而是 CSS 像素。并且它所包含的 CSS 像素的数量也是随着用户缩放而有所改变 在 head 加入这行，把默认的 layout viewport 的宽度设为移动设备的屏幕宽度，也就是把当前的 viewport 宽度设置为设备物理屏幕的宽度，实现全屏的效果 &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no&amp;quot;&amp;gt; Tips 类数组 函数里面的参数对象 arguments 用 getElementsByTagName/ClassName/Name 获得的 HTMLCollection 用 querySelector 获得的 NodeList arguments对象 只定义在函数体中 有一个 length 属性 callee 属性(此函数自身) function foo(name, age, sex) { console.log(arguments); // [Arguments] { &amp;#39;0&amp;#39;: &amp;#39;jack&amp;#39;, &amp;#39;1&amp;#39;: &amp;#39;18&amp;#39;, &amp;#39;2&amp;#39;: &amp;#39;male&amp;#39; } console.</description></item><item><title>毎日のフロントエンド 145</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-145/</link><pubDate>Tue, 08 Feb 2022 20:47:08 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-145/</guid><description>第一百四十五日 HTML Question: 表单属性type=&amp;quot;hidden&amp;quot; &amp;lt;input type=&amp;quot;hidden&amp;quot;&amp;gt; &amp;ldquo;hidden&amp;rdquo; 类型的 &amp;lt;input&amp;gt; 元素允许 Web 开发者存放一些用户不可见、不可改的数据，在用户提交表单时，这些数据会一并发送出。比如，正被请求或编辑的内容的 ID，或是一个唯一的安全令牌。这些隐藏的 &amp;lt;input&amp;gt;元素在渲染完成的页面中完全不可见，而且没有方法可以使它重新变为可见。 隐藏域在页面中对于用户是不可见的，在表单中插入隐藏域的目的在于收集或发送信息，以利于被处理表单的程序所使用。浏览者单击发送按钮发送表单的时候，隐藏域的信息也被一起发送到服务器 有些时候要给用户一信息，在提交表单时一同提交,以确定用户身份，如 sessionkey 等．同样也可以用 cookie 实现，但使用隐藏域就简单的多了．兼容性好，且可以避免被禁用cookies 一个 form 里有多个提交按钮，怎样使程序能够分清楚到底用户是按那一个按钮提交上来的呢？ 这时可以添加隐藏域，然后在每一个按钮处加上 οnclick=&amp;ldquo;document.form.command.value=&amp;ldquo;xx&amp;rdquo;， 然后接到数据后先检查 command 的值就会知道用户是按的那个按钮提交上来的 一个网页中有多个 form，我们知道多个 form 是不能同时提交的，但有时这些 form 确实相互作用，我们就可以在 form 中添加隐藏域来使它们联系起来 JavaScript Question: 原生 Math 的方法有哪些 常用方法
Math.abs(num) // num绝对值 Math.ceil(num) // num向上取整 Math.floor(num) // num向下取整 Math.max(num1, num2 ...) // 取较大值 Math.min(num1, num2 ...) // 取较小值 Math.pow(num1, num2) // num1的num2次幂 Math.</description></item></channel></rss>