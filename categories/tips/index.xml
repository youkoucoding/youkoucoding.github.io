<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tips on 技術の手帳</title><link>https://youkoucoding.github.io/categories/tips/</link><description>Recent content in Tips on 技術の手帳</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 12 May 2022 23:42:06 +0900</lastBuildDate><atom:link href="https://youkoucoding.github.io/categories/tips/index.xml" rel="self" type="application/rss+xml"/><item><title>Frontend 250</title><link>https://youkoucoding.github.io/p/frontend-250/</link><pubDate>Thu, 12 May 2022 23:42:06 +0900</pubDate><guid>https://youkoucoding.github.io/p/frontend-250/</guid><description>HTML CSS PPI和DP PPI（pixel per inch）：像素密度，1 英寸屏幕上显示的像素量。值越高，屏幕越细腻
DP（Density-independent pixel）：安卓开发用的长度单位
1dp 等于屏幕像素密度为 160ppi 时 1px 的长度，因此 dp 在整个系统大小是固定的。
公式：1dp=（屏幕 ppi / 160）px。 JavaScript Reference fe-interview/history.md</description></item><item><title>毎日のフロントエンド 243~249</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-243~249/</link><pubDate>Wed, 11 May 2022 20:49:25 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-243~249/</guid><description>HTML 如何不让网页嵌入iframe HTTP 响应头信息中的X-Frame-Options，可以指示浏览器是否应该加载一个 iframe 中的页面。如果服务器响应头信息中没有 X-Frame-Options，则该网站存在 ClickJacking 攻击风险。网站可以通过设置 X-Frame-Options 阻止站点内的页面被其他页面嵌入从而防止点击劫持 deny：表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许 sameorigin：表示该页面可以在相同域名页面的 frame 中展示 allow-from uri：表示该页面可以在指定来源的 frame 中展示 CSS 代替 html5 中不再支持 table 的 cellspacing 和 cellpadding 属性 border-spacing em em em 是相对元素本身的 font-size 的相对单位，比如元素本身的 font-size 是 14px，那么 1.2em = 1.2 * 14px = 16.8px。注意，是相对元素本身的 font-size，会随着元素的 font-size 的改变而改变
em 用于设置元素的 padding, margin, border-radius
useState Reference fe-interview/history.</description></item><item><title>毎日のフロントエンド 242</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-242/</link><pubDate>Tue, 10 May 2022 23:01:30 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-242/</guid><description>Tips useState state结构 useState 接收一个 initialState，同时返回一个 state 以及更新 state 的函数 不推荐将数据集中于一个 useState 避免重复计算 如果 initialState 为函数，则 useState 在初始化时会立刻执行该函数和获取函数的返回值，在没有任何返回值得情况下为 undefined 需要注意的是每次组件 re-render 都会导致 useState 中的函数重新计算，这里可以使用闭包函数来解决问题, 例如： 优化前：
const loop = () =&amp;gt; { console.log(&amp;#39;calc!&amp;#39;); let res = 0; for (let i = 0, len = 1000; i &amp;lt; len; i++) { res += i; } return res; }; const [value, setValue] = useState(loop()); 优化后：
// 优化后只有组件初始化时才会执行一遍loop函数 const App = () =&amp;gt; { const [value, setValue] = useState(() =&amp;gt; { return loop(); }); }; 更新 state 在某些情况下如果需要从上一个 state 来计算当前的 state，可能会想到使用下面优化前的方法。但是，需要注意的一点是在某些闭包的场景下面 count 可能不是最新的，这样会导致计算错误。这里推荐使用官方给出的方法。 优化前：</description></item><item><title>毎日のフロントエンド 241</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-241/</link><pubDate>Mon, 09 May 2022 23:33:18 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-241/</guid><description>HTML &amp;lt;a&amp;gt;除了用作跳转链接外，还有哪些用途 &amp;lt;a&amp;gt; - HTML（超文本标记语言） | MDN CSS vmax 和 vmin vmax和vmin都是相对于窗口大小的长度单位。 100vmax相当于 100%当前窗口长或者宽的长度，取其中最大值，vmin 反之。 如果 css 函数max()和min()普及后，100vmax 相当于 max(100vw, 100vh) 如vmin，可以在确保在保持宽高比的情况下，不论窗口如何缩放都可以不让元素超出窗口范围 Tips try..catch 不能捕获的错误有哪些 try
每个try块必须与至少一个catch或finally块，否则会抛出SyntaxError错误 try..catch 与 无效代码
try..catch 无法捕获无效的 JS 代码，例如 try 块中的以下代码在语法上是错误的，但它不会被 catch 块捕获 try { ~!$%^&amp;amp;* } catch(err) { console.log(&amp;#34;不会执行&amp;#34;); } try..catch 与 异步代码 try..catch 无法捕获在异步代码中引发的异常，例如 setTimeout： try { setTimeout(function () { noSuchVariable; // undefined variable }, 1000); } catch (err) { console.</description></item><item><title>毎日のフロントエンド 232~240</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-232~240/</link><pubDate>Sun, 08 May 2022 17:39:28 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-232~240/</guid><description>HTML table 由哪几部分组成 &amp;lt;table&amp;gt;&amp;lt;/table&amp;gt; &amp;lt;tbody&amp;gt;&amp;lt;/tbody&amp;gt; &amp;lt;th&amp;gt;&amp;lt;/th&amp;gt; &amp;lt;tr&amp;gt;&amp;lt;/tr&amp;gt; &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;!-- 定义表格的标题 --&amp;gt; &amp;lt;caption&amp;gt;&amp;lt;/caption&amp;gt; &amp;lt;!-- 定义表格的页脚 --&amp;gt; &amp;lt;tfoot&amp;gt;&amp;lt;/tfoot&amp;gt; &amp;lt;!-- 定义表格的页眉 --&amp;gt; &amp;lt;thead&amp;gt;&amp;lt;/thead&amp;gt; &amp;lt;!-- 定义用于表格列的属性 --&amp;gt; &amp;lt;col&amp;gt;&amp;lt;/col&amp;gt; &amp;lt;!-- 定义表格列的组 --&amp;gt; &amp;lt;colgroup&amp;gt;&amp;lt;/colgroup&amp;gt; CSS 模拟边框跟 border 效果一样 outline, 伪元素, box-shadow class 和 id 选择器 id具有唯一性，导致样式不能重用，且权重大，容易导致权重问题。不过用 id 来选择元素的效率比 class 高, 不推荐使用id选择器 兼容浏览器的前缀 -webkit- 谷歌 -moz- 火狐 -o- opera -ms- ie Reference haizlin/fe-interview
outline - CSS（层叠样式表） | MDN</description></item><item><title>毎日のフロントエンド 231</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-231/</link><pubDate>Sat, 07 May 2022 20:40:49 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-231/</guid><description>CSS padding和margin是相对于父元素还是子元素 padding和margin被设置为百分比的时候，这个百分比是相对于它们的包含块元素的宽度 包含块 大多数情况下，包含块就是这个元素最近的祖先块元素的内容区，但也不是总是这样
包含块有分为根元素包含块和其他元素的包含块 根元素包含块 根元素 html 的包含块是一个矩形,叫做初始化包含块(initial containing block) html外面还有空间，这个包含 html 的块就被称为初始包含块(initial containing block)，它是作为元素绝对定位和固定定位的参照物 对于连续媒体设备（continuous media），初始包含块的大小等于视口 viewport 的大小，基点在画布的原点（视口左上角） 对于分页媒体（paged media），初始包含块是页面区域（page area）, 初始包含块的 direction 属性与根元素的相同 其他元素的包含块 大多数情况下，包含块就是这个元素最近的祖先块元素的内容区 确定包含块的过程完全依赖于这个包含块的 position 属性，大致分为下列场景： 如果 position 属性是 static 或 relative 的话，包含块就是由它的最近的祖先块元素（比如说 inline-block, block 或 list-item 元素）或格式化上下文 BFC(比如说 a table container, flex container, grid container, or the block container itself)的内容区的边缘组成的 如果 position 属性是 absolute 的话，包含块就是由它的最近的 position 的值不是 static （fixed, absolute, relative, or sticky）的祖先元素的内边距区的边缘组成的 如果 position 属性是 fixed 的话，包含块就是由 viewport (in the case of continuous media) or the page area (in the case of paged media) 组成的 如果 position 属性是 absolute 或 fixed，包含块也可能是由满足以下条件的最近父级元素的内边距区的边缘组成的： transform or perspective value other than none will-change value of transform or perspective filter value other than none or a will-change value of filter (only works on Firefox).</description></item><item><title>毎日のフロントエンド 226(227)(228)(229)(230)</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-226227228229230/</link><pubDate>Fri, 06 May 2022 22:16:05 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-226227228229230/</guid><description>HTML html 规范 - Tips 标签名和属性推荐用小写 标签都需闭合，不管是单标签还是双标签 双标签不宜使用单标签闭合方式 属性值需双引号 img 标签需加上 alt img 标签推荐加上固定宽高 html 和 body 标签最好不好 部分字符推荐转义，比如 &amp;lt; link 写在 head 内，script 写在 body 内 末尾 不推荐使用已废弃的标签和属性名，比如 marquee center 等 推荐使用语义化标签 meta里设置有意义的title，keyword，description CSS css 规范 - Tips 命名规范（连字符-分隔的字符串） 文件宽度限制（每行 80 个字符） 加注释 编写选择器应有助于重用 尽量不要加 !important 避免使用 CSS 表达式 选择&amp;lt;link&amp;gt; 舍弃 @import 避免使用滤镜（IE 专有的 AlphaImageLoader 滤镜） 把样式表放在顶部 / 把 CSS 放在外部文件 压缩 CSS 不建议使用@import @import 属于 CSS，所以导入语句应写在 CSS 中，要注意的是导入语句应写在样式表的开头，否则无法正确导入外部文件； @import 是 CSS2.</description></item><item><title>毎日のフロントエンド 225</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-225/</link><pubDate>Thu, 05 May 2022 22:07:05 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-225/</guid><description>Tips offsetWidth、clientWidth、scrollWidth 三者的区别 offsetWidth: 对象整体的实际宽度，包滚动条等边线，会随对象显示大小的变化而改变
offsetWidth = contentWidth + padding * 2 + border * 2 + scrollbar
offsetWidth
clientWidth: 对象内容的可视区的宽度，不包滚动条等边线，会随对象显示大小的变化而改变
clientWidth = contentWidth + padding * 2
clientWidth
scrollWidth：对象的实际内容的宽度，不包边线宽度，会随对象中内容超过可视区后而变大
scrollWidth = contentWidth + padding * 2
scrollWidth
Reference haizlin/fe-interview
HTMLElement.offsetWidth - Web API 接口参考 | MDN</description></item><item><title>毎日のフロントエンド 224</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-224/</link><pubDate>Wed, 04 May 2022 23:14:56 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-224/</guid><description>JavaScript typeof NaN typeof NaN 结果是 &amp;rsquo;number' == 和 === 不能被用来判断一个值是否是 NaN。必须使用 Number.isNaN() 或 isNaN() 函数。在执行自比较之中：NaN，也只有 NaN，比较之中不等于它自己 NaN === NaN; // false Number.NaN === NaN; // false isNaN(NaN); // true isNaN(Number.NaN); // true function valueIsNaN(v) { return v !== v; } valueIsNaN(1); // false valueIsNaN(NaN); // true valueIsNaN(Number.NaN); // true Tips 函数式编程 Tips 在函数式编程中，函数就是一个管道（pipe） 输入一个值，就会输出来一个新的值，没有其他作用
函数的合成与柯里化 COMPOSE 如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做&amp;quot;函数的合成&amp;quot;（compose） 函数的合成还必须满足结合律 函数就像数据的管道（pipe）。那么，函数合成就是将这些管道连了起来，让数据从多个管道中穿过 CURRY 所谓&amp;quot;柯里化&amp;quot;，就是把一个多参数的函数，转化为单参数函数 Reference haizlin/fe-interview</description></item><item><title>毎日のフロントエンド 223</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-223/</link><pubDate>Tue, 03 May 2022 14:30:23 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-223/</guid><description>Tips tsconfig.json 配置 The presence of a tsconfig.json file in a directory indicates that the directory is the root of a TypeScript project. The tsconfig.json file specifies the root files and the compiler options required to compile the project.
compilerOptions 编译选项是 TypeScript 配置的核心部分，compilerOptions 内的配置根据功能可以分为: target
target 选项用来指定 TypeScript 编译代码的目标，不同的目标将影响代码中使用的特性是否会被降级 target 的可选值包括 ES3、ES5、ES6、ES7、ES2017、ES2018、ES2019、ES2020、ESNext target 的默认值为 ES3，如果不配置选项的话，代码中使用的 ES6 特性，比如箭头函数会被转换成等价的函数表达式 module
module 选项可以用来设置 TypeScript 代码所使用的模块系统 如果 target 的值设置为 ES3、ES5 ，那么 module 的默认值则为 CommonJS； 如果 target 的值为 ES6 或者更高，那么 module 的默认值则为 ES6 module 还支持 ES2020、UMD、AMD、System、ESNext、None 的选项 jsx</description></item><item><title>毎日のフロントエンド 222</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-222/</link><pubDate>Mon, 02 May 2022 23:24:53 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-222/</guid><description>HTML HTML5 对元素内容进行拼写检查 spellcheck 定义是否可以检查元素的拼写错误 true: 设置在可能的情况下会去检查元素内容的拼写错误; false: 设置在可能的情况下关闭对元素内容拼写检查。 如果没有设置这个属性，默认值由元素自身类型和浏览器设置决定。默认值也可以被继承，当有祖先元素的 spellcheck 设置为 true 的情况下，子元素的默认值也是 true。 ps:
contenteditable: 是一个枚举属性，表示元素是否可被用户编辑。如果可以，浏览器会修改元素的部件以允许编辑: true 或空字符串，表示元素是可编辑的 false 表示元素不是可编辑的 CSS css 实现饼图 方法一： 使用伪元素 + transform + css 渐变实现
.pie { width: 100px; height: 100px; border-radius: 50%; background: yellowgreen; background-image: linear-gradient(to right, transparent 50%, #655 0); } .pie::before { content: &amp;#39;&amp;#39;; display: block; margin-left: 50%; height: 100%; border-radius: 0 100% 100% 0 / 50%; background-color: inherit; transform-origin: left; transform: rotate(0.</description></item><item><title>毎日のフロントエンド 221</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-221/</link><pubDate>Sun, 01 May 2022 22:26:24 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-221/</guid><description>HTML wbr 和 br 标签的区别 wbr (word break opportunity)规定在文本的何处进行添加换行符, wbr 是用来实现连续英文和数字的精准换行的，具体效果是如果宽度足够就不换行，如果宽度不足则在 wbr 元素在的位置进行换行。 它创建了一个带有换行特性的宽度为 0px 的空格。这个空格的 Unicode 编码是 U+200B，因此这个标签也可以替换为 &amp;amp;#x200b br是整行换行, 表示必须换行 CSS css 实现左右拉伸拖动 .class { resize: horizontal; } Tips GIT 场景一：添加到一个新的修改，到最新的 commit 中 # 添加这个对应的小的修改 git add . # 提交并且使用两个特殊的参数 # --amend 修改最新的一次 commit，将现在 staged change 直接添加到上一次 commit 去，不生成新的 commit # --no-edit amend 的提交不修改提交信息 git commit --amend --no-edit # 修改上一次commit的message git commit --amend 场景二：Git 时光机： reflog + reset # 显示你的 git 操作记录 # git log 有很大区别，它不仅仅是提交的记录，还有其他git的操作记录 git reflog # 会看到一系列的操作记录 # 7b6e4f8 HEAD@{0} # e7d2c90 HEAD@{1} .</description></item><item><title>毎日のフロントエンド 220</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-220/</link><pubDate>Sat, 30 Apr 2022 20:39:00 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-220/</guid><description>CSS CSS表达式 attr() CSS 表达式 attr() 用来获取选择到的元素的某一 HTML 属性值，并用于其样式。它也可以用于伪元素，属性值采用伪元素所依附的元素。
语法: attr( attribute-name &amp;lt;type-or-unit&amp;gt;? [, &amp;lt;fallback&amp;gt; ]? )
&amp;lt;p data-foo=&amp;#34;hello&amp;#34;&amp;gt;world&amp;lt;/p&amp;gt; p:before { content: attr(data-foo) &amp;#39; &amp;#39;; } result: hello world TIps TypeScript Move some complex &amp;ldquo;Extract&amp;rdquo; logic to a generic slot, meaning it only gets calculated once. export type Obj = { a: &amp;#39;FOO&amp;#39;; a2: &amp;#39;a2&amp;#39;; a3: &amp;#39;a3&amp;#39;; b: &amp;#39;b&amp;#39;; b1: &amp;#39;b1&amp;#39;; b2: &amp;#39;b2&amp;#39;; }; type ValuesOfKeysStartingWithA&amp;lt;Obj&amp;gt; = { [K in Extract&amp;lt;keyof Obj, `a${string}`&amp;gt;]: Obj[K]; }[Extract&amp;lt;keyof Obj, `a${string}`&amp;gt;]; type NewUnion = ValuesOfKeysStartingWithA&amp;lt;Obj&amp;gt;; Solution export type Obj = { a: &amp;#39;FOO&amp;#39;; a2: &amp;#39;a2&amp;#39;; a3: &amp;#39;a3&amp;#39;; b: &amp;#39;b&amp;#39;; b1: &amp;#39;b1&amp;#39;; b2: &amp;#39;b2&amp;#39;; }; type ValuesOfKeysStartingWithA&amp;lt; Obj, _ExtractedKeys extends keyof Obj = Extract&amp;lt;keyof Obj, `a${string}`&amp;gt; &amp;gt; = { [K in _ExtractedKeys]: Obj[K]; }[_ExtractedKeys]; type NewUnion = ValuesOfKeysStartingWithA&amp;lt;Obj&amp;gt;; Playground Link Reference haizlin/fe-interview</description></item><item><title>毎日のフロントエンド 219</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-219/</link><pubDate>Fri, 29 Apr 2022 20:46:00 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-219/</guid><description>Tips TypeScript dynamic elements interface Animal { name: string; } interface Human { firstName: string; lastName: string; } export const getDisplayName = (item: Animal): { displayName: string } =&amp;gt; { return { displayName: item.name }; }; const result = getDisplayName({ name: &amp;#39;PATCH&amp;#39; }); Generic Solution 当函数在调用的时候前不能确定传入的数据的类型，可用泛型 尤其如此例中，需要跟据不同参数类型返回不同的类型 interface Animal { name: string; } interface Human { firstName: string; lastName: string; } export const getDisplayName = &amp;lt;TItem extends Animal | Human&amp;gt;( item: TItem ): TItem extends Human ?</description></item><item><title>毎日のフロントエンド 218</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-218/</link><pubDate>Thu, 28 Apr 2022 23:30:17 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-218/</guid><description>CSS CSS 下兼容性的元素水平/垂直翻转实现 /*水平翻转*/ .flipx { -moz-transform: scaleX(-1); -webkit-transform: scaleX(-1); -o-transform: scaleX(-1); transform: scaleX(-1); /*IE*/ filter: FlipH; } /*垂直翻转*/ .flipy { -moz-transform: scaleY(-1); -webkit-transform: scaleY(-1); -o-transform: scaleY(-1); transform: scaleY(-1); /*IE*/ filter: FlipV; } 对于基于 webkit 核心的浏览器，如 Chrome 以及 Safari，实现元素的垂直翻转或是水平翻转也可以使用如下样式: /*水平翻转*/ .flipx { transform: rotateY(180deg); } /*垂直翻转*/ .flipy { transform: rotateX(180deg); } 水平翻转或垂直翻转不同于旋转 180 度。前者以轴为镜像，后者以点为镜像; 如果是对称元素，旋转 180 度和翻转的显示效果基本上就是一致的，但非对称元素就会看到明显差异; 目前仅 webkit 核心浏览器支持的 rotateY(180deg)，大写的 Y, 这里的 Y 表示元素以纵轴为镜像翻转，也就是水平翻转 Tips TypeScript Assertion functions inside classes</description></item><item><title>毎日のフロントエンド 217</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-217/</link><pubDate>Wed, 27 Apr 2022 23:04:13 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-217/</guid><description>HTML 页面加载后，表单的第一个文本框如何自动获得焦点 &amp;lt;input type=&amp;quot;text&amp;quot; autofocus/&amp;gt;
&amp;lt;input id=&amp;quot;input&amp;quot; type=&amp;quot;text&amp;quot;/&amp;gt; document.getElementById('input').focus();
CSS :not()的使用场景 :not() 用来匹配不符合一组选择器的元素。由于它的作用是防止特定的元素被选中，它也被称为反选伪类（negation pseudo-class） /* 子级之间留 10px 空隙 */ .gap-right-10 &amp;gt; :not(:last-child) { margin-right: 10px; } /* 有数据时加上标题 */ .list-wrap:not(:empty):before { content: attr(data-title); } /* flex 容器中都不压缩宽度 */ .flex-row { display: flex; align-items: center; &amp;amp; &amp;gt; .grow { flex-grow: 1; } &amp;amp; &amp;gt; :not(.grow) { flex-shrink: 0; } } JavaSctript 举例说明 js 创建数组有哪些方法 const arr = [.</description></item><item><title>毎日のフロントエンド 216</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-216/</link><pubDate>Tue, 26 Apr 2022 23:16:47 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-216/</guid><description>Tips TypeScript Mapping over a union type can feel tricky to conceptualise. Distributive Conditional Types export type Letters = &amp;#39;a&amp;#39; | &amp;#39;b&amp;#39; | &amp;#39;c&amp;#39;; type RemoveC&amp;lt;TType&amp;gt; = any; type WowWithoutC = RemoveC&amp;lt;Letters&amp;gt;; Solution // RemoveC - a type helper to remove &amp;#34;c&amp;#34; from a union of letters. export type Letters = &amp;#39;a&amp;#39; | &amp;#39;b&amp;#39; | &amp;#39;c&amp;#39;; // extends 会将union type 中的每一个类型 进行对比 type RemoveC&amp;lt;TType&amp;gt; = TType extends &amp;#39;c&amp;#39; ?</description></item><item><title>毎日のフロントエンド 215</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-215/</link><pubDate>Mon, 25 Apr 2022 21:24:44 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-215/</guid><description>CSS 图片宽度自适应 object-fit: contain; Tips TypeScript The &amp;ldquo;noUncheckedIndexedAccess&amp;rdquo; is the most awesome config option you&amp;rsquo;ve never heard of. It makes accessing objects a lot safer, and also powers up TypeScript&amp;rsquo;s inference on Objects. export const myObj: Record&amp;lt;string, string[]&amp;gt; = {}; myObj.foo.push(&amp;#39;bar&amp;#39;); // get an error Solution // tsconfig.json { &amp;#34;noUncheckedIndexedAccess&amp;#34;: true } export const myObj: Record&amp;lt;string, string[]&amp;gt; = {}; if (!myObj.foo) { myObj.foo = []; } myObj.</description></item><item><title>毎日のフロントエンド 214</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-214/</link><pubDate>Sun, 24 Apr 2022 17:21:29 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-214/</guid><description>HTML required属性 The Boolean required attribute, if present, indicates that the user must specify a value for the input before the owning form can be submitted. If present on any of these input types and elements, the :required pseudo class will match. If the attribute is not included, the :optional pseudo class will match. CSS 文本的竖向排版 writing-mode Tips TypeScript Use Generics to dynamically specify the number, and type, of arguments to functions export type Event = | { type: &amp;#39;LOG_IN&amp;#39;; payload: { userId: string; }; } | { type: &amp;#39;SIGN_OUT&amp;#39;; }; const sendEvent = (eventType: Event[&amp;#39;type&amp;#39;], payload?</description></item><item><title>毎日のフロントエンド 213</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-213/</link><pubDate>Sat, 23 Apr 2022 20:15:50 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-213/</guid><description>Tips TypeScript declare global is super useful too for when you want to allow types to cross module boundaries declare global { interface GlobalReducerEvent {} } export type GlobalReducer&amp;lt;TState&amp;gt; = ( state: TState, event: { [EventType in keyof GlobalReducerEvent]: { type: EventType; } &amp;amp; GlobalReducerEvent[EventType]; }[keyof GlobalReducerEvent] ) =&amp;gt; TState; export const todosReducer: GlobalReducer&amp;lt;{ todos: { id: string }[] }&amp;gt; = (state, event) =&amp;gt; { return state; };</description></item><item><title>毎日のフロントエンド 212</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-212/</link><pubDate>Fri, 22 Apr 2022 21:57:53 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-212/</guid><description>HTML 如何自动转移到新的页面 &amp;lt;head&amp;gt;内引入
&amp;lt;meta http-equiv=&amp;quot;refresh&amp;quot; content=&amp;quot;0; url=http://example.com/&amp;quot;&amp;gt;
content 内第一个参数是延迟，单位秒，0 为立即跳转 参数 url 是跳转地址 Tips DRY Use typeof import('./') to grab the type of any module, even third-party ones. // src/demo/constants.ts export const ADD_TODO = &amp;#39;ADD_TODO&amp;#39;; export const REMOVE_TODO = &amp;#39;REMOVE_TODO&amp;#39;; export const EDIT_TODO = &amp;#39;EDIT_TODO&amp;#39;; export type ActionModule = typeof import(&amp;#39;./contants&amp;#39;); export type Action = ActionModul[keyof ActionModule]; // type Action = &amp;#39;ADD_TODO&amp;#39; | &amp;#39;REMOVE_TODO&amp;#39; | &amp;#39;EDIT_TODO&amp;#39; Reference haizlin/fe-interview</description></item><item><title>毎日のフロントエンド 211</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-211/</link><pubDate>Thu, 21 Apr 2022 22:36:12 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-211/</guid><description>CSS clear属性取值 clear CSS 属性指定一个元素是否必须移动(清除浮动后)到在它之前的浮动元素下面。clear 属性适用于浮动和非浮动元素。 none 元素不会向下移动清除之前的浮动。 left 元素被向下移动用于清除之前的左浮动。 right 元素被向下移动用于清除之前的右浮动。 both 元素被向下移动用于清除之前的左右浮动。 inline-start 该关键字表示该元素向下移动以清除其包含块的起始侧上的浮动。即在某个区域的左侧浮动或右侧浮动。 inline-end 该关键字表示该元素向下移动以清除其包含块的末端的浮点，即在某个区域的右侧浮动或左侧浮动。 Tips TypeScript LooseAutocomplete which gives us autocomplete while also allowing arbitrary values type IconSize = &amp;#39;sm&amp;#39; | &amp;#39;xs&amp;#39;; interface IconProps { size: IconSize; } export const Icon = (props: IconProps) =&amp;gt; { return &amp;lt;&amp;gt;&amp;lt;/&amp;gt;; }; const Comp1 = () =&amp;gt; { return ( &amp;lt;&amp;gt; &amp;lt;Icon size=&amp;#39;xs&amp;#39;&amp;gt;&amp;lt;/Icon&amp;gt; &amp;lt;Icon size=&amp;#39;something&amp;#39;&amp;gt;&amp;lt;/Icon&amp;gt; // arbitrary value right here.</description></item><item><title>毎日のフロントエンド 210</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-210/</link><pubDate>Wed, 20 Apr 2022 21:14:59 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-210/</guid><description>CSS :link、:visited、:hover、:active的执行顺序 :link(未访问链接)，:visited(已访问的链接)，:hover(鼠标悬停)，:active(鼠标按下)
a标签伪类 正确的顺序 是：lvha(:link&amp;ndash;&amp;gt;:visited&amp;ndash;&amp;gt;:hover&amp;ndash;&amp;gt;:active)
同等优先权的样式，写在后边的会覆盖前边 a 标签的伪类结合了不同的动作顺序，动作的触发顺序决定了伪类的顺序必须按 lvha 来写 前 2 者两种状态是常态，而后 2 者是即时状态，当即时状态触发时，要覆盖常态，所以2 个即时状态要放在后边 在常态下：如果 a 标签被访问过后，就要呈现被访问过的状态，所以 visited 要放在 link 后边； 鼠标按下时，伴随着悬停的 a 标签上，所以要想 active 覆盖 hover，就必须把 active 放后边； :link 和 a 的样式有可能会冲突
当 标签的 href 属性为空的时候，:link 样式不会生效；当 标签的 href 属性不为空的时候，:link 样式才会生效，这时候，如果 标签正常样式 和 a：link 冲突了的话，以写在后面的那个为准
Tips TypeScript Deep Partial type DeepPartial&amp;lt;Thing&amp;gt; = Thing extends Function ?</description></item><item><title>毎日のフロントエンド 209</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-209/</link><pubDate>Mon, 18 Apr 2022 23:37:56 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-209/</guid><description>Tips TypeScript A runtime check in a function to the tyoe level. export const deepEqualCompare = &amp;lt;Arg&amp;gt;(a: Arg, b: Arg): boolean =&amp;gt; { if (Array.isArray(a) || Array.isArray(b)) { throw new Error(&amp;#39;You cannot compare two arrays using deepEqualCompare&amp;#39;); } return a === b; }; deepEqualCompare(1, 1); deepEqualCompare([], [&amp;#39;a&amp;#39;]); // this gonna always be false Solution type CheckForBadArgs&amp;lt;Arg&amp;gt; = Arg extends any[] ? &amp;#39;You cannot compare two arrays using deepEqualCompare&amp;#39; : Arg; export const deepEqualCompare = &amp;lt;Arg&amp;gt;( a: CheckForBadArgs&amp;lt;Arg&amp;gt;, b: CheckForBadArgs&amp;lt;Arg&amp;gt; ): boolean =&amp;gt; { if (Array.</description></item><item><title>毎日のフロントエンド 208</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-208/</link><pubDate>Sun, 17 Apr 2022 14:48:54 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-208/</guid><description>CSS FONT 字体的分类 字体族，是一系列字体的集合: serif(衬线) sans-serif(无衬线) monospace(等宽) fantasy(梦幻) cuisive(草体) serif(衬线字体) sans-serif(无衬线字体) Serif的意思是，在字的笔划开始及结束的地方有额外的装饰，而且笔画的粗细会有所不同。衬线字体的风格都比较突出，常见的衬线字体有 Times New Roman、宋体。 Sans Serif字体没有这些额外的装饰，笔划粗细大致差不多，字形端庄，横平竖直，常见的无衬线字体有 Tahoma、Verdana、Arial、Helvetica、苹方、微软雅黑等等 monospace(等宽字体)等宽字体是指字符宽度相同的字体，通常用于编辑器以及技术文章的代码块中，等宽主要针对西文字体，而对于中文每个字都是等宽的，courier 是最常见的等宽字体 font-family属性 设置元素的字体，可以同时指定多个，如果浏览器不支持第一个字体，则会尝试下一个，可以设置字体或字体系列。font-family: Arial, sans-serif; 不设置 font-family 则使用浏览器默认字体，如果设置的 font-family 无效，也会 fallback 到浏览器的默认字体 常见字体 Helvetica 苹果系统支持的一种西文无衬线字体，是苹果生态中最常用的一套西文字体。Helvetica Neue 是 Helvetica 字体改善版，增加了更多不同粗细与宽度的字形 Arial 是为了与 Helvetica 竞争而设计的无衬线西文字体，表现形式和 Helvetica 类似，在不同系统的浏览器都支持，兼容性非常好 Tahoma 一种无衬线字体，间距较小，在不同系统的浏览器都支持，兼容性良好，可以解决 Helvetica 和 Arial 所为人诟病的缺点，比如大写的 I 和小写的 L 难以分辨。 San Francisco 苹果于 2017 年推出一种无衬线字体，也是目前苹果系统的默认西文字体，相比于 Helvetica 字体，San Francisco 的字体风格更加简洁，减少了一些修饰的细节，支持符号的整体居中，比如时间显示，之前的 Helvetica 的冒号是不居中的 PingFang SC(苹方-简) 中文无衬线字体，在 2017 年和 San Francisco 一起推出，SC 代表简体，同时还有台湾繁体和香港繁体，整体造型简洁美观，是苹果系统默认的中文字体。 Hiragino Sans GB(冬青黑体)、Heiti SC(黑体) 苹果系统中较早的中文无衬线字体，为了兼容旧版 macOS 系统，我们一般用它们作为苹方字体的 fallback。 Segoe UI windows 系统下的一种无衬线西文字体，也是 windows 系统的默认西文字体。 Microsoft YaHei(微软雅黑) Windows 系统默认的中文字体，也是一套无衬线字体。macOS 上的浏览器大都预装微软雅黑，但不包括 safari 浏览器(ios 和 android 系统不支持微软雅黑，所以设置移动端字体时可以忽略微软雅黑) Roboto Android 系统的默认西文字体，也是一种无衬线字体 Noto Sans (思源黑体) Android 系统的默认中文无衬线字体，由 google 推出的一款开源字体 Apple Color Emoji 苹果产品的文字表情，在 Mac 和 iOS 系统都支持 Segoe UI Emoji Windows10 系统中的 Emoji 表情，黑描边风格，没有苹果的圆润和质感。 Noto Color Emoji Google 推出的表情，和苹果的较为类似，更加扁平 浏览器默认字体 默认字体分为系统默认字体(system-ui)和浏览器默认字体，这两者是不同的</description></item><item><title>毎日のフロントエンド 207</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-207/</link><pubDate>Sat, 16 Apr 2022 15:43:37 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-207/</guid><description>CSS filter 滤镜 filter 将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像、背景和边框的渲染。CSS 标准里包含了一些已实现预定义效果的函数。 Don&amp;rsquo;t Rely on CSS 100vh &amp;lt;div className=&amp;#34;layout&amp;#34;&amp;gt; &amp;lt;p&amp;gt;Lorem ipsum dolor sit amet...&amp;lt;/p&amp;gt; &amp;lt;button&amp;gt;Sign Up&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;style&amp;gt; .layout { display: flex; flex-direction: column; justify-content: space-between; min-height: 100vh; } &amp;lt;/style&amp;gt; 上述代码，可以在大多是情况下保证button, 位于页面底部
但是在移动端浏览器上会被浏览器的工具栏遮挡，原因是： html - CSS3 100vh not constant in mobile browser - Stack Overflow
Fix Code
&amp;lt;div className=&amp;#34;layout&amp;#34;&amp;gt; &amp;lt;p&amp;gt;Lorem ipsum dolor sit amet...&amp;lt;/p&amp;gt; &amp;lt;button&amp;gt;Sign Up&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;style&amp;gt; .</description></item><item><title>毎日のフロントエンド 206</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-206/</link><pubDate>Thu, 14 Apr 2022 23:39:27 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-206/</guid><description>HTML 移动端点击 300ms 的延迟出现的原因 早期 IOS 为了区分用户是双击缩放还是点击链接行为，于是就有了 300ms 延迟，其他浏览器效仿 引入fastclick 在meta禁用浏览器缩放 touch事件模拟 CSS 元素设置 background-color,它的颜色会填充哪些区域 background 填充区域默认为content、padding和border区域 该行为由background-clip属性决定，默认为border-box background-clip 设置元素的背景（背景图片或颜色）是否延伸到边框、内边距盒子、内容盒子下面 填充区域如下 background-clip margin border padding content text border-box (默认) ✘ ✔ ✔ ✔ - padding-box ✘ ✘ ✔ ✔ - content-box ✘ ✘ ✘ ✔ - text (webkit) ✘ ✘ ✘ ✘ ✔ JavaScript js 获取 DOM 元素的方法 document.</description></item><item><title>毎日のフロントエンド 205</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-205/</link><pubDate>Wed, 13 Apr 2022 22:06:42 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-205/</guid><description>HTML picture标签 &amp;lt;picture&amp;gt; 元素通过包含零或多个 &amp;lt;source&amp;gt; 元素和一个 &amp;lt;img&amp;gt; 元素来为不同的显示/设备场景提供图像版本。浏览器会选择最匹配的子 &amp;lt;source&amp;gt; 元素，如果没有匹配的，就选择 &amp;lt;img&amp;gt; 元素的 src 属性中的 URL。然后，所选图像呈现在元素占据的空间中。
&amp;lt;picture&amp;gt; 的常见使用场景：
艺术指导 (Art direction) —— 针对不同 media 条件裁剪或修改图像 遇到所有浏览器都不支持的特定格式时，提供不同的图像格式 JavaScript getElementById和querySelector方法的区别 Document的方法 getElementById()返回一个匹配特定 ID 的元素. 由于元素的 ID 在大部分情况下要求是独一无二的，这个方法自然而然地成为了一个高效查找特定元素的方法。 Document 引用的 querySelector()方法返回文档中与指定选择器或选择器组匹配的第一个 Element 对象。 如果找不到匹配项，则返回 null。 selectors:包含一个或多个要匹配的选择器的 DOM 字符串 DOMString。 该字符串必须是有效的 CSS 选择器字符串；如果不是，则引发 SYNTAX_ERR 异常。 Tips TypeScript The Looseness of Object.keys can be a real pain point when it comes to use typescript.</description></item><item><title>毎日のフロントエンド 204</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-204/</link><pubDate>Tue, 12 Apr 2022 22:27:42 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-204/</guid><description>Tips TypeScript Type Helpers - PropsFrom Helper - Get the props&amp;rsquo; type from the other Component import React from &amp;#39;react&amp;#39;; // function component const MyComponent = (props: { enabled: boolean }) =&amp;gt; { return null; }; //class component class MyOtherComponent extends React.Component&amp;lt;{ enabled: boolean; data: string; }&amp;gt; {} // implement the PropsFrom type PropsFrom&amp;lt;TComponent&amp;gt; = TComponent extends React.FC&amp;lt;infer Props&amp;gt; ? Props : TComponent extends React.Component&amp;lt;infer Props&amp;gt; ? Props : never; const props: PropsFrom&amp;lt;typeof MyComponent&amp;gt; = { enabled: true, }; Playground Link</description></item><item><title>毎日のフロントエンド 203</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-203/</link><pubDate>Mon, 11 Apr 2022 22:12:08 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-203/</guid><description>HTML canvas 的width与height属性的值可不可以带单位 width/height的属性值可以带单位且不会报错，但是无论是 px 还是 em、rem，表现都和 px 一致 CSS height和line-height line-height: 在日常用的最多的是让单行文字垂直居中（其实不需要设置 height，一个 line-height 即可）。因为 line-height - font-size 为行距，一般会近似平分到文字的上下两边，使文字看上去垂直居中。如果需要多行文字的垂直居中，还需要加上 vertical-align: middle; line-height 可以不设置单位，表示 font-size 的倍数 height 指定了一个元素的高度。默认情况下，这个属性决定的是内容区（ content area）的高度，但是，如果将 box-sizing 设置为 border-box , 这个属性决定的将是边框区域（border area）的高度。 Tips TypeScript The extends keyword: narrow the value of a generic to enable some autocomplete type of interface const getDeepValue = &amp;lt;Obj, FirstKey, SecondKey&amp;gt;( obj: Obj, firstKey: FirstKey, secondKey: SecondKey ) =&amp;gt; { return {} as any; }; // to const obj = { foo: { a: true, b: 2 }, bar: { c: &amp;#39;cool&amp;#39;, d: 2 }, }; const result = getDeepValue(obj, &amp;#39;bar&amp;#39;, &amp;#39;d&amp;#39;); Solution const getDeepValue = &amp;lt;Obj, FirstKey extends keyof Obj, SecondKey extends keyof Obj[FirstKey]&amp;gt;( obj: Obj, firstKey: FirstKey, secondKey: SecondKey ): Obj[FirstKey][SecondKey] =&amp;gt; { return {} as any; }; Playground Link</description></item><item><title>毎日のフロントエンド 202</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-202/</link><pubDate>Sun, 10 Apr 2022 21:21:26 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-202/</guid><description>HTML &amp;lt;dialog&amp;gt; HTML &amp;lt;dialog&amp;gt; 元素表示一个对话框或其他交互式组件，例如一个检查器或者窗口。 Attributes - 属性 open: 指示这个对话框是激活的和能互动的。当这个 open 特性没有被设置，对话框不应该显示给用户。(没有它，这个对话框就会隐藏起来，直到你使用 JavaScript 来显示它) returnValue: 用来获取 close 时传入的参数 方法： show() showModal() 两个方法相同点都是打开弹窗，即都会给 dialog 元素添加一个 open 属性。 不同点： 唯一区别是show()会按照其在 DOM 流中的位置显示 dialog，没有遮罩，而showModal()会出现遮罩， 并且自动做了按键监控，即点击 esc 键，弹窗会关闭 大多数情况下，使用便利的 showModal() 方法来而不使用 show()方法。 close() 会关闭弹窗，即会删除 open 属性，并且可以携带一个参数作为额外数据，传入的值可以通过 dialog.returnValue 获取。 两个事件: close: 当 modal 关闭的时候触发 cancel: 当按下 ESC 关闭模态框的时候触发 在各事件的事件对象 event.target 里，同样可以看到 close()方法传入的参数，即 event.</description></item><item><title>毎日のフロントエンド 201</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-201/</link><pubDate>Sat, 09 Apr 2022 17:15:55 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-201/</guid><description>HTML &amp;lt;p&amp;gt; &amp;lt;/p&amp;gt;会换两行 p { display: block; margin-block-start: 1em; margin-block-end: 1em; margin-inline-start: 0px; margin-inline-end: 0px; } 以上为p的用户代理 默认上下 margin 为 1em，所以等效于两行字那么高。 margin-block-start /end等效于上下外边距 margin-inline-start/end等效于左右外边距 CSS 伪类:focus-within的用法 :focus-within 是一个 CSS 伪类 ，表示一个元素获得焦点，或，该元素的后代元素获得焦点。换句话说，元素自身或者它的某个后代匹配 :focus 伪类。 /* 当 &amp;lt;div&amp;gt; 的某个后代获得焦点时，匹配 &amp;lt;div&amp;gt; */ div:focus-within { background: cyan; } JavaScript Object 与 Map 的异同及使用场景 Map Map 是一种数据结构（是一种抽象的数据结构类型），数据一对对进行存储，其中包含键以及映射到该键的值。并且由于键的唯一性，因此不存在重复的键值对。 Map 中的键和值可以是任何数据类型，不仅限于字符串或整数 Object JavaScript 中的常规对象是一种字典类型的数据结构——这意味着它依然遵循与 Map 类型相同键值对的存储结构。 Object 中的 key，或者我们可以称之为属性，同样是独一无二的并且对应着一个单独的 value。 JavaScript 中的 Object 拥有内置原型(prototype) JavaScript 中几乎所有对象都是 Object 实例，包括 Map Object 和 Map 的本质都是以键值对的方式存储数据，但实质上他们之间存在很大的区别： 键： Object遵循普通的字典规则，键必须是单一类型，并且只能是整数、字符串或是**Symbol类型**。 Map 中，key 可以为任意数据类型（包括Object, Array 等） 元素顺序：Map 会保留所有元素的顺序，而 Object 并不会保证属性的顺序。 继承：Map 是 Object 的实例对象，而 Object 显然不可能是 Map 的实例对象。 var map = new Map([ [1, 2], [3, 4], ]); console.</description></item><item><title>毎日のフロントエンド 200</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-200/</link><pubDate>Fri, 08 Apr 2022 22:18:38 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-200/</guid><description>HTML &amp;lt;p&amp;gt;和&amp;lt;br&amp;gt;的区别 &amp;lt;p&amp;gt;块级元素，&amp;lt;br&amp;gt; 内联元素； &amp;lt;p&amp;gt;能被 css 修改，&amp;lt;br&amp;gt; 不能； &amp;lt;p&amp;gt;非单标签元素，&amp;lt;br&amp;gt; 是单标签元素； &amp;lt;p&amp;gt;换行靠的是块级元素特性，&amp;lt;br&amp;gt; 换行靠的可能是类似 \n 的渲染规则 Tips JavaScript Accessing URL data using window.location in JavaScript //https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#mapping-modifiers window.location.hash; // &amp;#39;#mapping-modifiers&amp;#39; window.location.href; // &amp;#39;https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#mapping-modifiers&amp;#39; window.location.origin; // &amp;#39;https://www.typescriptlang.org&amp;#39; window.location.pathname; // &amp;#39;/docs/handbook/2/mapped-types.html&amp;#39; window.location.search; // &amp;#39;&amp;#39; TypeScript Transform a union to another union, using the in operator as a kind of for-loop type Entity = | { type: &amp;#39;user&amp;#39;; } | { type: &amp;#39;post&amp;#39;; } | { type: &amp;#39;comment&amp;#39;; }; // to implement below: type EntityWithId = | { type: &amp;#39;user&amp;#39;; userId: sting; } | { type: &amp;#39;post&amp;#39;; postId: string; } | { type: &amp;#39;comment&amp;#39;; commentId: string; }; solution: type EntityWithId = { [EntityType in Entity[&amp;#39;type&amp;#39;]]: { type: EntityType; } &amp;amp; Record&amp;lt;`${EntityType}Id`, string&amp;gt;; }[Entity[&amp;#39;type&amp;#39;]]; const result: EntityWithId = { type: &amp;#39;comment&amp;#39;, commentId: &amp;#39;12345&amp;#39;, }; Playground Link Reference haizlin/fe-interview</description></item><item><title>毎日のフロントエンド 198</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-198/</link><pubDate>Tue, 05 Apr 2022 22:53:47 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-198/</guid><description>CSS CSS 实现段落首字母或首字放大效果 ::first-letter 伪元素 div::first-letter { font-size: 24px; font-weight: bold; } text-transform &amp;lt;style&amp;gt; div { text-transform: capitalize; } &amp;lt;/style&amp;gt; &amp;lt;div&amp;gt;come on&amp;lt;/div&amp;gt; Tips npm ci 合理使用 npm ci 和 npm install npm ci 就是专门为 CI 环境准备的安装命令，相比 npm install 它的不同之处在于： npm ci 要求项目中必须存在 package-lock.json 或 npm-shrinkwrap.json； npm ci 完全根据 package-lock.json 安装依赖，这可以保证整个开发团队都使用版本完全一致的依赖； npm ci 完全根据 package-lock.json 安装依赖，在安装过程中，它不需要计算求解依赖满足问题、构造依赖树，因此安装过程会更加迅速； npm ci 在执行安装时，会先删除项目中现有的 node_modules，然后全新安装； npm ci 只能一次安装整个项目所有依赖包，无法安装单个依赖包； 如果 package-lock.json 和 package.</description></item><item><title>毎日のフロントエンド 197</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-197/</link><pubDate>Mon, 04 Apr 2022 16:21:24 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-197/</guid><description>HTML 举例说明&amp;lt;a&amp;gt;作用 打开链接 当前页面打开 &amp;lt;a href=&amp;quot;https://www.github.com&amp;quot;&amp;gt;test&amp;lt;/a&amp;gt; 新标签页打开 &amp;lt;a target=&amp;quot;_blank&amp;quot; href=&amp;quot;https://www.github.com&amp;quot;&amp;gt;test&amp;lt;/a&amp;gt; 文件下载 &amp;lt;a href=&amp;quot;https://codeload.github.com/vkboo/vue-svg-board/zip/master&amp;quot; download=&amp;quot;vue-board-svg-name&amp;quot;&amp;gt;vue-board-svg&amp;lt;/a&amp;gt; 利用 URL Scheme 打开 app &amp;lt;a href=&amp;quot;imeituan://xxx.xxx.xxx&amp;quot;&amp;gt;&amp;lt;/a&amp;gt; mailto &amp;amp; telto &amp;lt;a href=&amp;quot;mailto:xxx@site.com&amp;quot;&amp;gt;&amp;lt;/a&amp;gt; 锚点 &amp;lt;a href=&amp;quot;#content&amp;quot;&amp;gt;go to content&amp;lt;/a&amp;gt; &amp;lt;section id=&amp;quot;content&amp;quot;&amp;gt;&amp;lt;/section&amp;gt; CSS 段落的首行缩进 text-indent属性 能定义一个块元素首行文本内容之前的缩进量 长度值：px em rem 百分比：取决于包含块的 width 关键字： each-line：文本缩进会影响第一行，以及使用强制断行后的第一行； hanging：该值会对所有的行进行反转缩进：除了第一行之外的所有的行都会被缩进，看起来就像第一行设置了一个负的缩进值。 全局值：inherit initial unset /* &amp;lt;length&amp;gt; 长度值 */ text-indent: 3mm; text-indent: 40px; /* &amp;lt;percentage&amp;gt;百分比值取决于其包含块（containing block）的宽度*/ text-indent: 15%; /* 关键字 */ text-indent: 5em each-line; text-indent: 5em hanging; text-indent: 5em hanging each-line; /* 全局值 */ text-indent: inherit; text-indent: initial; text-indent: unset; JavaScript 找出一段话里面出现频率最多的单词 const mostOftenWord = (para) =&amp;gt; para .</description></item><item><title>毎日のフロントエンド 196</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-196/</link><pubDate>Sun, 03 Apr 2022 14:27:21 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-196/</guid><description>HTML 引用标签 &amp;lt;blockquote&amp;gt;：块级引用元素
&amp;lt;blockquote&amp;gt; 元素（或者 HTML 块级引用元素），代表其中的文字是引用内容。通常在渲染时，这部分的内容会有一定的缩进（注 中说明了如何更改） 若引文来源于网络，则可以将原内容的出处 URL 地址设置到 cite 特性上，若要以文本的形式告知读者引文的出处时，可以通过 &amp;lt;cite&amp;gt; 元素 &amp;lt;q&amp;gt;标签, 短引用
引用标签 (&amp;lt;q&amp;gt;) 表示一个封闭的并且是短的行内引用的文本。这个标签是用来引用短的文本，所以不要引入换行符; 对于长的文本的引用使用 &amp;lt;blockquote&amp;gt; 替代。 cite这个属性的值是 URL，意在指出被引用的文本的源文档或者源信息。这个属性重在解释这个引用的参考或者是上下文。 &amp;lt;p&amp;gt; Everytime Kenny is killed, Stan will announce &amp;lt;q cite=&amp;#34;http://en.wikipedia.org/wiki/Kenny_McCormick#Cultural_impact&amp;#34;&amp;gt; Oh my God, &amp;lt;/q&amp;gt;. &amp;lt;/p&amp;gt; Tips - Yarn Yarn 是一个由 Facebook、Google、Exponent 和 Tilde 构建的新的 JavaScript 包管理器。它的出现是为了解决历史上 npm 的某些不足（比如 npm 对于依赖的完整性和一致性保障，以及 npm 安装速度过慢的问题等），虽然 npm 目前经过版本迭代汲取了 Yarn 一些优势特点（比如一致性安装校验算法等），但依然有必要关注 Yarn 的思想和理念。</description></item><item><title>毎日のフロントエンド 195</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-195/</link><pubDate>Sat, 02 Apr 2022 23:46:45 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-195/</guid><description>HTML html 支持的数学符号有哪些 HTML 符号实体参考手册 CSS CSS 的标准发布流程 CSS 的标准化流程由 W3C Cascading Style Sheets Working Group (CSSWG)——W3C 层叠样式列表小组，由浏览器商，大学，大公司（google，IBM 等），以及独立 CSS 专家组成。
W3C 本身并不制定标准，而是作为一个论坛式的平台，接收来自小组成员的提交，并通过会议来商讨制定标准，所有的提交以及讨论都是公开透明的，可以在 W3C 网站上看到会议的记录，标准确定一般有 6 个阶段，其中两个是过渡阶段：
编辑草案 Editor&amp;rsquo;s Draft (ED) 这个是规范的开始阶段，一个 CSS 属性或者选择器被提出来，并在 CSSWG 内部研究。如果小组成员同意这个属性可以正式推出，它就能进入下一阶段。 工作草案 Working Draft (WD) 编辑草案后是工作草案，标准的设计阶段。小组反复处理来自 CSSWG 内部和来自小组外部的反馈，这个阶段有两个结果：一是可能会因为技术困难或者可能会引起其他问题而使新属性被完全拒绝；二是规范会通过这个阶段，并会作为第一次公开工作草案（ First Public Working Draft (FPWD)）发布，后面还会有数个工作草案，会处理来自 CSSWG 内部和小组外部更广泛社会的反馈。 过渡－最后通告工作草案 Transition – Last Call Working Draft (LCWD) 这是第一个过渡阶段，当规范开始考虑从工作草案进入到下一个阶段时，将会对新属性的一些小改动的反馈设置一个截止日期，LCWD 即是日期截至后最后的一次公开草案处理。 最重要的阶段是 ED, WD, and CR，其他阶段不是很重要。 候选推荐标准 Candidate Recommendation (CR) 规范会在这个阶段通过完整的测试，测试人员来自 CSSWG 以及被选为实现这个规范的浏览器生产商(Chrome, Safari, Firefox, Opera, 等等)。为了继续进入下一阶段，CSSWG 会推出两个正确的实现规范。 过渡－建议推荐标准 Transition – Proposed Recommendations (PR) 当到达这个阶段，W3C 全球资源小组：W3C 咨询委员会（W3C Advisory Committee），决定这个规范是否会继续进入下一个阶段。这个阶段一般很少有异议出现，所以也是一个过渡阶段而已。 推荐标准 Recommendation (REC) 如果规范到达这个阶段，说明规范已经考虑完备并可以让浏览器商实现，W3C 和 CSSWG 对这个规范的讨论处理不再活跃，只做一些必要的维护。 Tips 轮播图生成器 Image Slider Maker - Free Generator Tool Reference haizlin/fe-interview</description></item><item><title>毎日のフロントエンド 194</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-194/</link><pubDate>Fri, 01 Apr 2022 21:20:27 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-194/</guid><description>npm npm 内部机制和核心原理 Bring the best of open source to you, your team and your company.
npm 的安装机制 Ruby 的 Gem、Python 的 pip 都是全局安装，但是 npm 的安装机制秉承了不同的设计哲学： npm安装流程图
npm install 执行之后，首先，检查并获取 npm 配置，这里的优先级为： 项目级的 .npmrc 文件 &amp;gt; 用户级的 .npmrc 文件&amp;gt; 全局级的 .npmrc 文件 &amp;gt; npm 内置的 .npmrc 文件 然后检查项目中是否有 package-lock.json 文件 如果有，则检查 package-lock.json 和 package.json 中声明的依赖是否一致： 一致，直接使用 package-lock.json 中的信息，从缓存或网络资源中加载依赖； 不一致，按照 npm 版本进行处理（不同 npm 版本处理会有不同，具体处理方式如图所示） 如果没有，则根据 package.</description></item><item><title>毎日のフロントエンド 193</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-193/</link><pubDate>Thu, 31 Mar 2022 11:01:04 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-193/</guid><description>HTML dl、ul、ol三个标签的区别 dl 标签就是定义列表，英文的单词是 definition list definition title dt 列表的标题 这个标签是必须要的 definition description 列表的列表项，如果不需要它，可以不加 dd dt、dd 只能在 dl 里面；dl 里面只能有 dt、dd。 &amp;lt;dl&amp;gt; &amp;lt;dt&amp;gt;Firefox&amp;lt;/dt&amp;gt; &amp;lt;dd&amp;gt; A free, open source, cross-platform, graphical web browser developed by the Mozilla Corporation and hundreds of volunteers. &amp;lt;/dd&amp;gt; &amp;lt;!-- other terms and definitions --&amp;gt; &amp;lt;/dl&amp;gt; ul标签 无序列表 unordered list
无序列表中的每一项是 li 标签 li：list item，“列表项”的意思 ol标签 有序列表 ol 英文单词：Ordered List</description></item><item><title>毎日のフロントエンド 190</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-190/</link><pubDate>Mon, 28 Mar 2022 10:54:51 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-190/</guid><description>CSS 颜色中#F00 的每一位分别表示什么？为什么会有三位和六位的表示 颜色可以使用红-绿-蓝（red-green-blue (RGB)）模式的两种方式被定义： 十六进制符号 #RRGGBB 和 #RGB 三位数的 RGB 符号（#RGB）和 六位数的形式（#RRGGBB）是相等的。 #f03 和 #ff0033 代表同样的颜色 JavaScript 原生 js 实现类似getElementsByClassName的方法，不使用querySelectorAll function getElementsByClassName(className) { const tags = document.getElementsByTagName(&amp;#39;*&amp;#39;); const tempTags = []; for (let i = 0, len = tags.length; i &amp;lt; len; i++) { let tag = tags[i]; tag.classList.contains(className) &amp;amp;&amp;amp; tempTags.push(tag); } return tempTags; } Reference haizlin/fe-interview
Document.getElementsByTagName() - Web API 接口参考 | MDN</description></item><item><title>毎日のフロントエンド 189</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-189/</link><pubDate>Sun, 27 Mar 2022 14:26:42 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-189/</guid><description>JavaScript 将 html 页面生成为图片 niklasvh/html2canvas: Screenshots with JavaScript Tips X-Frame-Options X-Frame-Options HTTP 响应头是用来给浏览器 指示允许一个页面 可否在 &amp;lt;frame&amp;gt;, &amp;lt;iframe&amp;gt;, &amp;lt;embed&amp;gt; 或者 &amp;lt;object&amp;gt; 中展现的标记。 X-Frame-Options: deny X-Frame-Options: sameorigin X-Frame-Options: allow-from https://example.com/ deny表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。 sameorigin 表示该页面可以在相同域名页面的 frame 中展示。 allow-from uri 表示该页面可以在指定来源的 frame 中展示。 Referer Referer 请求头包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。 服务端一般使用 Referer 请求头识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化 Node.js 实现原理 Node.js 的依赖模块
acorn：前面的课程中已经提过，用 JavaScript 编写的轻量级 JavaScript 解析器。 acorn-plugins：acorn 的扩展模块，让 acorn 支持 ES6 特性解析，比如类声明。 brotli：C 语言编写的 Brotli 压缩算法。 cares：应该写为“c-ares”，C 语言编写的用来处理异步 DNS 请求。 histogram：C 语言编写，实现柱状图生成功能。 icu-small：C 语言编写，为 Node.</description></item><item><title>毎日のフロントエンド 188</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-188/</link><pubDate>Sat, 26 Mar 2022 17:20:33 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-188/</guid><description>HTML PNG 格式 什么是 PNG PNG 的全称叫便携式网络图型（Portable Network Graphics）是目前最流行的网络传输和展示的图片格式，原因有如下几点： 无损压缩：PNG 图片采取了基于 LZ77 派生算法对文件进行压缩，使得它压缩比率更高，生成的文件体积更小，并且不损失数据。 体积小：它利用特殊的编码方法标记重复出现的数据，使得同样格式的图片，PNG 图片文件的体积更小。网络通讯中因受带宽制约，在保证图片清晰、逼真的前提下，优先选择 PNG 格式的图片。 支持透明效果：PNG 支持对原图像定义 256 个透明层次，使得图像的边缘能与任何背景平滑融合，这种功能是 GIF 和 JPEG 没有的。 PNG 类型 PNG 8：PNG 8 中的 8，其实指的是 8bits，相当于用 2^8（2 的 8 次方）大小来存储一张图片的颜色种类，2^8 等于 256，也就是说 PNG 8 能存储 256 种颜色，一张图片如果颜色种类很少，将它设置成 PNG 8 得图片类型是非常适合的。
PNG 24：PNG 24 中的 24，相当于 3 乘以 8 等于 24，就是用三个 8bits 分别去表示 R（红）、G（绿）、B（蓝）。R(0~255),G(0~255),B(0~255)，可以表达 256 乘以 256 乘以 256=16777216 种颜色的图片，这样 PNG 24 就能比 PNG 8 表示色彩更丰富的图片。但是所占用的空间相对就更大了。</description></item><item><title>毎日のフロントエンド 187</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-187/</link><pubDate>Fri, 25 Mar 2022 14:19:54 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-187/</guid><description>JavaScript FileReader FileReader 对象允许 Web 应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据 Tips 前端性能指标 首屏绘制（First Paint，FP） 首屏绘制时间是指从开始加载到浏览器首次绘制像素到屏幕上的时间，也就是页面在屏幕上首次发生视觉变化的时间。 首屏绘制不包括默认的背景绘制，但包括非默认的背景绘制。由于首次绘制之前网页呈现默认背景白色，所以也俗称“白屏时间”。 在 HTML5 下可以通过 performance API 来获取首屏绘制时间 performance.getEntriesByType(&amp;#39;paint&amp;#39;)[0]; /* { duration: 0, entryType: &amp;#34;paint&amp;#34;, name: &amp;#34;first-paint&amp;#34;, startTime: 197.58499998715706, } */ 通过 performance.getEntriesByType() 函数返回了一个 PerformanceEntry 实例组成的数组 duration 为该事件的耗时 entryType 为性能指标实例的类型 name 为指标名称 startTime 为指标采集时间。 首屏内容绘制（First Contentful Paint，FCP） 浏览器首次绘制来自 DOM 的内容时间，这个内容可以是文字、图片（也包括背景图片）、非空白的 canvas 和 svg。 performance.</description></item><item><title>毎日のフロントエンド 186</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-186/</link><pubDate>Thu, 24 Mar 2022 14:22:03 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-186/</guid><description>HTML 如何实现浏览器桌面通知 Websocket Desktop Notification Notification.requestPermission(function (perm) { if (perm == &amp;#34;granted&amp;#34;) { let notification = new Notification(&amp;#34;通知&amp;#34;, { dir: &amp;#34;auto&amp;#34;, lang: &amp;#34;hi&amp;#34;, tag: &amp;#34;testTag&amp;#34;, icon: &amp;#34;https://static.cnblogs.com/images/adminlogo.gif&amp;#34;, body: &amp;#34;content&amp;#34; }); } }) CSS 相邻兄选择器 相邻兄弟选择器 (+) 介于两个选择器之间，当第二个元素紧跟在第一个元素之后，并且两个元素都是属于同一个父元素的子元素，则第二个元素将被选中 /* 图片后面紧跟着的段落将被选中 */ img + p { font-style: bold; } Tips 组件通信 - 状态管理 全局状态 父子组件通信 父组件通过 prop(s) 属性向子组件传参，子组件通过自定义事件来向父组件发送消息 状态管理库 状态管理库具有 3 个特点：可预测、中心化、可调式。 其他组件通信方式 全局上下文 事件监听 代码编译之webpack webpack 有两个执行入口，分别是: 通过命令行调用的 bin/webpack.</description></item><item><title>毎日のフロントエンド 185</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-185/</link><pubDate>Wed, 23 Mar 2022 14:28:43 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-185/</guid><description>Tips onload和domcontentloaded哪个先执行 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完全加载。 onload 需要所有资源全都加载完成才执行 组件就是基于视图的模块 组件的核心任务就是将数据渲染到视图并监听用户在视图上的操作
虚拟 DOM 优化性能 。DOM 操作是比较耗时的，对于大量、频繁的 DOM 操作，如果先在 JavaScript 中模拟进行，然后再通过计算比对，找到真正需要更新的节点，这样就有可能减少不必要的 DOM 操作，从而提升渲染性能。但并不是所有的 DOM 操作都能通过虚拟 DOM 提升性能，比如单次删除某个节点，直接操作 DOM 肯定比虚拟 DOM 计算比对之后再删除要快。总体而言， 虚拟 DOM 提升了 DOM 操作的性能下限，降低了 DOM 操作的性能上限。 所以会看到一些对渲染性能要求比较高的场景，比如在线文档、表格编辑，还是会使用原生 DOM 操作。
跨平台 。由于虚拟 DOM 以 JavaScript 对象为基础，所以可根据不同的运行环境进行代码转换（比如浏览器、服务端、原生应用等），这使得它具有了跨平台的能力。
数据模型(React) React 组件的数据模型 state，其值就是 对象类型。 React 并没有直接采用深拷贝的方式来实现，因为深拷贝操作性能开销太大。 React 组件是通过将 state 设置为不可变对象的方式来实现的，不可变对象指的就是当一个变量被创建后，它的值不可以被修改。 意味着当组件状态发生变化时，不修改 state 属性，而是重新创建新的 state 状态对象。 React 中的不可变对象通过 Structural Sharing（结构共享）的操作，大大减少了性能开销。 操作的原理就是，如果对象中的一个属性发生变化，那么只深拷贝当前属性，然后将对象属性指向这个深拷贝的属性，其他节点仍然进行共享。 渲染 React 组件中的视图更新，并不是像 Vue 中那样自动响应的，而是需要手动调用 setState() 函数来触发。 React 为了提升组件更新时的性能，不仅将状态更新包装成任务放入了异步队列，而且还使用了类似协程的方式来调度这些队列中的更新任务。 任务的执行顺序会根据每个任务的优先级来进行调整，并且任务的执行过程中可能会被中断，但状态会被保存，直到合适的时候会再次读取状态并继续执行任务。 Vue 采取的是响应式的视图更新方式，基于 Object.</description></item><item><title>毎日のフロントエンド 184</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-184/</link><pubDate>Tue, 22 Mar 2022 14:27:44 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-184/</guid><description>HTML 下拉选项进行分组 &amp;lt;select name=&amp;#34;alpha&amp;#34;&amp;gt; &amp;lt;optgroup label=&amp;#34;A&amp;#34;&amp;gt; &amp;lt;option value=&amp;#34;1&amp;#34;&amp;gt;AA&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;2&amp;#34;&amp;gt;BB&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;3&amp;#34;&amp;gt;CC&amp;lt;/option&amp;gt; &amp;lt;/optgroup&amp;gt; &amp;lt;optgroup label=&amp;#34;a&amp;#34;&amp;gt; &amp;lt;option value=&amp;#34;1&amp;#34;&amp;gt;aa&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;2&amp;#34;&amp;gt;bb&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;3&amp;#34;&amp;gt;cc&amp;lt;/option&amp;gt; &amp;lt;/optgroup&amp;gt; &amp;lt;/select&amp;gt; CSS translate() 方法 translate() CSS 函数在水平和/或垂直方向上重新定位元素 transform: translate(x,y,z) 控制元素往三个轴方向平移 x 是屏幕左上角往右的方向 y 是屏幕左上角往下的方向 z 是屏幕到人眼的方向 Tips 前后端沟通 RPC—远程过程调用 RPC（Remote Procedure Call，远程过程调用）常用于后端服务进程之间的通信。 “远程”指的是不同服务器上的进程，“过程调用”里的“过程”可以理解为“函数”，这种接口设计和函数命名很相似，名称为动宾结构短语 GET /getUsers POST /deleteUser POST /createUser RPC 风格和平常编写模块的思路很像，提供了一个函数作为接口，供其他模块调用。是站在后端工程师的视角而设置的：为了像在本地调用一个函数那样调用远程的代码。 紧耦合：当前端工程师需要获取或修改某个数据时，他有可能需要先调用接口 A ，再调用接口 B，这种调用需要对系统非常熟悉，让前端工程师熟悉后端逻辑和代码显然是难以办到的。 冗余：把执行动作写在 URL 上实际是冗余的，因为 HTTP 的 Method 头部可以表示不同的动作行为。 REST—表现层状态转换 表现层 资源指的是一个实体信息，一个文本文件、一段 JSON 数据都可以称为资源。 一个资源可以有不同的呈现形式，比如一份数据可以是 XML 格式，也可以是 JSON 格式，这种呈现形式叫作“表现层（Representation） 状态转移 HTTP 本身是无状态的，因此，如果客户端想要操作服务器，则必须通过某种手段让服务器发生“状态转移（State Transfer）”。而这种转移是建立在表现层之上的，即“表现层状态转移”。 REST 的核心要点有两个，那就是资源和方法。</description></item><item><title>毎日のフロントエンド 183</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-183/</link><pubDate>Mon, 21 Mar 2022 15:15:07 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-183/</guid><description>HTML &amp;lt;output&amp;gt; 标签 &amp;lt;output&amp;gt; 标签表示计算或用户操作的结果。 属性 for其它影响计算结果的标签的 ID，可以多个。 form与当前标签有关联的 form（从属的表单）。该属性的值必须是当前文档内的表单元素的 ID。如果未指明该属性，output 标签必须是一个 form 的后代标签。该属性的用处在于可以让 output 标签脱离 form 标签，存在于一个网页文档的任意位置。 name 属性 &amp;lt;form oninput=&amp;#34;result.value=parseInt(a.value)+parseInt(b.value)&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;range&amp;#34; name=&amp;#34;b&amp;#34; value=&amp;#34;50&amp;#34; /&amp;gt; + &amp;lt;input type=&amp;#34;number&amp;#34; name=&amp;#34;a&amp;#34; value=&amp;#34;10&amp;#34; /&amp;gt; = &amp;lt;output name=&amp;#34;result&amp;#34;&amp;gt;&amp;lt;/output&amp;gt; &amp;lt;/form&amp;gt; CSS 去除图片自带的边距 图片以及所有其他 inline-block 元素之间都会有 4px 的间距，直接在父元素 font-size: 0 去除。 Tips 函数返回多个值方法 函数 return expression, 这个表达式应该是一个具体的值,这个具体的值可以是一个承载多个值的复杂值, 诸如 Array,Object, Map,Set 等方式来实现 AMD、CMD和CommonJS AMD,CMD 和 CommonJs 是 es6 之前推出的模块化方案</description></item><item><title>毎日のフロントエンド 182</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-182/</link><pubDate>Sun, 20 Mar 2022 14:04:20 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-182/</guid><description>HTML &amp;lt;meter&amp;gt; 标签 &amp;lt;meter&amp;gt;标签是 HTML 5 中的新标签
作用：定义已知范围或分数值内的标量测量。 &amp;lt;p&amp;gt;显示度量值：&amp;lt;/p&amp;gt; &amp;lt;meter value=&amp;#34;3&amp;#34; min=&amp;#34;0&amp;#34; max=&amp;#34;10&amp;#34;&amp;gt;3/10&amp;lt;/meter&amp;gt;&amp;lt;br /&amp;gt; &amp;lt;meter value=&amp;#34;0.6&amp;#34;&amp;gt;60%&amp;lt;/meter&amp;gt; &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;注释：&amp;lt;/b&amp;gt;Internet Explorer 不支持 meter 标签。&amp;lt;/p&amp;gt; CSS 写一个 reset 的文件 CSS reset，又叫做 CSS 重写或者 CSS 重置，用于改写 HTML 标签的默认样式, 尽量抹平个浏览器的样式差异 进行样式重写时，不建议使用 * 选择器进行重写，这样会降低效率，影响性能 JavaScript 为什么说 js 是弱类型语言 静态语言：我们把在使用之前就需要确认其变量数据类型的称为静态语言。 动态语言：我们把在运行过程中需要检查数据类型的语言称为动态语言。 通常把偷偷进行类型转换的操作成为隐式类型转换：
支持因此类型转换的语言称为弱类型语言 不支持隐式类型转换的语言称为强类型语言 编译型语言：通常都会对源代码进行编译，生成可以执行的二进制代码，执行的是编译后的结果。（C/C++、Object-C、swift, rust） 解释型语言:通常不用对源代码进行编译，一般是通过解释器载入脚本后运行。由于每个语句都是执行的时候才进行解释翻译，这样解释性语言每次执行就要翻译一次，效率相对要低。（JavaScript、Python、Erlang、PHP、Perl、Ruby） Javascript属于弱类型、动态、解释型语言 Tips 让浏览器更快地加载网络资源 通过减少响应内容大小</description></item><item><title>毎日のフロントエンド 179</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-179/</link><pubDate>Thu, 17 Mar 2022 22:28:57 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-179/</guid><description>Tips 进程（Process）与线程（Thread） 进程是操作系统进行资源分配和调度的基本单位
线程是操作系统进行运算的最小单位
一个程序至少有一个进程，一个进程至少有一个线程 线程需要由进程来启动和管理。 进程是操作系统资源分配的基本单位，这里隐含的意思就是，不同进程之间的资源是独享的，不可以相互访问。
多线程没有分配独立的资源，线程之间数据都是共享的，也就意味着创建线程的成本更小，因为不需要分配额外的存储空间。
多线程更轻量，多进程更安全更稳定
浏览器架构 浏览器进程
浏览器的主进程负责界⾯显⽰（地址栏、导航栏、书签等）、处理用户事件、管理⼦进程等。 GPU 进程
处理来自其他进程的 GPU 任务，比如来自渲染进程或扩展程序进程的 CSS3 动画效果，来自浏览器进程的界面绘制等。 还有一个重要的特性，那就是可以利用 GPU 硬件来加速渲染，包括 Canvas 绘制、CSS3 转换（Transitions）、CSS3 变换（Transforms）、WebGL 等。具体原理就是如果 DOM 元素使用了这些属性，GPU 进程就会在合成层的时候对它进行单独处理，提升到一个独立的层进行绘制，这样就能避免重新布局和重新绘制。 Network Service 进程
负责⻚⾯的⽹络资源加载，比如在地址栏输入一个网页地址，网络进程会将请求后得到的资源交给渲染进程处理。本来只是浏览器主进程的一个模块，现在为了将浏览器进程进行“服务化”，被抽取出来，成了一个单独的进程。 V8 代理解析工具进程
Chrome 支持使用 JavaScript 来写连接代理服务器脚本，称为 pac 代理脚本 由于 pac 代理脚本是用 JavaScript 编写的，要能够解析 pac 代理脚本就必须要用到 JavaScript 脚本引擎，直接在浏览器主进程中引入 JavaScript 引擎并不符合进程“服务化”的设计理念，所以就把这个解析功能独立成一个进程 渲染进程</description></item><item><title>毎日のフロントエンド 177</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-177/</link><pubDate>Tue, 15 Mar 2022 11:28:16 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-177/</guid><description>HTML 网站首页有大量的图片，加载很慢，怎么优化 小图用 iconfont（svg）代替。 不能替代的用 base64。 去除 gif 图，用 video 代替。 工具压缩图片的大小。 优先使用 webp 格式 骨骼屏+ 懒加载。 CSS preload、preconnect、prefetch Preload: 在 &amp;lt;link&amp;gt; 标签中使用 preload 时，提前请求资源。主要用于获取当前路由中使用的高优先级资源。 元素的 rel 属性的属性值 preload 能够让你在你的 HTML 页面中元素内部书写一些声明式的资源获取请求，可以指明哪些资源是在页面加载完成后即刻需要的。 rel=&amp;quot;preolad&amp;quot;声明这是一个 preload href 指明资源的位置 as 指明资源类型（这是为了让浏览器精确设置优先级，设置正确的 CSP、Accept 头部） crossorigin 指明使用的跨域设置 添加 preload 声明之后，浏览器初次加载的资源变多了，但 preload 并不会阻塞 onload 事件的触发 Preconnect: 解决 DNS 和 TCP 握手问题, 使浏览器能够预先建立一个连接，等真正需要加载资源的时候就能够直接请求了 Prefetch: 提前获取资源将其置于缓存中，使用资源时从缓存中获取而不是发出另一个请求。 Tips debounce (TypeScript) 函数 debounce 添加类型，包括参数类型和返回值类型。参数类型使用泛型变量，在调用函数 debounce 的时候手动指定，泛型变量有 3 个：函数 T 、函数 T 的返回值 U 和 函数 T 的参数 V 变量 timeout ，当定时器存在时它的值为 number，定时器不存在时值为 null const debounce = &amp;lt;T extends Function, U, V extends any[]&amp;gt;(func: T, wait: number = 0) =&amp;gt; { let timeout: number | null = null; let args: V; function debounced(.</description></item><item><title>毎日のフロントエンド 176</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-176/</link><pubDate>Mon, 14 Mar 2022 17:25:38 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-176/</guid><description>JavaScript 模块化 ES6 模块 ES6 模块强制自动采用严格模式，所以说不管有没有“user strict”声明都是一样的，换言之，编写代码的时候不必再刻意声明了； 虽然大部分主流浏览器支持 ES6 模块，但是和引入普通 JS 的方式略有不同，需要在对应 script 标签中将属性 type 值设置为module才能被正确地解析为 ES6 模块； 在 Node.js 下使用 ES6 模块则需要将文件名后缀改为“.mjs”，用来和 Node.js 默认使用的 CommonJS 规范模块作区分 ES6 模块有两个重要特性
值引用 指 export 语句输出的接口，与其对应的值是动态绑定关系。即通过该接口，可以取到模块内部实时的值，可以简单地理解为变量浅拷贝。 静态分析 指不需要执行代码，只从字面量上对代码进行分析。 // 必须首部声明 let a = 1 import { app } from &amp;#39;./app&amp;#39;; // 不允许使用变量或表达式 import { &amp;#39;a&amp;#39; + &amp;#39;p&amp;#39; + &amp;#39;p&amp;#39; } from &amp;#39;./app&amp;#39;; // 不允许被嵌入语句逻辑 if (moduleName === &amp;#39;app&amp;#39;) { import { init } from &amp;#39;.</description></item><item><title>毎日のフロントエンド 175</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-175/</link><pubDate>Sun, 13 Mar 2022 17:19:01 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-175/</guid><description>CSS css 文件过大时， &amp;ldquo;异步加载 CSS&amp;rdquo; 利用媒体查询 &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;./index.css&amp;quot; media=&amp;quot;none&amp;quot; onload=&amp;quot;this.media='all'&amp;quot;&amp;gt;
OR
&amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;./index1.css&amp;#34; media=&amp;#34;screen and (max-width: 800px)&amp;#34; /&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;./index2.css&amp;#34; media=&amp;#34;screen and (min-width: 800px)&amp;#34; /&amp;gt; rel means relationship
提前加载资源 优先级最高，异步加载，不会阻塞 DOM 的渲染，浏览器支持度比较低。
&amp;lt;link rel=&amp;quot;preload&amp;quot; href=&amp;quot;./index.css&amp;quot; as=&amp;quot;style&amp;quot;&amp;gt;
该属性还可以应用于其他资源
当用到这些资源的时候，浏览器会从缓存中取得，不再次发送请求了
Here however, we will use a rel value of preload, which turns &amp;lt;link&amp;gt; into a preloader for any resource we want.</description></item><item><title>毎日のフロントエンド 173</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-173/</link><pubDate>Fri, 11 Mar 2022 15:40:11 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-173/</guid><description>HTML HTML 的标签区分大小写 DOCTYPE 声明, 不区分大小写
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;!doctype html&amp;gt; &amp;lt;!DOCTYPE HTML&amp;gt; &amp;lt;!Doctype html&amp;gt; HTML 文档中的标签名和属性名都是大小写不敏感的
HTML 中属性的名字是大小写不敏感的，而属性的值则默认是大小写敏感的
下述列表中的属性的值是大小写不敏感的: accept accept-charset align alink axis bgcolor charset checked clear codetype color compact declare defer dir direction disabled enctype face frame hreflang http-equiv lang language link media method multiple nohref noresize noshade nowrap readonly rel rev rules scope scrolling selected shape target text type (视情况而定) valign valuetype vlink XML 文档中的标签名和属性名都是大小写敏感的。</description></item><item><title>毎日のフロントエンド 172</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-172/</link><pubDate>Thu, 10 Mar 2022 20:42:49 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-172/</guid><description>Tips 函数为什么是一等公民 据类型与函数是很多高级语言中最重要的两个概念，前者用来存储数据，后者用来存储代码。JavaScript 中的函数相对于数据类型而言更加复杂，它可以有属性，也可以被赋值给一个变量，还可以作为参数被传递&amp;hellip;&amp;hellip;正是这些强大特性让它成了 JavaScript 的“一等公民”
this 关键字 this 指向的应该是一个对象，更具体地说是函数执行的“上下文对象” 这个对象指向的是“调用它”的对象，如果调用它的不是对象或对象不存在，则会指向全局对象（严格模式下为 undefined） function fn() { console.log(this); } function fn2() { fn(); } var obj = { fn2 }; obj.fn2(); // ? 调用函数 fn() 的是函数 fn2() 而不是 obj。虽然 fn2() 作为 obj 的属性调用，但 fn2()中的 this 指向并不会传递给函数 fn()， 所以答案也是 window（Node.js 下是 global） var dx = { arr: [1], }; dx.arr.forEach(function () { console.log(this); }); // ? forEach，它有两个参数，第一个是回调函数，第二个是 this 指向的对象，这里只传入了回调函数，第二个参数没有传入，默认为 undefined，所以正确答案应该是输出全局对象。 类似的，需要传入 this 指向的函数还有：every()、find()、findIndex()、map()、some() class B { fn() { console.</description></item><item><title>毎日のフロントエンド 161</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-161/</link><pubDate>Thu, 24 Feb 2022 16:52:49 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-161/</guid><description>HTML HTML 调用摄像头 window.navigator.getUserMedia()
接收三个参数，第一个是视频或者音频以及分辨率{video:true}第二个是成功回调，第三个是失败回调 window.navigator.mediaDevices.getUserMedia()
也是三个参数，参数格式和上文一样，区别在于这个 api 是基于 promise 实现的 JavaScript Nodejs Process.nextTick process.nextTick(callback[, ...args])
第一个参数是 callback 回调函数，第二个参数是 args 调用 callback 时额外传的参数，是可选参数 Process.nextTick 是微任务 也是异步 API 的一部分
Process.nextTick 的运行逻辑：
Process.nextTick 会将 callback 添加到“next tick queue”； “next tick queue”会在当前 JavaScript stack 执行完成后，下一次 event loop 开始执行前按照 FIFO 出队； 如果递归调用 Process.nextTick 可能会导致一个无限循环，需要去适时终止递归。 根据代码执行顺序，Process.</description></item><item><title>毎日のフロントエンド 160</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-160/</link><pubDate>Wed, 23 Feb 2022 17:07:08 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-160/</guid><description>CSS 第一行和第二行的颜色分别是什么 &amp;lt;style&amp;gt; .red { color: red; } .green { color: green; } &amp;lt;/style&amp;gt; &amp;lt;div class=&amp;#34;red green&amp;#34;&amp;gt;第一行：颜色是什么？&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;green red&amp;#34;&amp;gt;第二行：颜色是什么？&amp;lt;/div&amp;gt; 都是绿色。CSS 的覆盖顺序与标签内 class 定义的顺序无关，只与 style 中的顺序有关，后面的覆盖前面的属性 JavaScript 有些 js 库习惯在代码开头处添加分号有什么作用 js 文件结束 处是 没有 分号的。若几个 js 连在一起时，2 个 js 连接处 会发生语法上的混淆。 开头加; 用于分隔， 可以避免多文件压缩在一起时引起的错误。分号和分号放在一起也没问题，相当于 “空语句”。 可以用void ! + ~ 代替 宏任务和微任务 代码执行顺序 console.log(&amp;#39;begin&amp;#39;); setTimeout(() =&amp;gt; { console.log(&amp;#39;setTimeout&amp;#39;); }, 0); new Promise((resolve) =&amp;gt; { console.log(&amp;#39;promise&amp;#39;); resolve(); }) .</description></item><item><title>毎日のフロントエンド 159</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-159/</link><pubDate>Tue, 22 Feb 2022 23:06:50 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-159/</guid><description>第一百五十九日 HTML html 实现下拉提示 datalist - HTML（超文本标记语言） | MDN &amp;lt;label for=&amp;#34;favorite_team&amp;#34;&amp;gt;Favorite Team:&amp;lt;/label&amp;gt; &amp;lt;!-- 注意input的list属性与datalist的id属性进行绑定 --&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;team&amp;#34; id=&amp;#34;favorite_team&amp;#34; list=&amp;#34;team_list&amp;#34; autocomplete=&amp;#34;off&amp;#34;/&amp;gt; &amp;lt;datalist id=&amp;#34;team_list&amp;#34;&amp;gt; &amp;lt;!-- 指定了value值之后，value和innerHTML类似于标题与副标题之间的关系，选中后input的值是value --&amp;gt; &amp;lt;option value=&amp;#34;A&amp;#34;&amp;gt;Aus Tigers&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;B&amp;#34;&amp;gt;Detroit Lions&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;C&amp;#34;&amp;gt;Detroit Pistons&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;D&amp;#34;&amp;gt;Detroit Red Wings&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;E&amp;#34;&amp;gt;Detroit Tigers&amp;lt;/option&amp;gt; &amp;lt;/datalist&amp;gt; &amp;lt;/datalist&amp;gt; CSS 两端对齐 对于文字，利用 text-align-last:justify; or :before 模拟成多行然后 text-align: justify 子元素的两端对齐，用 float 或 flex 或 grid Tips attribute 和 property 区别 attribute</description></item><item><title>毎日のフロントエンド 158</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-158/</link><pubDate>Mon, 21 Feb 2022 21:20:02 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-158/</guid><description>第一百五十八日 Tips V8 引擎 V8 引擎执行 JS 代码都要经过哪些阶段 Parse 阶段：V8 引擎负责将 JS 代码转换成 AST（抽象语法树）； Ignition 阶段：解释器将 AST 转换为字节码，解析执行字节码也会为下一个阶段优化编译提供需要的信息； TurboFan 阶段：编译器利用上个阶段收集的信息，将字节码优化为可以执行的机器码； Orinoco 阶段：垃圾回收阶段，将程序中不再使用的内存空间进行回收。 生成 AST AST 抽象语法树的应用场景
JS 反编译，语法解析； Babel 编译 ES6 语法； 代码高亮； 关键字匹配； 代码压缩。 AST 分为两个阶段
词法分析： 这个阶段会将源代码拆成最小的、不可再分的词法单元，称为 token。比如这行代码 var a =1；通常会被分解成 var 、a、=、2、; 这五个词法单元。另外刚才代码中的空格在 JavaScript 中是直接忽略的。 语法分析 这个过程是将词法单元转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，这个树被称为抽象语法树。 // 第一段代码 var a = 1; // 第二段代码 function sum(a, b) { return a + b; } 分别转换成 AST 抽象语法树之后返回的 JSON 格式如下</description></item><item><title>毎日のフロントエンド 157</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-157/</link><pubDate>Sun, 20 Feb 2022 11:26:21 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-157/</guid><description>第一百五十七日 HTML bdo 标签 将内部的文字反序输出 属性是dir 默认是ltr 需要倒叙就改成rtl CSS 外边距重叠 外边距重叠是什么？
外边距重叠指的是，当两个垂直外边距相遇时，它们将形成一个外边距。 重叠后的外边距的高度等于两个发生重叠的外边距的高度中的较大者。 发生的条件：属于同一个 BFC 的两个相邻元素上下 margin 会重叠。 重叠的结果是什么？
举例 1：当一个元素出现在另一个元素上面时，重叠后的外边距的高度等于两个发生重叠的外边距的高度中的较大者。 举例 2： 当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距也会发生重叠。如果这个外边距遇到另一个元素的外边距，它还会发生重叠。 怎么防止外边距重叠？
浮动元素、inline-block 元素、绝对定位元素的 margin 不会和垂直方向上其他元素的 margin 折叠（注意这里指的是上下相邻的元素） 外层元素 padding 代替 内层元素透明边框 border:1px solid transparent; 用同一方向的 margin，都设置为 top 或者 bottom。 Tips 浏览器的 Eventloop 1.调用堆栈（call stack）负责跟踪所有要执行的代码 每当一个函数执行完成时，就会从堆栈中弹出（pop）该执行完成函数 如果有代码需要进去执行的话，就进行 push 操作 2.</description></item><item><title>毎日のフロントエンド 156</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-156/</link><pubDate>Sat, 19 Feb 2022 15:08:08 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-156/</guid><description>第一百五十六日 CSS border:none和border:0px区别 从border: 10px;过渡到border: none;，是不会有动画的 从border: 10px;过渡到border: 0px;，是可以有动画的 Tips JavaScript 的内存管理 基本类型：这些类型在内存中会占据固定的内存空间，它们的值都保存在栈空间中，直接可以通过值来访问这些； 引用类型：由于引用类型值大小不固定（比如上面的对象可以添加属性等），栈内存中存放地址指向堆内存中的对象，是通过引用来访问的 栈内存中的基本类型，可以通过操作系统直接处理；而堆内存中的引用类型，正是由于可以经常变化，大小不固定，因此需要 JavaScript 的引擎通过垃圾回收机制来处理。
Chrome 内存回收机制 Chrome 的 JavaScript 引擎 V8 将堆内存分为两类 新生代的回收机制和老生代的回收机制
内存泄漏与优化 内存泄漏的场景： 过多的缓存未释放 闭包太多未释放 定时器或者回调太多未释放 太多无效的 DOM 未释放 全局变量太多未被发现 减少不必要的全局变量，使用严格模式避免意外创建全局变量 function foo() { // 全局变量=&amp;gt; window.bar this.bar = &amp;#39;默认this指向全局&amp;#39;; // 没有声明变量，实际上是全局变量=&amp;gt;window.bar bar = &amp;#39;全局变量&amp;#39;; } foo(); 在你使用完数据后，及时解除引用（闭包中的变量，DOM 引用，定时器清除） var someResource = getData(); setInterval(function() { var node = document.</description></item><item><title>毎日のフロントエンド 155</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-155/</link><pubDate>Fri, 18 Feb 2022 10:51:40 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-155/</guid><description>第一百五十五日 HTML HTML5 有哪些存储类型 cookie: 最大 4k, 基本无兼容问题, 所有同源 tab 共享, 每次请求都携带, key-value 存储, value 只存字符串 sessionStorage 无大小限制, 只在当前 tab 有效, tab 关闭即失效, key-value 存储, value 只存字符串 localStorage 最大 5M-10M, 所有同源 tab 共享, 能持久化存储, key-value 存储, value 只存字符串 indexDB key-value 存储,value 可以任意类型, 同源, 支持事务, 最大 250M, 兼容 ie10 webSQL 支持版本,事务,支持 sql 语句, 不兼容 ie CSS CSS Guidelines (2.2.5) – High-level advice and guidelines for writing sane, manageable, scalable CSS</description></item><item><title>毎日のフロントエンド 154</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-154/</link><pubDate>Thu, 17 Feb 2022 16:45:01 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-154/</guid><description>第一百五十四日 JavaScript 并行和并发、同步和异步、阻塞和非阻塞 并发并行是处理任务的方式 并发是在一个时间段可以处理多个任务，但是在相同的时间内只能处理一个任务 并行是同时可以处理多个任务 同步异步是处理运行结果的方式 同步是在上一个返回结果还没返回的时候就不进行下一步的调用 异步是上一个结果还没返回就继续执行下一步，直到有返回结果了再调用对应的异步回调 阻塞和非阻塞是运行时的状态 阻塞是在上一个任务还在执行时，下一个任务处于无法执行的状态，需要继续等待，直到上一个任务执行完毕 非阻塞就是任务的执行状态一直是上一个执行了，下一个就继续执行，没有多余的等待时间 Tips EventEmitter(node) 常用的 EventEmitter 模块的 API
addListener 和 removeListener、on 和 off 方法对比 addListener 方法的作用是为指定事件添加一个监听器，其实和 on 方法实现的功能是一样的，on 其实就是 addListener 方法的一个别名。二者实现的作用是一样的 removeListener 方法的作用是为移除某个事件的监听器，同样 off 也是 removeListener 的别名 var events = require(&amp;#39;events&amp;#39;); var emitter = new events.EventEmitter(); function hello1(name) { console.log(&amp;#39;hello 1&amp;#39;, name); } function hello2(name) { console.</description></item><item><title>毎日のフロントエンド 153</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-153/</link><pubDate>Wed, 16 Feb 2022 16:56:17 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-153/</guid><description>第一百五十三日 HTML 单词标志缩写 &amp;lt;abbr&amp;gt; - HTML（超文本标记语言） | MDN CSS 背景裁剪 background-clip`: border-box: 默认,背景延伸至边框外沿,但是在边框的下层 padding-box: 背景延伸至 padding 的外沿 content-box: 背景延伸至内容的外沿 text: 背景剪裁成文字的样式 Tips 异步编程 什么是同步 所谓的同步就是在执行某段代码时，在该代码没有得到返回结果之前，其他代码暂时是无法执行的，但是一旦执行完成拿到返回值之后，就可以执行其他代码了。换句话说，在此段代码执行完未返回结果之前，会阻塞之后的代码执行，这样的情况称为同步。
什么是异步 所谓异步就是当某一代码执行异步过程调用发出后，这段代码不会立刻得到返回结果。而是在异步调用发出之后，一般通过回调函数处理这个调用之后拿到结果。异步调用发出后，不会影响阻塞后面的代码执行，这样的情形称为异步。
Promise function read(url) { return new Promise((resolve, reject) =&amp;gt; { fs.readFile(url, &amp;#39;utf8&amp;#39;, (err, data) =&amp;gt; { if (err) reject(err); resolve(data); }); }); } // 通过 Promise.all 可以实现多个异步并行执行，同一时刻获取最终结果的问题 Promise.all([read(A), read(B), read(C)]) .then((data) =&amp;gt; { console.log(data); }) .catch((err) =&amp;gt; console.</description></item><item><title>毎日のフロントエンド 152</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-152/</link><pubDate>Tue, 15 Feb 2022 17:28:33 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-152/</guid><description>第一百五十二日 HTML small标签 &amp;lt;small&amp;gt;元素將使文本的字体变小一号。(例如从大变成中等，从中等变成小，从小变成超小)。在 HTML5 中，除了它的样式含义，这个元素被重新定义为表示边注释和附属细则，包括版权和法律文本。 JavaScript CORS 预检请求 简单请求 同源策略是一个重要的安全策略，它用于限制一个 origin 的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。 当一个资源从与该资源本身所在的服务器不同的域、协议、端口请求一个资源时，资源会发起一个跨域 HTTP 请求。
出于安全原因，浏览器限制从脚本内发起的跨源 HTTP 请求，XMLHttpRequest 和 Fetch API，只能从加载应用程序的同一个域请求 HTTP 资源，除非使用 CORS 头文件 CORS 概述 跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。
另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。
服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）
cors-flow
简单请求 不会触发 CORS 预检的请求称为简单请求，满足以下所有条件的才会被视为简单请求: 使用GET、POST、HEAD其中一种方法 只使用了如下的安全首部字段，不得人为设置其他首部字段 Accept Accept-Language Content-Language Content-Type 仅限以下三种 text/plain multipart/form-data application/x-www-form-urlencoded HTML 头部 header field 字段：DPR、Download、Save-Data、Viewport-Width、Width 请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload对象可以使用 XMLHttpRequest.</description></item><item><title>毎日のフロントエンド 151</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-151/</link><pubDate>Mon, 14 Feb 2022 10:24:45 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-151/</guid><description>第一百五十一日 HTML Question: 在页面中添加数学公式 KaTeX – The fastest math typesetting library for the web MathJax | Beautiful math in all browsers. Tips 常用的数组方法底层实现 push 方法的底层实现 Array.prototype.push = function (...items) { let O = Object(this); // ecma 中提到的先转换为对象 // &amp;gt;&amp;gt;&amp;gt; 无符号右移 &amp;gt;&amp;gt;&amp;gt; 0 对非负数 取整; // 确保 ensure that the length property is a unsigned 32-bit integer. let len = this.length &amp;gt;&amp;gt;&amp;gt; 0; let argCount = items.</description></item><item><title>毎日のフロントエンド 150</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-150/</link><pubDate>Sun, 13 Feb 2022 15:12:49 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-150/</guid><description>第一百五十日 HTML Question: HTML5 如何使某个页面元素或整个页面可编辑 让某个元素可以编辑，可以使用 contenteditable 属性 让整个页面可编辑可以使用 document.designMode 属性 CSS Question: 什么时候用 transition？什么时候使用 animation transition 相当于是个过度动画，需要又过度效果才会触发。一般用来做元素的放大缩小、平移旋转等简单的操作 transition 只执行一次，当需要执行多次时，一般会利用 :hover 等时机或者使用 javaScript 改变类名进行控制。 animation 需要自己设定关键帧，可以做相对复杂的操作，比如延迟、循环播放等。一般在需要比较复杂的情况才会使用 animation Tips sort排序算法实现原理 arr.sort([compareFunction]) 数组已原地排序，并且不进行复制 compareFunction 用来指定按某种顺序进行排列的函数，如果省略不写，元素按照转换为字符串的各个字符的 Unicode 位点进行排序 const months = [&amp;#39;March&amp;#39;, &amp;#39;Jan&amp;#39;, &amp;#39;Feb&amp;#39;, &amp;#39;Dec&amp;#39;]; months.sort(); console.log(months); // [&amp;#34;Dec&amp;#34;, &amp;#34;Feb&amp;#34;, &amp;#34;Jan&amp;#34;, &amp;#34;March&amp;#34;] const array1 = [1, 30, 4, 21, 100000]; array1.sort(); console.log(array1); // [1, 100000, 21, 30, 4] 如果指明了 compareFunction 参数 ，那么数组会按照调用该函数的返回值排序，即 a 和 b 是两个将要被比较的元素： 如果 compareFunction（a, b)小于 0，那么 a 会被排列到 b 之前； 如果 compareFunction（a, b)等于 0，a 和 b 的相对位置不变； 如果 compareFunction（a, b)大于 0，b 会被排列到 a 之前。 sort 源码分析</description></item><item><title>毎日のフロントエンド 149</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-149/</link><pubDate>Sat, 12 Feb 2022 16:50:12 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-149/</guid><description>第一百四十九日 HTML Question: 整个页面中的内容设置成只读，不可编辑的状态 body { pointer-events: none !important; } Tips 数组排序 比较类排序：通过比较来决定元素间的相对次序，其时间复杂度不能突破 O(nlogn)，因此也称为非线性时间比较类排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 排序的分类
冒泡排序 let a = [1, 3, 6, 3, 23, 76, 1, 34, 222, 6, 456, 221]; function bubbleSort(array) { const len = array.length; if (len &amp;lt; 2) return array; for (let i = 0; i &amp;lt; len; i++) { for (let j = 0; j &amp;lt; i; j++) { if (array[j] &amp;gt; array[i]) { const temp = array[j]; array[j] = array[i]; array[i] = temp; } } } return array; } bubbleSort(a); // [1, 1, 3, 3, 6, 6, 23, 34, 76, 221, 222, 456] 快速排序 最主要的思路是从数列中挑出一个元素，称为 “基准”（pivot）；然后重新排序数列，所有元素比基准值小的摆放在基准前面、比基准值大的摆在基准的后面；在这个区分搞定之后，该基准就处于数列的中间位置；然后把小于基准值元素的子数列（left）和大于基准值元素的子数列（right）递归地调用 quick 方法排序完成。 let a = [1, 3, 6, 3, 23, 76, 1, 34, 222, 6, 456, 221]; function quickSort(array) { let quick = function (arr) { if (arr.</description></item><item><title>毎日のフロントエンド 147</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-147/</link><pubDate>Thu, 10 Feb 2022 12:56:13 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-147/</guid><description>第一百四十六日 HTML Question: 本地存储的生命周期 cookie: expire 和 max-age 都能控制数据的存储时间。expire 是一个绝对的过期时间，max-age 是文档被访问之后的存活时间（是相对时间）。默认是 session (一次会话) sessionStorage: 当会话被关闭后（浏览器、标签页被关闭），就会被清除。与 localStorage 用法一样 localStorage: 除非被主动清除，不然永久储存在浏览器中 IndexedDB: 没有过期时间，除非主动清除 CSS Question: background-attachment属性 background-attachment: fixed / scroll / local： 设置背景图像是否固定或者随着页面的其余部分滚动。 fixed: 背景图片不会随着页面的滚动而滚动 scroll: 背景图片随着页面的滚动而滚动，默认 local: 背景图片会随着元素内容的滚动而滚动 inherit: 指定 background-attachment 的设置应该从父元素继承。 Tips 数组扁平化 数组的扁平化其实就是将一个嵌套多层的数组 array（嵌套可以是任何层数）转换为只有一层的数组。
方法一：普通的递归实现 // 方法1 // 在遍历过程中发现数组元素还是数组的时候进行递归操作， // 把数组的结果通过数组的 concat 方法拼接到最后要返回的 result 数组上，那么最后输出的结果就是扁平化后的数组。 var a = [1, [2, [3, 4, 5]]]; function flatten(arr) { let result = []; for (let i = 0; i &amp;lt; arr.</description></item><item><title>毎日のフロントエンド 146</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-146/</link><pubDate>Wed, 09 Feb 2022 11:17:27 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-146/</guid><description>第一百四十六日 HTML Question: viewport 是什么？在什么时候下使用 viewport 是用户网页的可视区域 多用于移动端，也可以用在支持类似“固定到边缘”等特性的桌面浏览器 移动端的浏览器是把页面放在一个虚拟的&amp;quot;窗口&amp;quot;（viewport）中，通常这个虚拟的&amp;quot;窗口&amp;quot;（viewport）比物理屏幕宽，这样就不用把每个网页挤到很小的窗口中（这样会破坏没有针对手机浏览器优化的网页的布局），用户可以通过平移和缩放来看网页的不同部分 visual viewport 尺寸所对应的并不是指屏幕区域里的物理像素，而是 CSS 像素。并且它所包含的 CSS 像素的数量也是随着用户缩放而有所改变 在 head 加入这行，把默认的 layout viewport 的宽度设为移动设备的屏幕宽度，也就是把当前的 viewport 宽度设置为设备物理屏幕的宽度，实现全屏的效果 &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no&amp;quot;&amp;gt; Tips 类数组 函数里面的参数对象 arguments 用 getElementsByTagName/ClassName/Name 获得的 HTMLCollection 用 querySelector 获得的 NodeList arguments对象 只定义在函数体中 有一个 length 属性 callee 属性(此函数自身) function foo(name, age, sex) { console.log(arguments); // [Arguments] { &amp;#39;0&amp;#39;: &amp;#39;jack&amp;#39;, &amp;#39;1&amp;#39;: &amp;#39;18&amp;#39;, &amp;#39;2&amp;#39;: &amp;#39;male&amp;#39; } console.</description></item><item><title>毎日のフロントエンド 145</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-145/</link><pubDate>Tue, 08 Feb 2022 20:47:08 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-145/</guid><description>第一百四十五日 HTML Question: 表单属性type=&amp;quot;hidden&amp;quot; &amp;lt;input type=&amp;quot;hidden&amp;quot;&amp;gt; &amp;ldquo;hidden&amp;rdquo; 类型的 &amp;lt;input&amp;gt; 元素允许 Web 开发者存放一些用户不可见、不可改的数据，在用户提交表单时，这些数据会一并发送出。比如，正被请求或编辑的内容的 ID，或是一个唯一的安全令牌。这些隐藏的 &amp;lt;input&amp;gt;元素在渲染完成的页面中完全不可见，而且没有方法可以使它重新变为可见。 隐藏域在页面中对于用户是不可见的，在表单中插入隐藏域的目的在于收集或发送信息，以利于被处理表单的程序所使用。浏览者单击发送按钮发送表单的时候，隐藏域的信息也被一起发送到服务器 有些时候要给用户一信息，在提交表单时一同提交,以确定用户身份，如 sessionkey 等．同样也可以用 cookie 实现，但使用隐藏域就简单的多了．兼容性好，且可以避免被禁用cookies 一个 form 里有多个提交按钮，怎样使程序能够分清楚到底用户是按那一个按钮提交上来的呢？ 这时可以添加隐藏域，然后在每一个按钮处加上 οnclick=&amp;ldquo;document.form.command.value=&amp;ldquo;xx&amp;rdquo;， 然后接到数据后先检查 command 的值就会知道用户是按的那个按钮提交上来的 一个网页中有多个 form，我们知道多个 form 是不能同时提交的，但有时这些 form 确实相互作用，我们就可以在 form 中添加隐藏域来使它们联系起来 JavaScript Question: 原生 Math 的方法有哪些 常用方法
Math.abs(num) // num绝对值 Math.ceil(num) // num向上取整 Math.floor(num) // num向下取整 Math.max(num1, num2 ...) // 取较大值 Math.min(num1, num2 ...) // 取较小值 Math.pow(num1, num2) // num1的num2次幂 Math.</description></item></channel></rss>