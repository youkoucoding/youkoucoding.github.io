<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tips on 技術の手帳</title><link>https://youkoucoding.github.io/categories/tips/</link><description>Recent content in Tips on 技術の手帳</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 19 Feb 2022 15:08:08 +0900</lastBuildDate><atom:link href="https://youkoucoding.github.io/categories/tips/index.xml" rel="self" type="application/rss+xml"/><item><title>毎日のフロントエンド 156</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-156/</link><pubDate>Sat, 19 Feb 2022 15:08:08 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-156/</guid><description>CSS border:none和border:0px区别 从border: 10px;过渡到border: none;，是不会有动画的 从border: 10px;过渡到border: 0px;，是可以有动画的 Tips JavaScript 的内存管理 基本类型：这些类型在内存中会占据固定的内存空间，它们的值都保存在栈空间中，直接可以通过值来访问这些； 引用类型：由于引用类型值大小不固定（比如上面的对象可以添加属性等），栈内存中存放地址指向堆内存中的对象，是通过引用来访问的 栈内存中的基本类型，可以通过操作系统直接处理；而堆内存中的引用类型，正是由于可以经常变化，大小不固定，因此需要 JavaScript 的引擎通过垃圾回收机制来处理。
Chrome 内存回收机制 Chrome 的 JavaScript 引擎 V8 将堆内存分为两类 新生代的回收机制和老生代的回收机制
内存泄漏与优化 内存泄漏的场景： 过多的缓存未释放 闭包太多未释放 定时器或者回调太多未释放 太多无效的 DOM 未释放 全局变量太多未被发现 减少不必要的全局变量，使用严格模式避免意外创建全局变量 function foo() { // 全局变量=&amp;gt; window.bar this.bar = &amp;#39;默认this指向全局&amp;#39;; // 没有声明变量，实际上是全局变量=&amp;gt;window.bar bar = &amp;#39;全局变量&amp;#39;; } foo(); 在你使用完数据后，及时解除引用（闭包中的变量，DOM 引用，定时器清除） var someResource = getData(); setInterval(function() { var node = document.</description></item><item><title>毎日のフロントエンド 155</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-155/</link><pubDate>Fri, 18 Feb 2022 10:51:40 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-155/</guid><description>第一百五十五日 HTML HTML5 有哪些存储类型 cookie: 最大 4k, 基本无兼容问题, 所有同源 tab 共享, 每次请求都携带, key-value 存储, value 只存字符串 sessionStorage 无大小限制, 只在当前 tab 有效, tab 关闭即失效, key-value 存储, value 只存字符串 localStorage 最大 5M-10M, 所有同源 tab 共享, 能持久化存储, key-value 存储, value 只存字符串 indexDB key-value 存储,value 可以任意类型, 同源, 支持事务, 最大 250M, 兼容 ie10 webSQL 支持版本,事务,支持 sql 语句, 不兼容 ie CSS CSS Guidelines (2.2.5) – High-level advice and guidelines for writing sane, manageable, scalable CSS</description></item><item><title>毎日のフロントエンド 154</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-154/</link><pubDate>Thu, 17 Feb 2022 16:45:01 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-154/</guid><description>第一百五十四日 JavaScript 并行和并发、同步和异步、阻塞和非阻塞 并发并行是处理任务的方式 并发是在一个时间段可以处理多个任务，但是在相同的时间内只能处理一个任务 并行是同时可以处理多个任务 同步异步是处理运行结果的方式 同步是在上一个返回结果还没返回的时候就不进行下一步的调用 异步是上一个结果还没返回就继续执行下一步，直到有返回结果了再调用对应的异步回调 阻塞和非阻塞是运行时的状态 阻塞是在上一个任务还在执行时，下一个任务处于无法执行的状态，需要继续等待，直到上一个任务执行完毕 非阻塞就是任务的执行状态一直是上一个执行了，下一个就继续执行，没有多余的等待时间 Tips EventEmitter(node) 常用的 EventEmitter 模块的 API
addListener 和 removeListener、on 和 off 方法对比 addListener 方法的作用是为指定事件添加一个监听器，其实和 on 方法实现的功能是一样的，on 其实就是 addListener 方法的一个别名。二者实现的作用是一样的 removeListener 方法的作用是为移除某个事件的监听器，同样 off 也是 removeListener 的别名 var events = require(&amp;#39;events&amp;#39;); var emitter = new events.EventEmitter(); function hello1(name) { console.log(&amp;#39;hello 1&amp;#39;, name); } function hello2(name) { console.</description></item><item><title>毎日のフロントエンド 153</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-153/</link><pubDate>Wed, 16 Feb 2022 16:56:17 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-153/</guid><description>第一百五十三日 HTML 单词标志缩写 &amp;lt;abbr&amp;gt; - HTML（超文本标记语言） | MDN CSS 背景裁剪 background-clip`: border-box: 默认,背景延伸至边框外沿,但是在边框的下层 padding-box: 背景延伸至 padding 的外沿 content-box: 背景延伸至内容的外沿 text: 背景剪裁成文字的样式 Tips 异步编程 什么是同步 所谓的同步就是在执行某段代码时，在该代码没有得到返回结果之前，其他代码暂时是无法执行的，但是一旦执行完成拿到返回值之后，就可以执行其他代码了。换句话说，在此段代码执行完未返回结果之前，会阻塞之后的代码执行，这样的情况称为同步。
什么是异步 所谓异步就是当某一代码执行异步过程调用发出后，这段代码不会立刻得到返回结果。而是在异步调用发出之后，一般通过回调函数处理这个调用之后拿到结果。异步调用发出后，不会影响阻塞后面的代码执行，这样的情形称为异步。
Promise function read(url) { return new Promise((resolve, reject) =&amp;gt; { fs.readFile(url, &amp;#39;utf8&amp;#39;, (err, data) =&amp;gt; { if (err) reject(err); resolve(data); }); }); } // 通过 Promise.all 可以实现多个异步并行执行，同一时刻获取最终结果的问题 Promise.all([read(A), read(B), read(C)]) .then((data) =&amp;gt; { console.log(data); }) .catch((err) =&amp;gt; console.</description></item><item><title>毎日のフロントエンド 152</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-152/</link><pubDate>Tue, 15 Feb 2022 17:28:33 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-152/</guid><description>第一百五十二日 HTML small标签 &amp;lt;small&amp;gt;元素將使文本的字体变小一号。(例如从大变成中等，从中等变成小，从小变成超小)。在 HTML5 中，除了它的样式含义，这个元素被重新定义为表示边注释和附属细则，包括版权和法律文本。 JavaScript CORS 预检请求 简单请求 同源策略是一个重要的安全策略，它用于限制一个 origin 的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。 当一个资源从与该资源本身所在的服务器不同的域、协议、端口请求一个资源时，资源会发起一个跨域 HTTP 请求。
出于安全原因，浏览器限制从脚本内发起的跨源 HTTP 请求，XMLHttpRequest 和 Fetch API，只能从加载应用程序的同一个域请求 HTTP 资源，除非使用 CORS 头文件 CORS 概述 跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。
另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。
服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）
cors-flow
简单请求 不会触发 CORS 预检的请求称为简单请求，满足以下所有条件的才会被视为简单请求: 使用GET、POST、HEAD其中一种方法 只使用了如下的安全首部字段，不得人为设置其他首部字段 Accept Accept-Language Content-Language Content-Type 仅限以下三种 text/plain multipart/form-data application/x-www-form-urlencoded HTML 头部 header field 字段：DPR、Download、Save-Data、Viewport-Width、Width 请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload对象可以使用 XMLHttpRequest.</description></item><item><title>毎日のフロントエンド 151</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-151/</link><pubDate>Mon, 14 Feb 2022 10:24:45 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-151/</guid><description>第一百五十一日 HTML Question: 在页面中添加数学公式 KaTeX – The fastest math typesetting library for the web MathJax | Beautiful math in all browsers. Tips 常用的数组方法底层实现 push 方法的底层实现 Array.prototype.push = function (...items) { let O = Object(this); // ecma 中提到的先转换为对象 // &amp;gt;&amp;gt;&amp;gt; 无符号右移 &amp;gt;&amp;gt;&amp;gt; 0 对非负数 取整; // 确保 ensure that the length property is a unsigned 32-bit integer. let len = this.length &amp;gt;&amp;gt;&amp;gt; 0; let argCount = items.</description></item><item><title>毎日のフロントエンド 150</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-150/</link><pubDate>Sun, 13 Feb 2022 15:12:49 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-150/</guid><description>第一百五十日 HTML Question: HTML5 如何使某个页面元素或整个页面可编辑 让某个元素可以编辑，可以使用 contenteditable 属性 让整个页面可编辑可以使用 document.designMode 属性 CSS Question: 什么时候用 transition？什么时候使用 animation transition 相当于是个过度动画，需要又过度效果才会触发。一般用来做元素的放大缩小、平移旋转等简单的操作 transition 只执行一次，当需要执行多次时，一般会利用 :hover 等时机或者使用 javaScript 改变类名进行控制。 animation 需要自己设定关键帧，可以做相对复杂的操作，比如延迟、循环播放等。一般在需要比较复杂的情况才会使用 animation Tips sort排序算法实现原理 arr.sort([compareFunction]) 数组已原地排序，并且不进行复制 compareFunction 用来指定按某种顺序进行排列的函数，如果省略不写，元素按照转换为字符串的各个字符的 Unicode 位点进行排序 const months = [&amp;#39;March&amp;#39;, &amp;#39;Jan&amp;#39;, &amp;#39;Feb&amp;#39;, &amp;#39;Dec&amp;#39;]; months.sort(); console.log(months); // [&amp;#34;Dec&amp;#34;, &amp;#34;Feb&amp;#34;, &amp;#34;Jan&amp;#34;, &amp;#34;March&amp;#34;] const array1 = [1, 30, 4, 21, 100000]; array1.sort(); console.log(array1); // [1, 100000, 21, 30, 4] 如果指明了 compareFunction 参数 ，那么数组会按照调用该函数的返回值排序，即 a 和 b 是两个将要被比较的元素： 如果 compareFunction（a, b)小于 0，那么 a 会被排列到 b 之前； 如果 compareFunction（a, b)等于 0，a 和 b 的相对位置不变； 如果 compareFunction（a, b)大于 0，b 会被排列到 a 之前。 sort 源码分析</description></item><item><title>毎日のフロントエンド 149</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-149/</link><pubDate>Sat, 12 Feb 2022 16:50:12 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-149/</guid><description>第一百四十九日 HTML Question: 整个页面中的内容设置成只读，不可编辑的状态 body { pointer-events: none !important; } Tips 数组排序 比较类排序：通过比较来决定元素间的相对次序，其时间复杂度不能突破 O(nlogn)，因此也称为非线性时间比较类排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 排序的分类
冒泡排序 let a = [1, 3, 6, 3, 23, 76, 1, 34, 222, 6, 456, 221]; function bubbleSort(array) { const len = array.length; if (len &amp;lt; 2) return array; for (let i = 0; i &amp;lt; len; i++) { for (let j = 0; j &amp;lt; i; j++) { if (array[j] &amp;gt; array[i]) { const temp = array[j]; array[j] = array[i]; array[i] = temp; } } } return array; } bubbleSort(a); // [1, 1, 3, 3, 6, 6, 23, 34, 76, 221, 222, 456] 快速排序 最主要的思路是从数列中挑出一个元素，称为 “基准”（pivot）；然后重新排序数列，所有元素比基准值小的摆放在基准前面、比基准值大的摆在基准的后面；在这个区分搞定之后，该基准就处于数列的中间位置；然后把小于基准值元素的子数列（left）和大于基准值元素的子数列（right）递归地调用 quick 方法排序完成。 let a = [1, 3, 6, 3, 23, 76, 1, 34, 222, 6, 456, 221]; function quickSort(array) { let quick = function (arr) { if (arr.</description></item><item><title>毎日のフロントエンド 147</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-147/</link><pubDate>Thu, 10 Feb 2022 12:56:13 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-147/</guid><description>第一百四十六日 HTML Question: 本地存储的生命周期 cookie: expire 和 max-age 都能控制数据的存储时间。expire 是一个绝对的过期时间，max-age 是文档被访问之后的存活时间（是相对时间）。默认是 session (一次会话) sessionStorage: 当会话被关闭后（浏览器、标签页被关闭），就会被清除。与 localStorage 用法一样 localStorage: 除非被主动清除，不然永久储存在浏览器中 IndexedDB: 没有过期时间，除非主动清除 CSS Question: background-attachment属性 background-attachment: fixed / scroll / local： 设置背景图像是否固定或者随着页面的其余部分滚动。 fixed: 背景图片不会随着页面的滚动而滚动 scroll: 背景图片随着页面的滚动而滚动，默认 local: 背景图片会随着元素内容的滚动而滚动 inherit: 指定 background-attachment 的设置应该从父元素继承。 Tips 数组扁平化 数组的扁平化其实就是将一个嵌套多层的数组 array（嵌套可以是任何层数）转换为只有一层的数组。
方法一：普通的递归实现 // 方法1 // 在遍历过程中发现数组元素还是数组的时候进行递归操作， // 把数组的结果通过数组的 concat 方法拼接到最后要返回的 result 数组上，那么最后输出的结果就是扁平化后的数组。 var a = [1, [2, [3, 4, 5]]]; function flatten(arr) { let result = []; for (let i = 0; i &amp;lt; arr.</description></item><item><title>毎日のフロントエンド 146</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-146/</link><pubDate>Wed, 09 Feb 2022 11:17:27 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-146/</guid><description>第一百四十六日 HTML Question: viewport 是什么？在什么时候下使用 viewport 是用户网页的可视区域 多用于移动端，也可以用在支持类似“固定到边缘”等特性的桌面浏览器 移动端的浏览器是把页面放在一个虚拟的&amp;quot;窗口&amp;quot;（viewport）中，通常这个虚拟的&amp;quot;窗口&amp;quot;（viewport）比物理屏幕宽，这样就不用把每个网页挤到很小的窗口中（这样会破坏没有针对手机浏览器优化的网页的布局），用户可以通过平移和缩放来看网页的不同部分 visual viewport 尺寸所对应的并不是指屏幕区域里的物理像素，而是 CSS 像素。并且它所包含的 CSS 像素的数量也是随着用户缩放而有所改变 在 head 加入这行，把默认的 layout viewport 的宽度设为移动设备的屏幕宽度，也就是把当前的 viewport 宽度设置为设备物理屏幕的宽度，实现全屏的效果 &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no&amp;quot;&amp;gt; Tips 类数组 函数里面的参数对象 arguments 用 getElementsByTagName/ClassName/Name 获得的 HTMLCollection 用 querySelector 获得的 NodeList arguments对象 只定义在函数体中 有一个 length 属性 callee 属性(此函数自身) function foo(name, age, sex) { console.log(arguments); // [Arguments] { &amp;#39;0&amp;#39;: &amp;#39;jack&amp;#39;, &amp;#39;1&amp;#39;: &amp;#39;18&amp;#39;, &amp;#39;2&amp;#39;: &amp;#39;male&amp;#39; } console.</description></item><item><title>毎日のフロントエンド 145</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-145/</link><pubDate>Tue, 08 Feb 2022 20:47:08 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-145/</guid><description>第一百四十五日 HTML Question: 表单属性type=&amp;quot;hidden&amp;quot; &amp;lt;input type=&amp;quot;hidden&amp;quot;&amp;gt; &amp;ldquo;hidden&amp;rdquo; 类型的 &amp;lt;input&amp;gt; 元素允许 Web 开发者存放一些用户不可见、不可改的数据，在用户提交表单时，这些数据会一并发送出。比如，正被请求或编辑的内容的 ID，或是一个唯一的安全令牌。这些隐藏的 &amp;lt;input&amp;gt;元素在渲染完成的页面中完全不可见，而且没有方法可以使它重新变为可见。 隐藏域在页面中对于用户是不可见的，在表单中插入隐藏域的目的在于收集或发送信息，以利于被处理表单的程序所使用。浏览者单击发送按钮发送表单的时候，隐藏域的信息也被一起发送到服务器 有些时候要给用户一信息，在提交表单时一同提交,以确定用户身份，如 sessionkey 等．同样也可以用 cookie 实现，但使用隐藏域就简单的多了．兼容性好，且可以避免被禁用cookies 一个 form 里有多个提交按钮，怎样使程序能够分清楚到底用户是按那一个按钮提交上来的呢？ 这时可以添加隐藏域，然后在每一个按钮处加上 οnclick=&amp;ldquo;document.form.command.value=&amp;ldquo;xx&amp;rdquo;， 然后接到数据后先检查 command 的值就会知道用户是按的那个按钮提交上来的 一个网页中有多个 form，我们知道多个 form 是不能同时提交的，但有时这些 form 确实相互作用，我们就可以在 form 中添加隐藏域来使它们联系起来 JavaScript Question: 原生 Math 的方法有哪些 常用方法
Math.abs(num) // num绝对值 Math.ceil(num) // num向上取整 Math.floor(num) // num向下取整 Math.max(num1, num2 ...) // 取较大值 Math.min(num1, num2 ...) // 取较小值 Math.pow(num1, num2) // num1的num2次幂 Math.</description></item></channel></rss>