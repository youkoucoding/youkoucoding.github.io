<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tips on 技術の手帳</title><link>https://youkoucoding.github.io/categories/tips/</link><description>Recent content in Tips on 技術の手帳</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 30 Jun 2022 23:35:17 +0900</lastBuildDate><atom:link href="https://youkoucoding.github.io/categories/tips/index.xml" rel="self" type="application/rss+xml"/><item><title>毎日のフロントエンド 351</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-351/</link><pubDate>Thu, 30 Jun 2022 23:35:17 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-351/</guid><description>CSS 哪些标签是不支持伪元素 伪元素用双冒号 要标签支持伪元素，需要这个元素是要可以插入内容 br, input，img，iframe 等元素都不能包含其他元素，所以不能通过伪元素插入内容 Reference fe-interview/history.md</description></item><item><title>毎日のフロントエンド 350</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-350/</link><pubDate>Wed, 29 Jun 2022 23:40:27 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-350/</guid><description>JavaScript Math.ceil(), Math.round(), Math.floor() Math.ceil() 函数返回大于或等于一个给定数字的最小整数 console.log(Math.ceil(0.95)); // expected output: 1 console.log(Math.ceil(4)); // expected output: 4 console.log(Math.ceil(7.004)); // expected output: 8 console.log(Math.ceil(-7.004)); // expected output: -7 Math.round() 函数返回一个数字四舍五入后最接近的整数
Math.floor() 返回小于或等于一个给定数字的最大整数
Reference fe-interview/history.md
Math.floor() - JavaScript | MDN
Math.ceil() - JavaScript | MDN
Math.round() - JavaScript | MDN</description></item><item><title>毎日のフロントエンド 346~349</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-346~349/</link><pubDate>Tue, 28 Jun 2022 23:07:09 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-346~349/</guid><description>CSS shape-outside shape-outside的 CSS 属性定义了一个可以是非矩形的形状，相邻的内联内容应围绕该形状进行包装。默认情况下，内联内容包围其边距框; shape-outside提供了一种自定义此包装的方法，可以将文本包装在复杂对象周围而不是简单的框中。 Tips API 设计原则 好 API 的特质 极简： 完备： 语义清晰简单 符合直觉 易于记忆 引导 API 使用者写出可读代码 静态多态 尽量减少继承，让相似的类具备相似的 API，而不是统一继承一个父类。因为统一继承会带来 API public 数量过多，父级无意义的方法对用户产生误导 基于属性的 API 属性指的是对象状态，通过属性为粒度的 API，有利于使用者理解 API 的含义，但需注意关联属性的顺序性 API 语义和文档 比如传值 -1 的含义是什么？如果 API 文档不像 http status codes 一样健全，建议通过枚举的方式增加可读性 命名的艺术 不要使用缩写，保持一致性。类命名以功能分组作为后缀，比零散命名更易懂 函数命名要体现出是否包含副作用，参数过多时以对象作为传参，布尔参数改为枚举类型，或者分解为两个语义化 API 统一关键字库 所有 api 定义之前，先抽离业务和功能语义的关键字，统一关键字库; 可以更好的让多人协作看起来如出一辙, 而且关键字库 更能够让调用者感觉到 符合直觉、语义清晰; 关键字库也是 PREDO 的内容之一 单一职责 接口设计尽量要做到 单一职责,最细粒度化; 可以使用组合的方式把多个解耦的单个接口组合在一起作为一个大的功能项接口; 接口设计的单一职责，也更方便多人协作时候的扩展和组合; 面向未来的多态 对于接口参数的扩展，我们要做到面向扩展开放，面向修改关闭; 升级做到要兼容，否则会导致大批量的下游不可用 同时也要避免过度设计，当抽象功能只有一处使用时，尽量不要过早抽象 Reference fe-interview/history.md
shape-outside - CSS（层叠样式表） | MDN</description></item><item><title>毎日のフロントエンド 303~304</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-303~304/</link><pubDate>Mon, 30 May 2022 21:43:28 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-303~304/</guid><description>HTML html 的嵌套规范 HTML 标签包括 块级元素(block)、行内元素（inline） 块级元素，一般用来搭建网站架构、布局、承载内容……它包括以下这些标签： address、blockquote、center、dir、div、dl、dt、dd、fieldset、form、h1~h6、hr、isindex、menu、noframes、noscript、ol、p、pre、table、ul 行内元素　一般用在网站内容之中的某些细节或部位，用以“强调、区分样式、上标、下标、锚点”等等，下面这些标签都属于内嵌元素： a、abbr、acronym、b、bdo、big、br、cite、code、dfn、em、font、i、img、input、kbd、label、q、s、samp、select、small、span、strike、strong、sub、sup、textarea、tt、u、var HTML 标签的嵌套规则 块元素可以包含内联元素或某些块元素，但内联元素却不能包含块元素，它只能包含其它的内联元素 块级元素不能放在&amp;lt;p&amp;gt;里面： 有几个特殊的块级元素只能包含内嵌元素，不能再包含块级元素，这几个特殊的标签是： h1、h2、h3、h4、h5、h6、p、dt li 内可以包含 div 标签： li 和 div 标 签都是装载内容的容器，没有级别之分（例如：h1、h2），li 标签连它的父级 ul 或者是 ol 都 可以容纳 块级元素与块级元素并列、内嵌元素与内嵌元素并列： a标签不能嵌套a img alt 属性 alt 属性是一个必需的属性，它规定在图像无法显示时的替代文本 加 alt 属性提示文本的好处： 有利于 SEO 优化，让搜索引擎爬虫蜘蛛爬取关键词 在很多情况下用户无法查看图像，可以让用户明白图片的意思，提高用户体验 搜索引擎会对网站的 title 以及 alt 分析，进而分类进行排序 CSS img 标签是行内元素，为什么能设置宽高 置换元素（Replaced Element）：可以设置宽高,有自己的属性，和 inline-block 有一样的属性，主要是指 img、input、textarea、select、object 等这类默认有宽高样式的元素。浏览器根据元素的标签和属性，来决定元素的具体显示内容,例如：浏览器根据标签的 src 属性显示图片。根据 type 属性决定显示输入框还是按钮 Reference fe-interview/history.md
可替换元素 - CSS（层叠样式表） | MDN</description></item><item><title>毎日のフロントエンド 298</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-298/</link><pubDate>Sun, 29 May 2022 14:57:59 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-298/</guid><description>CSS initial、inherit、unset、revert initial（初始）、inherit（继承）、unset（未设置）、revert（还原）
inherit 可以继承父级元素的属性
initial则是不继承
unset 表示如果该属性默认可继承，则值为inherit，否则值为initial
revert 表示样式表中定义的元素属性的默认值。若用户定义样式表中显式设置，则按此设置；否则，按照浏览器定义样式表中的样式设置；否则，等价于unset
取消从父级元素继承下来的 CSS 样式 如果是恢复单个属性样式，例如 font-size，可以使用 font-size: initial; 如果是将所有属性样式恢复为默认状态，可以使用 all: intial; height:100%和height:inherit 父容器height: auto，无论height:100%或者height:inherit表现都是auto 父容器定高height: 100px，无论height:100%或者height:inherit表现都是100px 当子元素为绝对定位元素，同时，父容器的position: static的时候
height:100%和 height:inherit 差异演示
height:inherit 高度自适应没有定位特性的父级元素, 容器高度变化了，里面的绝对定位元素依然高度自适应
JavaScript 删除字符串中所有相邻重复的项 'aabbaaaaccdeee'.replace(/(.)\1*/g, '$1'); // abacde Tips 304 协商缓存: 向服务器发送请求，服务器会根据这个请求的 request header 的一些参数来判断是否命中协商缓存，如果命中，则返回 304 状态码并带上新的 response header 通知浏览器从缓存中读取资源； 请求头：if-modified-since if-none-match 与 响应头：last-modified etag 比较 Reference fe-interview/history.md
HTML &amp;lt;area&amp;gt;&amp;lt;map&amp;gt;标签及在实际开发中的应用
CSS 中 height:100%和 height:inherit 的异同</description></item><item><title>毎日のフロントエンド 296~297</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-296~297/</link><pubDate>Sat, 28 May 2022 17:24:12 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-296~297/</guid><description>HTML 文字贯穿线 &amp;lt;del&amp;gt;&amp;lt;/del&amp;gt; CSS font-size-adjust font-size-adjust CSS 属性定义字体大小应取决于小写字母，而不是大写字母。 在字体较小时，字体的可读性主要由小写字母的大小决定，通过此选项即可进行调整。 @font-face src 远程字体文件位置的 URL 或者用户计算机上的字体名称， 可以使用 local 语法通过名称指定用户的本地计算机上的字体( i.e. src: local(&amp;lsquo;Arial&amp;rsquo;); )。 如果找不到该字体，将会尝试其他来源，直到找到它。 Tips setTimeout 和 setInterval setTimeout() 只执行函数一次, 也就是说当达到设定的时间后就开始运行指定的代码，运行完后就结束了，次数是一次 setInterval() 是循环执行的, 即每达到指定的时间间隔就执行相应的函数或者表达式，只要窗口不关闭或 clearInterval() 调用就会无限循环下去 使用 setInterval 时，某些间隔会被跳过；即使 setInterval 调用的方法报错了，他仍然会继续执行。 无视网络延迟，可能多个定时器会连续执行 React 代码整洁之道 不冗余 避免重复代码段，对 JSX 同理： // Dirty const MyComponent = () =&amp;gt; ( &amp;lt;div&amp;gt; &amp;lt;OtherComponent type=&amp;#39;a&amp;#39; className=&amp;#39;colorful&amp;#39; foo={123} bar={456} /&amp;gt; &amp;lt;OtherComponent type=&amp;#39;b&amp;#39; className=&amp;#39;colorful&amp;#39; foo={123} bar={456} /&amp;gt; &amp;lt;/div&amp;gt; ); // Clean const MyOtherComponent = ({ type }) =&amp;gt; ( &amp;lt;OtherComponent type={type} className=&amp;#39;colorful&amp;#39; foo={123} bar={456} /&amp;gt; ); const MyComponent = () =&amp;gt; ( &amp;lt;div&amp;gt; &amp;lt;MyOtherComponent type=&amp;#39;a&amp;#39; /&amp;gt; &amp;lt;MyOtherComponent type=&amp;#39;b&amp;#39; /&amp;gt; &amp;lt;/div&amp;gt; ); 可预测、可测试 americanexpress/jest-image-snapshot: ✨ Jest matcher for image comparisons.</description></item><item><title>毎日のフロントエンド 295</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-295/</link><pubDate>Fri, 27 May 2022 23:20:28 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-295/</guid><description>HTML &amp;lt;article&amp;gt; 和 &amp;lt;section&amp;gt; 区别 &amp;lt;article&amp;gt; 标签定义外部的内容，比如来自 blog 的文本。其内容独立于文档的其余部分 &amp;lt;section&amp;gt; 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分 CSS body{height:100%}和html,body{height:100%}有什么区别？为什么 html 要设置height:100% html 是 body 的父级，在缺少了父级的宽高之后，如果给 body 设置一个渐变色背景的话将不会正常显示 一个 div 块级元素没有主动为其设置宽度和高度，浏览器会为其分配可使用的最大宽度(比如全屏宽度)，但是不负责分配高度，块级元素的高度是由子元素堆砌撑起来的。那么，html 和 body 标签的高度也都是由子级元素堆砌撑起来的 元素高度百分比需要向上遍历父标签要找到一个定值高度才能起作用，如果中途有个 height 为 auto 或是没有设置 height 属性，则高度百分比不起作用，此时的情况是父元素高度依赖子元素堆砌撑高，而子元素依赖父元素的定高起作用，互相依赖，却都无法依赖(body 如果为默认设置，它的高度值为 auto，会根据子元素的高度来支撑高度。倘若子元素的高度设置为依赖父元素(body)的高度来支持的百分比数值，那么就形成了悖论。最后浏览器找不到计算高度的情况下，body 的高度实际被设置为 0) html, body { height: 100%; margin: 0; padding: 0; } Tips Reference fe-interview/history.md</description></item><item><title>毎日のフロントエンド 289~294</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-289~294/</link><pubDate>Wed, 25 May 2022 23:52:09 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-289~294/</guid><description>Tips postMessage window.postMessage() 方法可以安全地实现跨源通信。 通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为 https），端口号（443 为 https 的默认值），以及主机 (两个页面的模数 Document.domain 设置为相同的值) 时，这两个脚本才能相互通信。 window.postMessage() 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。 Expires Cache-Control ETag Expires 响应头包含日期/时间， 即在此时候之后，响应过期。 无效的日期，比如 0, 代表着过去的日期，即该资源已经过期。 如果在 Cache-Control 响应头设置了 &amp;ldquo;max-age&amp;rdquo; 或者 &amp;ldquo;s-max-age&amp;rdquo; 指令，那么 Expires 头会被忽略。 Cache-Control Cache-Control 通用消息头字段，被用于在 http 请求和响应中，通过指定指令来实现缓存机制。缓存指令是单向的，这意味着在请求中设置的指令，不一定被包含在响应中。 不区分大小写，但建议使用小写。 多个指令以逗号分隔。 具有可选参数，可以用令牌或者带引号的字符串语法。 ETag ETagHTTP 响应头是资源的特定版本的标识符。这可以让缓存更高效，并节省带宽，因为如果内容没有改变，Web 服务器不需要发送完整的响应。而如果内容发生了变化，使用 ETag 有助于防止资源的同时更新相互覆盖（“空中碰撞”）。
如果给定 URL 中的资源更改，则一定要生成新的 Etag 值。 因此 Etags 类似于指纹，也可能被某些服务器用于跟踪。 比较 etags 能快速确定此资源是否变化，但也可能被跟踪服务器永久存留。
null &amp;gt;= 0 大于判断 a &amp;gt; b 调用 b 的 ToPrimitive(hit Number) 方法.</description></item><item><title>毎日のフロントエンド 286~288</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-286~288/</link><pubDate>Tue, 24 May 2022 22:13:40 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-286~288/</guid><description>CSS css 属性恢复为初始化状态 all:unset 移动端 1px 像素问题及解决办法 为什么会有 1px 问题 物理像素-设备像素 &amp;amp; 逻辑像素-CSS 像素 物理像素：移动设备出厂时，不同设备自带的不同像素，也称硬件像素； 逻辑像素：css 中记录的像素 移动端 CSS 里面写了 1px，实际上看起来比 1px 粗； 设计师要求的 1px 是指设备的物理像素 1px，而 CSS 里记录的像素是逻辑像素，它们之间存在一个比例关系，通常可以用 javascript 中的 window.devicePixelRatio 来获取 也可以用媒体查询的 -webkit-min-device-pixel-ratio 来获取 iPhone 的 devicePixelRatio==2, 而 border-width: 1px; 描述的是设备独立像素，所以，border 被放大到物理像素 2px 显示，在 iPhone 上就显得较粗 解决方案 1. transform: scale(0.5) 方案 - 推荐: 很灵活 设置height: 1px，根据媒体查询结合transform缩放为相应尺寸 div { height: 1px; background: #000; -webkit-transform: scaleY(0.5); -webkit-transform-origin: 0 0; overflow: hidden; } 用::after和::before,设置border-bottom：1px solid #000,然后在缩放-webkit-transform: scaleY(0.</description></item><item><title>毎日のフロントエンド 279~285</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-279~285/</link><pubDate>Mon, 23 May 2022 20:31:14 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-279~285/</guid><description>HTML html 缺少了结束标签，如何检测预防 W3C 验证服务：The W3C Markup Validation Service CSS baseline baseline 是西文字体里面的一种定位 vertical-align:baseline 是指行内元素里的文字，在垂直方向上，按字体的基线排列， axec 这些字母的底部就是baseline，然后 lh 的 baseline 也一样 g的baseline则在于中间，就是西文字体如何在一条看不见的线上排练形成整齐的视觉效果 JavaScript Window.getSelection 返回一个 Selection 对象，表示用户选择的文本范围或光标的当前位置。 Tips V8 引擎特性带来的的 JS 性能变化 try catch 对性能的影响忽略不计 Callback Promise Generator Async-Await 和异常处理的演进 · Issue #14 · ascoders/blog 解决 delete 性能问题 arguments 转数组性能已不是问题 node8.3 版本及以上，该使用拓展运算符获取参数，不但没有性能问题，可读性也大大提高，结合 ts 时也能得到类型支持 bind 对性能影响可以忽略 在 react 中副作用仍需警惕, 推荐使用箭头函数书写成员函数 函数调用对性能影响越来越小 对函数调用优化的越来越好，不需要过于担心注释与空白、函数间调用对性能的影响 32 64 位数字计算性能 node8 对超长数字计算性能还是较低，大概是 32 位数字性能的 2/3，所以尽量用字符串处理大数 遍历 object 基本用法有 for in Object.</description></item><item><title>毎日のフロントエンド 277~278</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-277~278/</link><pubDate>Sun, 22 May 2022 11:55:05 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-277~278/</guid><description>HTML 选择合适的元素来编写代码可保证代码的易读性 使用&amp;lt;h1&amp;gt;&amp;lt;h2&amp;gt;&amp;lt;h3&amp;gt;表示标题，&amp;lt;ul&amp;gt;或&amp;lt;ol&amp;gt;实现列表 注意使用&amp;lt;article&amp;gt;标签之前应添加&amp;lt;h1&amp;gt;标签 选择合适的 HTML5 语义元素如&amp;lt;header&amp;gt;，&amp;lt;footer&amp;gt;, &amp;lt;nav&amp;gt;, &amp;lt;aside&amp;gt; 使用&amp;lt;p&amp;gt;描述 Body 文本，HTML5 语义元素可以形成内容，反之不成立 使用&amp;lt;em&amp;gt;和&amp;lt;strong&amp;gt;标签替代 i 和 b 标签。 使用&amp;lt;label&amp;gt;元素，输入类型，占位符及其他属性来强制验证。 使用&amp;lt;p&amp;gt;元素修饰文本，而不是布局；默认&amp;lt;p&amp;gt;是自动提供边缘，而且其他样式也是浏览器默认提供的 避免使用&amp;lt;br&amp;gt;分行，可以使用 block 元素或 CSS 显示属性来代替 避免使用&amp;lt;hr&amp;gt;来添加水平线，可使用 CSS 的 border-bottom 来代替 不到关键时刻不要使用 div 标签 尽量少用 Table 来布局 可以多使用 FlexBox 使用 CSS 来调整边距等 JavaScript 判断一个数是否为整数 let isInteger=n=&amp;gt; typeof(n)!='NAN'&amp;amp;&amp;amp;n%1===0 Tips Web fonts should I use Web Font and when Web Font 最大的弊端在于它是异步加载的，没有办法避免下载它所用的时间 预加载，对于字体，浏览器是能够有效缓存的，如果能够做好预加载，不会太影响用户体验 link 的 rel=preload 来做预加载 JS 有一些库在支持这方面功能，例如 bramstein/fontfaceobserver 通常加载字体是在 CSS 中的@font-face 被读到的时候才去加载的，那么就会出现先加载 CSS，后加载字体的情况 如果利用 link 预加载，那么在 CSS 中的@font-face 被读到前就已经开始加载了，那么字体加载和 CSS 加载就可以同时加载，提升速度 Reference fe-interview/history.</description></item><item><title>毎日のフロントエンド 276</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-276/</link><pubDate>Fri, 20 May 2022 23:50:25 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-276/</guid><description>HTML html 的标签元素分为哪几大类 HTML 文档标签 &amp;lt;!DOCTYPE&amp;gt;：定义文档类型 &amp;lt;html&amp;gt;： 定义 HTML 文档 &amp;lt;head&amp;gt;：定义文档的头部 &amp;lt;meta&amp;gt;：定义元素可提供的有关页面的元信息，比如针对搜索引擎和更新频度的描述和关键字 &amp;lt;base&amp;gt;：定义页面上的所有链接规定默认地址或默认目标 &amp;lt;title&amp;gt;：定义文档标题 &amp;lt;link&amp;gt;：定义文档与外部资源的关系 &amp;lt;style&amp;gt;：定义 HTML 文档样式信息 &amp;lt;body&amp;gt;：定义文档的主体。（脚本在非必需情况时在的最后） &amp;lt;script&amp;gt;：定义客户端脚本，比如 javascript。 &amp;lt;noscript&amp;gt;：定义脚本未被执行时的替代内容。（如文本） 按闭合特征分类 空标签 &amp;lt;br&amp;gt; &amp;lt;hr&amp;gt; &amp;lt;img&amp;gt; &amp;lt;input&amp;gt; &amp;lt;link&amp;gt; &amp;lt;meta&amp;gt; 是否换行 块级元素 块级元素的特点： 每个块级元素独占一行，每个块级元素都会从新的一行开始，从上到下排布 块级元素可以直接控制宽度、高度以及盒子模型的相关 css 属性 在不设置宽度的情况下，块级元素的宽度是他父级元素内容的宽度 在不设置高度的情况下，块级元素的高度是他本身内容的高度 内联元素 内联元素的特点： 内联元素会和其他元素从左到右显示在一行 内联元素不能直接控制宽度、高度以及盒子模型的相关 css 属性，但是可以设置内外边距的水平方向的值。 对于内联元素的 margin 和 padding，只有 margin-left/margin-right 和 padding-left/padding-right 是有效的，但是竖直方向的 margin 和 padding 无效果 内联元素的宽高是由内容本身的大小决定的（文字、图片等） 内联元素只能容纳文本或者其他内联元素（不要在内联元素中嵌套块级元素） 前端调试技巧 Must Read Dev Tips - Developer Tips by Umar Hansa</description></item><item><title>毎日のフロントエンド 271~275</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-271~275/</link><pubDate>Thu, 19 May 2022 21:06:57 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-271~275/</guid><description>Tips 移动端禁止用户手动缩放页面 &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no&amp;quot;&amp;gt; Array.prototype.sort() sort() 方法用原地算法对数组的元素进行排序，并返回数组。 默认排序顺序是在将元素转换为字符串，然后比较它们的 UTF-16 代码单元值序列时构建的 JS 错误堆栈处理 JavaScript 中主要是通过 Error 对象和 Stack Traces 提供有价值的错误堆栈，帮助开发者调试。在服务端开发中，开发者可以将有价值错误信息打印到服务器日志中，而对于客户端而言就很难重现用户环境下的报错
Stack js 中函数调用栈的概念，符合栈的基本特性『当调用时，压入栈顶。当它执行完毕时，被弹出栈』 function c() { try { var bar = baz; throw new Error(); } catch (e) { console.log(e.stack); } } function b() { c(); } function a() { b(); } a(); 上述代码中会在执行到 c 函数的时候跑错，调用栈为 a -&amp;gt; b -&amp;gt; c, 错误堆栈可以帮助定位到报错的位置 Error 对象 Error 对象，主要有两个重要属性 message 和 name 分别表示错误信息和错误名称, 除了这两个属性还有一个未被标准化的 stack 属性 e.</description></item><item><title>毎日のフロントエンド 264~270</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-264~270/</link><pubDate>Wed, 18 May 2022 23:05:00 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-264~270/</guid><description>Tips MIME 媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型 ）是一种标准，用来表示文档、文件或字节流的性质和格式 常用类型 text/plain text/html image/jpeg image/png audio/mpeg audio/ogg audio/* video/mp4 application/* application/json application/javascript application/ecmascript application/octet-stream AsyncAwait 优越之处 Async/Await 的优点：
语法简洁清晰，节省了很多不必要的匿名函数 直接使用 try&amp;hellip;catch&amp;hellip; 进行异常处理 添加条件判断更符合直觉 减少不必要的中间变量 更清晰明确的错误堆栈 调试时可以轻松给每个异步调用加断点 Async/Await 是如何实现的
根据 Async/Await 的规范 中的描述 —— 一个 Async 函数总是会返回一个 Promise async function test() { const img = await fetch(&amp;#39;tiger.jpg&amp;#39;); } Babel
&amp;#39;use strict&amp;#39;; var test = (function () { var _ref = _asyncToGenerator( regeneratorRuntime.</description></item><item><title>毎日のフロントエンド 261~263</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-261~263/</link><pubDate>Mon, 16 May 2022 21:40:43 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-261~263/</guid><description>Tips 移动端滚动穿透 什么是滚动穿透 移动端开发中在页面上进行弹窗、加浮层等，在上面滑动时，下面的内容也在跟随滚动，即滚动“穿透”到了下方，即滚动穿透（scroll-chaining） 原因 CSSOM View Module
首先滚动的 target 可以是 document 和里面的 element 其次，在 element 上的 scroll 事件是不冒泡的，document 上的 scroll 事件冒泡。 想通过在 scroll 的节点上去阻止它的滚动事件冒泡来解决问题是不可行的, 因为它根本就不冒泡，无法触及 dom tree 的父节点， 因此也无法触发滚动 解决 overflow: hidden 如果遮罩层是透明的，弹出后用户仍然会看到丢失距离后的下方页面
.modal--open { height: 100%; overflow: hidden; } prevent touch event 直接阻止掉遮罩层和弹窗的 touch event 这样就不会在移动端触发 scroll 事件了。但是在 PC 上没有 touch 事件， scroll 事件仍然可以被触发 &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;mask&amp;#34;&amp;gt;mask&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;dialog&amp;#34;&amp;gt;dialog&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; const $mask = document.querySelector(&amp;#39;.mask&amp;#39;); const $dialog = document.</description></item><item><title>毎日のフロントエンド 257~260</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-257~260/</link><pubDate>Sun, 15 May 2022 21:07:28 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-257~260/</guid><description>CSS opacity: 0、visibility: hidden、display: none opacity: 0 : 单纯视觉效果，除了看不见，其他都正常, 不会改变页面布局，能触发点击事件的 visibility: hidden : 可继承也可覆盖, 不会触发该元素已经绑定的事件 display: none : 元素不会渲染，不影响布局，不会被 css 计数，也不支持 transition, 动态创建和销毁元素，会改变页面布局且忽略掉该元素的权重 Tips js 事件中currentTarget和target的区别 event.currentTarget Event 接口的只读属性 currentTarget 表示的，标识是当事件沿着 DOM 触发时事件的当前目标。它总是指向事件绑定的元素，而 Event.target 则是事件触发的元素。 Event.target 触发事件的对象 (某个 DOM 元素) 的引用。当事件处理程序在事件的冒泡或捕获阶段被调用时，它与 event.currentTarget 不同。 CDN The History of Content Delivery Networks (CDN) | GlobalDots Reference fe-interview/history.md
Event.target - Web API 接口参考 | MDN
event.currentTarget - Web API 接口参考 | MDN</description></item><item><title>毎日のフロントエンド 250~252</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-250~252/</link><pubDate>Thu, 12 May 2022 23:42:06 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-250~252/</guid><description>HTML CSS PPI和DP PPI（pixel per inch）：像素密度，1 英寸屏幕上显示的像素量。值越高，屏幕越细腻
DP（Density-independent pixel）：安卓开发用的长度单位
1dp 等于屏幕像素密度为 160ppi 时 1px 的长度，因此 dp 在整个系统大小是固定的。
公式：1dp=（屏幕 ppi / 160）px。 radio和checkbox自定义样式 方法一：appearance + :after 利用 appearance 属性清除 radio 或 checkbox 的原生样式，然后在此基础添加上一些自定义的样式和动画效果，以达到自定义样式的目的。 用到了:after 伪元素生成控件内部的选中样式。 input[type=&amp;#39;radio&amp;#39;], input[type=&amp;#39;checkbox&amp;#39;] { appearance: none; } &amp;lt;div class=&amp;#34;dz-switch&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;checkbox&amp;#34; name=&amp;#34;c1&amp;#34; /&amp;gt; &amp;lt;input type=&amp;#34;checkbox&amp;#34; name=&amp;#34;c1&amp;#34; checked /&amp;gt; &amp;lt;/div&amp;gt; @color-error: #f56c6c; @color-black: #000; .dz-switch { margin: 30px; font-size: 18px; input[type=&amp;#39;radio&amp;#39;], input[type=&amp;#39;checkbox&amp;#39;] { -webkit-appearance: none; -moz-appearance: none; position: relative; display: inline-block; vertical-align: middle; margin: -0.</description></item><item><title>毎日のフロントエンド 243~249</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-243~249/</link><pubDate>Wed, 11 May 2022 20:49:25 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-243~249/</guid><description>HTML 如何不让网页嵌入iframe HTTP 响应头信息中的X-Frame-Options，可以指示浏览器是否应该加载一个 iframe 中的页面。如果服务器响应头信息中没有 X-Frame-Options，则该网站存在 ClickJacking 攻击风险。网站可以通过设置 X-Frame-Options 阻止站点内的页面被其他页面嵌入从而防止点击劫持 deny：表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许 sameorigin：表示该页面可以在相同域名页面的 frame 中展示 allow-from uri：表示该页面可以在指定来源的 frame 中展示 CSS 代替 html5 中不再支持 table 的 cellspacing 和 cellpadding 属性 border-spacing em em em 是相对元素本身的 font-size 的相对单位，比如元素本身的 font-size 是 14px，那么 1.2em = 1.2 * 14px = 16.8px。注意，是相对元素本身的 font-size，会随着元素的 font-size 的改变而改变
em 用于设置元素的 padding, margin, border-radius
useState Reference fe-interview/history.md</description></item><item><title>毎日のフロントエンド 242</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-242/</link><pubDate>Tue, 10 May 2022 23:01:30 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-242/</guid><description>Tips useState state结构 useState 接收一个 initialState，同时返回一个 state 以及更新 state 的函数 不推荐将数据集中于一个 useState 避免重复计算 如果 initialState 为函数，则 useState 在初始化时会立刻执行该函数和获取函数的返回值，在没有任何返回值得情况下为 undefined 需要注意的是每次组件 re-render 都会导致 useState 中的函数重新计算，这里可以使用闭包函数来解决问题, 例如： 优化前：
const loop = () =&amp;gt; { console.log(&amp;#39;calc!&amp;#39;); let res = 0; for (let i = 0, len = 1000; i &amp;lt; len; i++) { res += i; } return res; }; const [value, setValue] = useState(loop()); 优化后：
// 优化后只有组件初始化时才会执行一遍loop函数 const App = () =&amp;gt; { const [value, setValue] = useState(() =&amp;gt; { return loop(); }); }; 更新 state 在某些情况下如果需要从上一个 state 来计算当前的 state，可能会想到使用下面优化前的方法。但是，需要注意的一点是在某些闭包的场景下面 count 可能不是最新的，这样会导致计算错误。这里推荐使用官方给出的方法。 优化前：</description></item><item><title>毎日のフロントエンド 241</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-241/</link><pubDate>Mon, 09 May 2022 23:33:18 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-241/</guid><description>HTML &amp;lt;a&amp;gt;除了用作跳转链接外，还有哪些用途 &amp;lt;a&amp;gt; - HTML（超文本标记语言） | MDN CSS vmax 和 vmin vmax和vmin都是相对于窗口大小的长度单位。 100vmax相当于 100%当前窗口长或者宽的长度，取其中最大值，vmin 反之。 如果 css 函数max()和min()普及后，100vmax 相当于 max(100vw, 100vh) 如vmin，可以在确保在保持宽高比的情况下，不论窗口如何缩放都可以不让元素超出窗口范围 Tips try..catch 不能捕获的错误有哪些 try
每个try块必须与至少一个catch或finally块，否则会抛出SyntaxError错误 try..catch 与 无效代码
try..catch 无法捕获无效的 JS 代码，例如 try 块中的以下代码在语法上是错误的，但它不会被 catch 块捕获 try { ~!$%^&amp;amp;* } catch(err) { console.log(&amp;#34;不会执行&amp;#34;); } try..catch 与 异步代码 try..catch 无法捕获在异步代码中引发的异常，例如 setTimeout： try { setTimeout(function () { noSuchVariable; // undefined variable }, 1000); } catch (err) { console.log(&amp;#39;不会执行&amp;#39;); } // 未捕获的ReferenceError将在1秒后引发: // Uncaught ReferenceError: noSuchVariable is not defined 应该在异步代码内部使用 try.</description></item><item><title>毎日のフロントエンド 232~240</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-232~240/</link><pubDate>Sun, 08 May 2022 17:39:28 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-232~240/</guid><description>HTML table 由哪几部分组成 &amp;lt;table&amp;gt;&amp;lt;/table&amp;gt; &amp;lt;tbody&amp;gt;&amp;lt;/tbody&amp;gt; &amp;lt;th&amp;gt;&amp;lt;/th&amp;gt; &amp;lt;tr&amp;gt;&amp;lt;/tr&amp;gt; &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;!-- 定义表格的标题 --&amp;gt; &amp;lt;caption&amp;gt;&amp;lt;/caption&amp;gt; &amp;lt;!-- 定义表格的页脚 --&amp;gt; &amp;lt;tfoot&amp;gt;&amp;lt;/tfoot&amp;gt; &amp;lt;!-- 定义表格的页眉 --&amp;gt; &amp;lt;thead&amp;gt;&amp;lt;/thead&amp;gt; &amp;lt;!-- 定义用于表格列的属性 --&amp;gt; &amp;lt;col&amp;gt;&amp;lt;/col&amp;gt; &amp;lt;!-- 定义表格列的组 --&amp;gt; &amp;lt;colgroup&amp;gt;&amp;lt;/colgroup&amp;gt; CSS 模拟边框跟 border 效果一样 outline, 伪元素, box-shadow class 和 id 选择器 id具有唯一性，导致样式不能重用，且权重大，容易导致权重问题。不过用 id 来选择元素的效率比 class 高, 不推荐使用id选择器 兼容浏览器的前缀 -webkit- 谷歌 -moz- 火狐 -o- opera -ms- ie Reference haizlin/fe-interview
outline - CSS（层叠样式表） | MDN
&amp;lt;table&amp;gt; - HTML（超文本标记语言） | MDN</description></item><item><title>毎日のフロントエンド 231</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-231/</link><pubDate>Sat, 07 May 2022 20:40:49 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-231/</guid><description>CSS padding和margin是相对于父元素还是子元素 padding和margin被设置为百分比的时候，这个百分比是相对于它们的包含块元素的宽度 包含块 大多数情况下，包含块就是这个元素最近的祖先块元素的内容区，但也不是总是这样
包含块有分为根元素包含块和其他元素的包含块 根元素包含块 根元素 html 的包含块是一个矩形,叫做初始化包含块(initial containing block) html外面还有空间，这个包含 html 的块就被称为初始包含块(initial containing block)，它是作为元素绝对定位和固定定位的参照物 对于连续媒体设备（continuous media），初始包含块的大小等于视口 viewport 的大小，基点在画布的原点（视口左上角） 对于分页媒体（paged media），初始包含块是页面区域（page area）, 初始包含块的 direction 属性与根元素的相同 其他元素的包含块 大多数情况下，包含块就是这个元素最近的祖先块元素的内容区 确定包含块的过程完全依赖于这个包含块的 position 属性，大致分为下列场景： 如果 position 属性是 static 或 relative 的话，包含块就是由它的最近的祖先块元素（比如说 inline-block, block 或 list-item 元素）或格式化上下文 BFC(比如说 a table container, flex container, grid container, or the block container itself)的内容区的边缘组成的 如果 position 属性是 absolute 的话，包含块就是由它的最近的 position 的值不是 static （fixed, absolute, relative, or sticky）的祖先元素的内边距区的边缘组成的 如果 position 属性是 fixed 的话，包含块就是由 viewport (in the case of continuous media) or the page area (in the case of paged media) 组成的 如果 position 属性是 absolute 或 fixed，包含块也可能是由满足以下条件的最近父级元素的内边距区的边缘组成的： transform or perspective value other than none will-change value of transform or perspective filter value other than none or a will-change value of filter (only works on Firefox).</description></item><item><title>毎日のフロントエンド 226(227)(228)(229)(230)</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-226227228229230/</link><pubDate>Fri, 06 May 2022 22:16:05 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-226227228229230/</guid><description>HTML html 规范 - Tips 标签名和属性推荐用小写 标签都需闭合，不管是单标签还是双标签 双标签不宜使用单标签闭合方式 属性值需双引号 img 标签需加上 alt img 标签推荐加上固定宽高 html 和 body 标签最好不好 部分字符推荐转义，比如 &amp;lt; link 写在 head 内，script 写在 body 内 末尾 不推荐使用已废弃的标签和属性名，比如 marquee center 等 推荐使用语义化标签 meta里设置有意义的title，keyword，description CSS css 规范 - Tips 命名规范（连字符-分隔的字符串） 文件宽度限制（每行 80 个字符） 加注释 编写选择器应有助于重用 尽量不要加 !important 避免使用 CSS 表达式 选择&amp;lt;link&amp;gt; 舍弃 @import 避免使用滤镜（IE 专有的 AlphaImageLoader 滤镜） 把样式表放在顶部 / 把 CSS 放在外部文件 压缩 CSS 不建议使用@import @import 属于 CSS，所以导入语句应写在 CSS 中，要注意的是导入语句应写在样式表的开头，否则无法正确导入外部文件； @import 是 CSS2.</description></item><item><title>毎日のフロントエンド 225</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-225/</link><pubDate>Thu, 05 May 2022 22:07:05 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-225/</guid><description>Tips offsetWidth、clientWidth、scrollWidth 三者的区别 offsetWidth: 对象整体的实际宽度，包滚动条等边线，会随对象显示大小的变化而改变
offsetWidth = contentWidth + padding * 2 + border * 2 + scrollbar
offsetWidth clientWidth: 对象内容的可视区的宽度，不包滚动条等边线，会随对象显示大小的变化而改变
clientWidth = contentWidth + padding * 2
clientWidth scrollWidth：对象的实际内容的宽度，不包边线宽度，会随对象中内容超过可视区后而变大
scrollWidth = contentWidth + padding * 2
scrollWidth Reference haizlin/fe-interview
HTMLElement.offsetWidth - Web API 接口参考 | MDN
Element.clientWidth - Web API 接口参考 | MDN
Element.scrollWidth - Web API 接口参考 | MDN</description></item><item><title>毎日のフロントエンド 224</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-224/</link><pubDate>Wed, 04 May 2022 23:14:56 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-224/</guid><description>JavaScript typeof NaN typeof NaN 结果是 &amp;rsquo;number' == 和 === 不能被用来判断一个值是否是 NaN。必须使用 Number.isNaN() 或 isNaN() 函数。在执行自比较之中：NaN，也只有 NaN，比较之中不等于它自己 NaN === NaN; // false Number.NaN === NaN; // false isNaN(NaN); // true isNaN(Number.NaN); // true function valueIsNaN(v) { return v !== v; } valueIsNaN(1); // false valueIsNaN(NaN); // true valueIsNaN(Number.NaN); // true Tips 函数式编程 Tips 在函数式编程中，函数就是一个管道（pipe） 输入一个值，就会输出来一个新的值，没有其他作用
函数的合成与柯里化 COMPOSE 如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做&amp;quot;函数的合成&amp;quot;（compose） 函数的合成还必须满足结合律 函数就像数据的管道（pipe）。那么，函数合成就是将这些管道连了起来，让数据从多个管道中穿过 CURRY 所谓&amp;quot;柯里化&amp;quot;，就是把一个多参数的函数，转化为单参数函数 Reference haizlin/fe-interview
Ramda 函数库参考教程
函数式编程入门教程
函数式编程指北</description></item><item><title>毎日のフロントエンド 223</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-223/</link><pubDate>Tue, 03 May 2022 14:30:23 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-223/</guid><description>Tips tsconfig.json 配置 The presence of a tsconfig.json file in a directory indicates that the directory is the root of a TypeScript project. The tsconfig.json file specifies the root files and the compiler options required to compile the project.
compilerOptions 编译选项是 TypeScript 配置的核心部分，compilerOptions 内的配置根据功能可以分为: target
target 选项用来指定 TypeScript 编译代码的目标，不同的目标将影响代码中使用的特性是否会被降级 target 的可选值包括 ES3、ES5、ES6、ES7、ES2017、ES2018、ES2019、ES2020、ESNext target 的默认值为 ES3，如果不配置选项的话，代码中使用的 ES6 特性，比如箭头函数会被转换成等价的函数表达式 module
module 选项可以用来设置 TypeScript 代码所使用的模块系统 如果 target 的值设置为 ES3、ES5 ，那么 module 的默认值则为 CommonJS； 如果 target 的值为 ES6 或者更高，那么 module 的默认值则为 ES6 module 还支持 ES2020、UMD、AMD、System、ESNext、None 的选项 jsx</description></item><item><title>毎日のフロントエンド 222</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-222/</link><pubDate>Mon, 02 May 2022 23:24:53 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-222/</guid><description>HTML HTML5 对元素内容进行拼写检查 spellcheck 定义是否可以检查元素的拼写错误 true: 设置在可能的情况下会去检查元素内容的拼写错误; false: 设置在可能的情况下关闭对元素内容拼写检查。 如果没有设置这个属性，默认值由元素自身类型和浏览器设置决定。默认值也可以被继承，当有祖先元素的 spellcheck 设置为 true 的情况下，子元素的默认值也是 true。 ps:
contenteditable: 是一个枚举属性，表示元素是否可被用户编辑。如果可以，浏览器会修改元素的部件以允许编辑: true 或空字符串，表示元素是可编辑的 false 表示元素不是可编辑的 CSS css 实现饼图 方法一： 使用伪元素 + transform + css 渐变实现
.pie { width: 100px; height: 100px; border-radius: 50%; background: yellowgreen; background-image: linear-gradient(to right, transparent 50%, #655 0); } .pie::before { content: &amp;#39;&amp;#39;; display: block; margin-left: 50%; height: 100%; border-radius: 0 100% 100% 0 / 50%; background-color: inherit; transform-origin: left; transform: rotate(0.</description></item><item><title>毎日のフロントエンド 221</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-221/</link><pubDate>Sun, 01 May 2022 22:26:24 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-221/</guid><description>HTML wbr 和 br 标签的区别 wbr (word break opportunity)规定在文本的何处进行添加换行符, wbr 是用来实现连续英文和数字的精准换行的，具体效果是如果宽度足够就不换行，如果宽度不足则在 wbr 元素在的位置进行换行。 它创建了一个带有换行特性的宽度为 0px 的空格。这个空格的 Unicode 编码是 U+200B，因此这个标签也可以替换为 &amp;amp;#x200b br是整行换行, 表示必须换行 CSS css 实现左右拉伸拖动 .class { resize: horizontal; } Tips GIT 场景一：添加到一个新的修改，到最新的 commit 中 # 添加这个对应的小的修改 git add . # 提交并且使用两个特殊的参数 # --amend 修改最新的一次 commit，将现在 staged change 直接添加到上一次 commit 去，不生成新的 commit # --no-edit amend 的提交不修改提交信息 git commit --amend --no-edit # 修改上一次commit的message git commit --amend 场景二：Git 时光机： reflog + reset # 显示你的 git 操作记录 # git log 有很大区别，它不仅仅是提交的记录，还有其他git的操作记录 git reflog # 会看到一系列的操作记录 # 7b6e4f8 HEAD@{0} # e7d2c90 HEAD@{1} .</description></item><item><title>毎日のフロントエンド 220</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-220/</link><pubDate>Sat, 30 Apr 2022 20:39:00 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-220/</guid><description>CSS CSS表达式 attr() CSS 表达式 attr() 用来获取选择到的元素的某一 HTML 属性值，并用于其样式。它也可以用于伪元素，属性值采用伪元素所依附的元素。
语法: attr( attribute-name &amp;lt;type-or-unit&amp;gt;? [, &amp;lt;fallback&amp;gt; ]? )
&amp;lt;p data-foo=&amp;#34;hello&amp;#34;&amp;gt;world&amp;lt;/p&amp;gt; p:before { content: attr(data-foo) &amp;#39; &amp;#39;; } result: hello world TIps TypeScript Move some complex &amp;ldquo;Extract&amp;rdquo; logic to a generic slot, meaning it only gets calculated once. export type Obj = { a: &amp;#39;FOO&amp;#39;; a2: &amp;#39;a2&amp;#39;; a3: &amp;#39;a3&amp;#39;; b: &amp;#39;b&amp;#39;; b1: &amp;#39;b1&amp;#39;; b2: &amp;#39;b2&amp;#39;; }; type ValuesOfKeysStartingWithA&amp;lt;Obj&amp;gt; = { [K in Extract&amp;lt;keyof Obj, `a${string}`&amp;gt;]: Obj[K]; }[Extract&amp;lt;keyof Obj, `a${string}`&amp;gt;]; type NewUnion = ValuesOfKeysStartingWithA&amp;lt;Obj&amp;gt;; Solution export type Obj = { a: &amp;#39;FOO&amp;#39;; a2: &amp;#39;a2&amp;#39;; a3: &amp;#39;a3&amp;#39;; b: &amp;#39;b&amp;#39;; b1: &amp;#39;b1&amp;#39;; b2: &amp;#39;b2&amp;#39;; }; type ValuesOfKeysStartingWithA&amp;lt; Obj, _ExtractedKeys extends keyof Obj = Extract&amp;lt;keyof Obj, `a${string}`&amp;gt; &amp;gt; = { [K in _ExtractedKeys]: Obj[K]; }[_ExtractedKeys]; type NewUnion = ValuesOfKeysStartingWithA&amp;lt;Obj&amp;gt;; Playground Link Reference haizlin/fe-interview</description></item><item><title>毎日のフロントエンド 219</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-219/</link><pubDate>Fri, 29 Apr 2022 20:46:00 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-219/</guid><description>Tips TypeScript dynamic elements interface Animal { name: string; } interface Human { firstName: string; lastName: string; } export const getDisplayName = (item: Animal): { displayName: string } =&amp;gt; { return { displayName: item.name }; }; const result = getDisplayName({ name: &amp;#39;PATCH&amp;#39; }); Generic Solution 当函数在调用的时候前不能确定传入的数据的类型，可用泛型 尤其如此例中，需要跟据不同参数类型返回不同的类型 interface Animal { name: string; } interface Human { firstName: string; lastName: string; } export const getDisplayName = &amp;lt;TItem extends Animal | Human&amp;gt;( item: TItem ): TItem extends Human ?</description></item><item><title>毎日のフロントエンド 218</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-218/</link><pubDate>Thu, 28 Apr 2022 23:30:17 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-218/</guid><description>CSS CSS 下兼容性的元素水平/垂直翻转实现 /*水平翻转*/ .flipx { -moz-transform: scaleX(-1); -webkit-transform: scaleX(-1); -o-transform: scaleX(-1); transform: scaleX(-1); /*IE*/ filter: FlipH; } /*垂直翻转*/ .flipy { -moz-transform: scaleY(-1); -webkit-transform: scaleY(-1); -o-transform: scaleY(-1); transform: scaleY(-1); /*IE*/ filter: FlipV; } 对于基于 webkit 核心的浏览器，如 Chrome 以及 Safari，实现元素的垂直翻转或是水平翻转也可以使用如下样式: /*水平翻转*/ .flipx { transform: rotateY(180deg); } /*垂直翻转*/ .flipy { transform: rotateX(180deg); } 水平翻转或垂直翻转不同于旋转 180 度。前者以轴为镜像，后者以点为镜像; 如果是对称元素，旋转 180 度和翻转的显示效果基本上就是一致的，但非对称元素就会看到明显差异; 目前仅 webkit 核心浏览器支持的 rotateY(180deg)，大写的 Y, 这里的 Y 表示元素以纵轴为镜像翻转，也就是水平翻转 Tips TypeScript Assertion functions inside classes</description></item><item><title>毎日のフロントエンド 217</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-217/</link><pubDate>Wed, 27 Apr 2022 23:04:13 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-217/</guid><description>HTML 页面加载后，表单的第一个文本框如何自动获得焦点 &amp;lt;input type=&amp;quot;text&amp;quot; autofocus/&amp;gt;
&amp;lt;input id=&amp;quot;input&amp;quot; type=&amp;quot;text&amp;quot;/&amp;gt; document.getElementById('input').focus();
CSS :not()的使用场景 :not() 用来匹配不符合一组选择器的元素。由于它的作用是防止特定的元素被选中，它也被称为反选伪类（negation pseudo-class） /* 子级之间留 10px 空隙 */ .gap-right-10 &amp;gt; :not(:last-child) { margin-right: 10px; } /* 有数据时加上标题 */ .list-wrap:not(:empty):before { content: attr(data-title); } /* flex 容器中都不压缩宽度 */ .flex-row { display: flex; align-items: center; &amp;amp; &amp;gt; .grow { flex-grow: 1; } &amp;amp; &amp;gt; :not(.grow) { flex-shrink: 0; } } JavaSctript 举例说明 js 创建数组有哪些方法 const arr = [...document.querySelectorAll(`[data-dom=&amp;#34;^div&amp;#34;`)]; const arr = [.</description></item><item><title>毎日のフロントエンド 216</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-216/</link><pubDate>Tue, 26 Apr 2022 23:16:47 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-216/</guid><description>Tips TypeScript Mapping over a union type can feel tricky to conceptualise. Distributive Conditional Types export type Letters = &amp;#39;a&amp;#39; | &amp;#39;b&amp;#39; | &amp;#39;c&amp;#39;; type RemoveC&amp;lt;TType&amp;gt; = any; type WowWithoutC = RemoveC&amp;lt;Letters&amp;gt;; Solution // RemoveC - a type helper to remove &amp;#34;c&amp;#34; from a union of letters. export type Letters = &amp;#39;a&amp;#39; | &amp;#39;b&amp;#39; | &amp;#39;c&amp;#39;; // extends 会将union type 中的每一个类型 进行对比 type RemoveC&amp;lt;TType&amp;gt; = TType extends &amp;#39;c&amp;#39; ? never : TType; type WithoutC = RemoveC&amp;lt;Letters&amp;gt;; Playground Link</description></item><item><title>毎日のフロントエンド 215</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-215/</link><pubDate>Mon, 25 Apr 2022 21:24:44 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-215/</guid><description>CSS 图片宽度自适应 object-fit: contain; Tips TypeScript The &amp;ldquo;noUncheckedIndexedAccess&amp;rdquo; is the most awesome config option you&amp;rsquo;ve never heard of. It makes accessing objects a lot safer, and also powers up TypeScript&amp;rsquo;s inference on Objects. export const myObj: Record&amp;lt;string, string[]&amp;gt; = {}; myObj.foo.push(&amp;#39;bar&amp;#39;); // get an error Solution // tsconfig.json { &amp;#34;noUncheckedIndexedAccess&amp;#34;: true } export const myObj: Record&amp;lt;string, string[]&amp;gt; = {}; if (!myObj.foo) { myObj.foo = []; } myObj.foo.push(&amp;#39;bar&amp;#39;); Reference haizlin/fe-interview
object-fit - CSS（层叠样式表） | MDN</description></item><item><title>毎日のフロントエンド 214</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-214/</link><pubDate>Sun, 24 Apr 2022 17:21:29 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-214/</guid><description>HTML required属性 The Boolean required attribute, if present, indicates that the user must specify a value for the input before the owning form can be submitted. If present on any of these input types and elements, the :required pseudo class will match. If the attribute is not included, the :optional pseudo class will match. CSS 文本的竖向排版 writing-mode Tips TypeScript Use Generics to dynamically specify the number, and type, of arguments to functions export type Event = | { type: &amp;#39;LOG_IN&amp;#39;; payload: { userId: string; }; } | { type: &amp;#39;SIGN_OUT&amp;#39;; }; const sendEvent = (eventType: Event[&amp;#39;type&amp;#39;], payload?</description></item><item><title>毎日のフロントエンド 213</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-213/</link><pubDate>Sat, 23 Apr 2022 20:15:50 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-213/</guid><description>Tips TypeScript declare global is super useful too for when you want to allow types to cross module boundaries declare global { interface GlobalReducerEvent {} } export type GlobalReducer&amp;lt;TState&amp;gt; = ( state: TState, event: { [EventType in keyof GlobalReducerEvent]: { type: EventType; } &amp;amp; GlobalReducerEvent[EventType]; }[keyof GlobalReducerEvent] ) =&amp;gt; TState; export const todosReducer: GlobalReducer&amp;lt;{ todos: { id: string }[] }&amp;gt; = (state, event) =&amp;gt; { return state; };</description></item><item><title>毎日のフロントエンド 212</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-212/</link><pubDate>Fri, 22 Apr 2022 21:57:53 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-212/</guid><description>HTML 如何自动转移到新的页面 &amp;lt;head&amp;gt;内引入
&amp;lt;meta http-equiv=&amp;quot;refresh&amp;quot; content=&amp;quot;0; url=http://example.com/&amp;quot;&amp;gt;
content 内第一个参数是延迟，单位秒，0 为立即跳转 参数 url 是跳转地址 Tips DRY Use typeof import('./') to grab the type of any module, even third-party ones. // src/demo/constants.ts export const ADD_TODO = &amp;#39;ADD_TODO&amp;#39;; export const REMOVE_TODO = &amp;#39;REMOVE_TODO&amp;#39;; export const EDIT_TODO = &amp;#39;EDIT_TODO&amp;#39;; export type ActionModule = typeof import(&amp;#39;./contants&amp;#39;); export type Action = ActionModul[keyof ActionModule]; // type Action = &amp;#39;ADD_TODO&amp;#39; | &amp;#39;REMOVE_TODO&amp;#39; | &amp;#39;EDIT_TODO&amp;#39; Reference haizlin/fe-interview
HTTP 的重定向 - HTTP | MDN</description></item><item><title>毎日のフロントエンド 211</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-211/</link><pubDate>Thu, 21 Apr 2022 22:36:12 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-211/</guid><description>CSS clear属性取值 clear CSS 属性指定一个元素是否必须移动(清除浮动后)到在它之前的浮动元素下面。clear 属性适用于浮动和非浮动元素。 none 元素不会向下移动清除之前的浮动。 left 元素被向下移动用于清除之前的左浮动。 right 元素被向下移动用于清除之前的右浮动。 both 元素被向下移动用于清除之前的左右浮动。 inline-start 该关键字表示该元素向下移动以清除其包含块的起始侧上的浮动。即在某个区域的左侧浮动或右侧浮动。 inline-end 该关键字表示该元素向下移动以清除其包含块的末端的浮点，即在某个区域的右侧浮动或左侧浮动。 Tips TypeScript LooseAutocomplete which gives us autocomplete while also allowing arbitrary values type IconSize = &amp;#39;sm&amp;#39; | &amp;#39;xs&amp;#39;; interface IconProps { size: IconSize; } export const Icon = (props: IconProps) =&amp;gt; { return &amp;lt;&amp;gt;&amp;lt;/&amp;gt;; }; const Comp1 = () =&amp;gt; { return ( &amp;lt;&amp;gt; &amp;lt;Icon size=&amp;#39;xs&amp;#39;&amp;gt;&amp;lt;/Icon&amp;gt; &amp;lt;Icon size=&amp;#39;something&amp;#39;&amp;gt;&amp;lt;/Icon&amp;gt; // arbitrary value right here.</description></item><item><title>毎日のフロントエンド 210</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-210/</link><pubDate>Wed, 20 Apr 2022 21:14:59 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-210/</guid><description>CSS :link、:visited、:hover、:active的执行顺序 :link(未访问链接)，:visited(已访问的链接)，:hover(鼠标悬停)，:active(鼠标按下)
a标签伪类 正确的顺序 是：lvha(:link&amp;ndash;&amp;gt;:visited&amp;ndash;&amp;gt;:hover&amp;ndash;&amp;gt;:active)
同等优先权的样式，写在后边的会覆盖前边 a 标签的伪类结合了不同的动作顺序，动作的触发顺序决定了伪类的顺序必须按 lvha 来写 前 2 者两种状态是常态，而后 2 者是即时状态，当即时状态触发时，要覆盖常态，所以2 个即时状态要放在后边 在常态下：如果 a 标签被访问过后，就要呈现被访问过的状态，所以 visited 要放在 link 后边； 鼠标按下时，伴随着悬停的 a 标签上，所以要想 active 覆盖 hover，就必须把 active 放后边； :link 和 a 的样式有可能会冲突
当 标签的 href 属性为空的时候，:link 样式不会生效；当 标签的 href 属性不为空的时候，:link 样式才会生效，这时候，如果 标签正常样式 和 a：link 冲突了的话，以写在后面的那个为准
Tips TypeScript Deep Partial type DeepPartial&amp;lt;Thing&amp;gt; = Thing extends Function ? Thing : Thing extends Array&amp;lt;infer InferredArrayMember&amp;gt; ? DeepPartialArray&amp;lt;InferredArrayMember&amp;gt; : Thing extends object ?</description></item><item><title>毎日のフロントエンド 209</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-209/</link><pubDate>Mon, 18 Apr 2022 23:37:56 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-209/</guid><description>Tips TypeScript A runtime check in a function to the tyoe level. export const deepEqualCompare = &amp;lt;Arg&amp;gt;(a: Arg, b: Arg): boolean =&amp;gt; { if (Array.isArray(a) || Array.isArray(b)) { throw new Error(&amp;#39;You cannot compare two arrays using deepEqualCompare&amp;#39;); } return a === b; }; deepEqualCompare(1, 1); deepEqualCompare([], [&amp;#39;a&amp;#39;]); // this gonna always be false Solution type CheckForBadArgs&amp;lt;Arg&amp;gt; = Arg extends any[] ? &amp;#39;You cannot compare two arrays using deepEqualCompare&amp;#39; : Arg; export const deepEqualCompare = &amp;lt;Arg&amp;gt;( a: CheckForBadArgs&amp;lt;Arg&amp;gt;, b: CheckForBadArgs&amp;lt;Arg&amp;gt; ): boolean =&amp;gt; { if (Array.</description></item><item><title>毎日のフロントエンド 208</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-208/</link><pubDate>Sun, 17 Apr 2022 14:48:54 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-208/</guid><description>CSS FONT 字体的分类 字体族，是一系列字体的集合: serif(衬线) sans-serif(无衬线) monospace(等宽) fantasy(梦幻) cuisive(草体) serif(衬线字体) sans-serif(无衬线字体) Serif的意思是，在字的笔划开始及结束的地方有额外的装饰，而且笔画的粗细会有所不同。衬线字体的风格都比较突出，常见的衬线字体有 Times New Roman、宋体。 Sans Serif字体没有这些额外的装饰，笔划粗细大致差不多，字形端庄，横平竖直，常见的无衬线字体有 Tahoma、Verdana、Arial、Helvetica、苹方、微软雅黑等等 monospace(等宽字体)等宽字体是指字符宽度相同的字体，通常用于编辑器以及技术文章的代码块中，等宽主要针对西文字体，而对于中文每个字都是等宽的，courier 是最常见的等宽字体 font-family属性 设置元素的字体，可以同时指定多个，如果浏览器不支持第一个字体，则会尝试下一个，可以设置字体或字体系列。font-family: Arial, sans-serif; 不设置 font-family 则使用浏览器默认字体，如果设置的 font-family 无效，也会 fallback 到浏览器的默认字体 常见字体 Helvetica 苹果系统支持的一种西文无衬线字体，是苹果生态中最常用的一套西文字体。Helvetica Neue 是 Helvetica 字体改善版，增加了更多不同粗细与宽度的字形 Arial 是为了与 Helvetica 竞争而设计的无衬线西文字体，表现形式和 Helvetica 类似，在不同系统的浏览器都支持，兼容性非常好 Tahoma 一种无衬线字体，间距较小，在不同系统的浏览器都支持，兼容性良好，可以解决 Helvetica 和 Arial 所为人诟病的缺点，比如大写的 I 和小写的 L 难以分辨。 San Francisco 苹果于 2017 年推出一种无衬线字体，也是目前苹果系统的默认西文字体，相比于 Helvetica 字体，San Francisco 的字体风格更加简洁，减少了一些修饰的细节，支持符号的整体居中，比如时间显示，之前的 Helvetica 的冒号是不居中的 PingFang SC(苹方-简) 中文无衬线字体，在 2017 年和 San Francisco 一起推出，SC 代表简体，同时还有台湾繁体和香港繁体，整体造型简洁美观，是苹果系统默认的中文字体。 Hiragino Sans GB(冬青黑体)、Heiti SC(黑体) 苹果系统中较早的中文无衬线字体，为了兼容旧版 macOS 系统，我们一般用它们作为苹方字体的 fallback。 Segoe UI windows 系统下的一种无衬线西文字体，也是 windows 系统的默认西文字体。 Microsoft YaHei(微软雅黑) Windows 系统默认的中文字体，也是一套无衬线字体。macOS 上的浏览器大都预装微软雅黑，但不包括 safari 浏览器(ios 和 android 系统不支持微软雅黑，所以设置移动端字体时可以忽略微软雅黑) Roboto Android 系统的默认西文字体，也是一种无衬线字体 Noto Sans (思源黑体) Android 系统的默认中文无衬线字体，由 google 推出的一款开源字体 Apple Color Emoji 苹果产品的文字表情，在 Mac 和 iOS 系统都支持 Segoe UI Emoji Windows10 系统中的 Emoji 表情，黑描边风格，没有苹果的圆润和质感。 Noto Color Emoji Google 推出的表情，和苹果的较为类似，更加扁平 浏览器默认字体 默认字体分为系统默认字体(system-ui)和浏览器默认字体，这两者是不同的</description></item><item><title>毎日のフロントエンド 207</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-207/</link><pubDate>Sat, 16 Apr 2022 15:43:37 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-207/</guid><description>CSS filter 滤镜 filter 将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像、背景和边框的渲染。CSS 标准里包含了一些已实现预定义效果的函数。 Don&amp;rsquo;t Rely on CSS 100vh &amp;lt;div className=&amp;#34;layout&amp;#34;&amp;gt; &amp;lt;p&amp;gt;Lorem ipsum dolor sit amet...&amp;lt;/p&amp;gt; &amp;lt;button&amp;gt;Sign Up&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;style&amp;gt; .layout { display: flex; flex-direction: column; justify-content: space-between; min-height: 100vh; } &amp;lt;/style&amp;gt; 上述代码，可以在大多是情况下保证button, 位于页面底部
但是在移动端浏览器上会被浏览器的工具栏遮挡，原因是： html - CSS3 100vh not constant in mobile browser - Stack Overflow
Fix Code
&amp;lt;div className=&amp;#34;layout&amp;#34;&amp;gt; &amp;lt;p&amp;gt;Lorem ipsum dolor sit amet...&amp;lt;/p&amp;gt; &amp;lt;button&amp;gt;Sign Up&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;style&amp;gt; .layout { display: flex; flex-direction: column; justify-content: space-between; min-height: 100vh; } .</description></item><item><title>毎日のフロントエンド 206</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-206/</link><pubDate>Thu, 14 Apr 2022 23:39:27 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-206/</guid><description>HTML 移动端点击 300ms 的延迟出现的原因 早期 IOS 为了区分用户是双击缩放还是点击链接行为，于是就有了 300ms 延迟，其他浏览器效仿 引入fastclick 在meta禁用浏览器缩放 touch事件模拟 CSS 元素设置 background-color,它的颜色会填充哪些区域 background 填充区域默认为content、padding和border区域 该行为由background-clip属性决定，默认为border-box background-clip 设置元素的背景（背景图片或颜色）是否延伸到边框、内边距盒子、内容盒子下面 填充区域如下 background-clip margin border padding content text border-box (默认) ✘ ✔ ✔ ✔ - padding-box ✘ ✘ ✔ ✔ - content-box ✘ ✘ ✘ ✔ - text (webkit) ✘ ✘ ✘ ✘ ✔ JavaScript js 获取 DOM 元素的方法 document.getElementById - 元素的 ID 在大部分情况下要求是独一无二的，这个方法自然而然地成为了一个高效查找特定元素的方法 返回一个匹配到 ID 的 DOM Element 对象, 没有找到，则返回 null 仅在 document 下调用 document.</description></item><item><title>毎日のフロントエンド 205</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-205/</link><pubDate>Wed, 13 Apr 2022 22:06:42 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-205/</guid><description>HTML picture标签 &amp;lt;picture&amp;gt; 元素通过包含零或多个 &amp;lt;source&amp;gt; 元素和一个 &amp;lt;img&amp;gt; 元素来为不同的显示/设备场景提供图像版本。浏览器会选择最匹配的子 &amp;lt;source&amp;gt; 元素，如果没有匹配的，就选择 &amp;lt;img&amp;gt; 元素的 src 属性中的 URL。然后，所选图像呈现在元素占据的空间中。
&amp;lt;picture&amp;gt; 的常见使用场景：
艺术指导 (Art direction) —— 针对不同 media 条件裁剪或修改图像 遇到所有浏览器都不支持的特定格式时，提供不同的图像格式 JavaScript getElementById和querySelector方法的区别 Document的方法 getElementById()返回一个匹配特定 ID 的元素. 由于元素的 ID 在大部分情况下要求是独一无二的，这个方法自然而然地成为了一个高效查找特定元素的方法。 Document 引用的 querySelector()方法返回文档中与指定选择器或选择器组匹配的第一个 Element 对象。 如果找不到匹配项，则返回 null。 selectors:包含一个或多个要匹配的选择器的 DOM 字符串 DOMString。 该字符串必须是有效的 CSS 选择器字符串；如果不是，则引发 SYNTAX_ERR 异常。 Tips TypeScript The Looseness of Object.keys can be a real pain point when it comes to use typescript. Use Generics and keyof keyword to create a tighter version.</description></item><item><title>毎日のフロントエンド 204</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-204/</link><pubDate>Tue, 12 Apr 2022 22:27:42 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-204/</guid><description>Tips TypeScript Type Helpers - PropsFrom Helper - Get the props&amp;rsquo; type from the other Component import React from &amp;#39;react&amp;#39;; // function component const MyComponent = (props: { enabled: boolean }) =&amp;gt; { return null; }; //class component class MyOtherComponent extends React.Component&amp;lt;{ enabled: boolean; data: string; }&amp;gt; {} // implement the PropsFrom type PropsFrom&amp;lt;TComponent&amp;gt; = TComponent extends React.FC&amp;lt;infer Props&amp;gt; ? Props : TComponent extends React.Component&amp;lt;infer Props&amp;gt; ? Props : never; const props: PropsFrom&amp;lt;typeof MyComponent&amp;gt; = { enabled: true, }; Playground Link</description></item><item><title>毎日のフロントエンド 203</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-203/</link><pubDate>Mon, 11 Apr 2022 22:12:08 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-203/</guid><description>HTML canvas 的width与height属性的值可不可以带单位 width/height的属性值可以带单位且不会报错，但是无论是 px 还是 em、rem，表现都和 px 一致 CSS height和line-height line-height: 在日常用的最多的是让单行文字垂直居中（其实不需要设置 height，一个 line-height 即可）。因为 line-height - font-size 为行距，一般会近似平分到文字的上下两边，使文字看上去垂直居中。如果需要多行文字的垂直居中，还需要加上 vertical-align: middle; line-height 可以不设置单位，表示 font-size 的倍数 height 指定了一个元素的高度。默认情况下，这个属性决定的是内容区（ content area）的高度，但是，如果将 box-sizing 设置为 border-box , 这个属性决定的将是边框区域（border area）的高度。 Tips TypeScript The extends keyword: narrow the value of a generic to enable some autocomplete type of interface const getDeepValue = &amp;lt;Obj, FirstKey, SecondKey&amp;gt;( obj: Obj, firstKey: FirstKey, secondKey: SecondKey ) =&amp;gt; { return {} as any; }; // to const obj = { foo: { a: true, b: 2 }, bar: { c: &amp;#39;cool&amp;#39;, d: 2 }, }; const result = getDeepValue(obj, &amp;#39;bar&amp;#39;, &amp;#39;d&amp;#39;); Solution const getDeepValue = &amp;lt;Obj, FirstKey extends keyof Obj, SecondKey extends keyof Obj[FirstKey]&amp;gt;( obj: Obj, firstKey: FirstKey, secondKey: SecondKey ): Obj[FirstKey][SecondKey] =&amp;gt; { return {} as any; }; Playground Link</description></item><item><title>毎日のフロントエンド 202</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-202/</link><pubDate>Sun, 10 Apr 2022 21:21:26 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-202/</guid><description>HTML &amp;lt;dialog&amp;gt; HTML &amp;lt;dialog&amp;gt; 元素表示一个对话框或其他交互式组件，例如一个检查器或者窗口。 Attributes - 属性 open: 指示这个对话框是激活的和能互动的。当这个 open 特性没有被设置，对话框不应该显示给用户。(没有它，这个对话框就会隐藏起来，直到你使用 JavaScript 来显示它) returnValue: 用来获取 close 时传入的参数 方法： show() showModal() 两个方法相同点都是打开弹窗，即都会给 dialog 元素添加一个 open 属性。 不同点： 唯一区别是show()会按照其在 DOM 流中的位置显示 dialog，没有遮罩，而showModal()会出现遮罩， 并且自动做了按键监控，即点击 esc 键，弹窗会关闭 大多数情况下，使用便利的 showModal() 方法来而不使用 show()方法。 close() 会关闭弹窗，即会删除 open 属性，并且可以携带一个参数作为额外数据，传入的值可以通过 dialog.returnValue 获取。 两个事件: close: 当 modal 关闭的时候触发 cancel: 当按下 ESC 关闭模态框的时候触发 在各事件的事件对象 event.target 里，同样可以看到 close()方法传入的参数，即 event.target.returnValue 一个伪元素: ::backdrop : 是 dialog 伪元素，用来设置弹窗遮罩的样式，用法如下: dialog::backdrop { background-color: rgba(0, 0, 0, 0.</description></item><item><title>毎日のフロントエンド 201</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-201/</link><pubDate>Sat, 09 Apr 2022 17:15:55 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-201/</guid><description>HTML &amp;lt;p&amp;gt; &amp;lt;/p&amp;gt;会换两行 p { display: block; margin-block-start: 1em; margin-block-end: 1em; margin-inline-start: 0px; margin-inline-end: 0px; } 以上为p的用户代理 默认上下 margin 为 1em，所以等效于两行字那么高。 margin-block-start /end等效于上下外边距 margin-inline-start/end等效于左右外边距 CSS 伪类:focus-within的用法 :focus-within 是一个 CSS 伪类 ，表示一个元素获得焦点，或，该元素的后代元素获得焦点。换句话说，元素自身或者它的某个后代匹配 :focus 伪类。 /* 当 &amp;lt;div&amp;gt; 的某个后代获得焦点时，匹配 &amp;lt;div&amp;gt; */ div:focus-within { background: cyan; } JavaScript Object 与 Map 的异同及使用场景 Map Map 是一种数据结构（是一种抽象的数据结构类型），数据一对对进行存储，其中包含键以及映射到该键的值。并且由于键的唯一性，因此不存在重复的键值对。 Map 中的键和值可以是任何数据类型，不仅限于字符串或整数 Object JavaScript 中的常规对象是一种字典类型的数据结构——这意味着它依然遵循与 Map 类型相同键值对的存储结构。 Object 中的 key，或者我们可以称之为属性，同样是独一无二的并且对应着一个单独的 value。 JavaScript 中的 Object 拥有内置原型(prototype) JavaScript 中几乎所有对象都是 Object 实例，包括 Map Object 和 Map 的本质都是以键值对的方式存储数据，但实质上他们之间存在很大的区别： 键： Object遵循普通的字典规则，键必须是单一类型，并且只能是整数、字符串或是**Symbol类型**。 Map 中，key 可以为任意数据类型（包括Object, Array 等） 元素顺序：Map 会保留所有元素的顺序，而 Object 并不会保证属性的顺序。 继承：Map 是 Object 的实例对象，而 Object 显然不可能是 Map 的实例对象。 var map = new Map([ [1, 2], [3, 4], ]); console.</description></item><item><title>毎日のフロントエンド 200</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-200/</link><pubDate>Fri, 08 Apr 2022 22:18:38 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-200/</guid><description>HTML &amp;lt;p&amp;gt;和&amp;lt;br&amp;gt;的区别 &amp;lt;p&amp;gt;块级元素，&amp;lt;br&amp;gt; 内联元素； &amp;lt;p&amp;gt;能被 css 修改，&amp;lt;br&amp;gt; 不能； &amp;lt;p&amp;gt;非单标签元素，&amp;lt;br&amp;gt; 是单标签元素； &amp;lt;p&amp;gt;换行靠的是块级元素特性，&amp;lt;br&amp;gt; 换行靠的可能是类似 \n 的渲染规则 Tips JavaScript Accessing URL data using window.location in JavaScript //https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#mapping-modifiers window.location.hash; // &amp;#39;#mapping-modifiers&amp;#39; window.location.href; // &amp;#39;https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#mapping-modifiers&amp;#39; window.location.origin; // &amp;#39;https://www.typescriptlang.org&amp;#39; window.location.pathname; // &amp;#39;/docs/handbook/2/mapped-types.html&amp;#39; window.location.search; // &amp;#39;&amp;#39; TypeScript Transform a union to another union, using the in operator as a kind of for-loop type Entity = | { type: &amp;#39;user&amp;#39;; } | { type: &amp;#39;post&amp;#39;; } | { type: &amp;#39;comment&amp;#39;; }; // to implement below: type EntityWithId = | { type: &amp;#39;user&amp;#39;; userId: sting; } | { type: &amp;#39;post&amp;#39;; postId: string; } | { type: &amp;#39;comment&amp;#39;; commentId: string; }; solution: type EntityWithId = { [EntityType in Entity[&amp;#39;type&amp;#39;]]: { type: EntityType; } &amp;amp; Record&amp;lt;`${EntityType}Id`, string&amp;gt;; }[Entity[&amp;#39;type&amp;#39;]]; const result: EntityWithId = { type: &amp;#39;comment&amp;#39;, commentId: &amp;#39;12345&amp;#39;, }; Playground Link Reference haizlin/fe-interview</description></item><item><title>毎日のフロントエンド 198</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-198/</link><pubDate>Tue, 05 Apr 2022 22:53:47 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-198/</guid><description>CSS CSS 实现段落首字母或首字放大效果 ::first-letter 伪元素 div::first-letter { font-size: 24px; font-weight: bold; } text-transform &amp;lt;style&amp;gt; div { text-transform: capitalize; } &amp;lt;/style&amp;gt; &amp;lt;div&amp;gt;come on&amp;lt;/div&amp;gt; Tips npm ci 合理使用 npm ci 和 npm install npm ci 就是专门为 CI 环境准备的安装命令，相比 npm install 它的不同之处在于： npm ci 要求项目中必须存在 package-lock.json 或 npm-shrinkwrap.json； npm ci 完全根据 package-lock.json 安装依赖，这可以保证整个开发团队都使用版本完全一致的依赖； npm ci 完全根据 package-lock.json 安装依赖，在安装过程中，它不需要计算求解依赖满足问题、构造依赖树，因此安装过程会更加迅速； npm ci 在执行安装时，会先删除项目中现有的 node_modules，然后全新安装； npm ci 只能一次安装整个项目所有依赖包，无法安装单个依赖包； 如果 package-lock.json 和 package.json 冲突，那么 npm ci 会直接报错，并非更新 lockfiles； npm ci 永远不会改变 package.</description></item><item><title>毎日のフロントエンド 197</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-197/</link><pubDate>Mon, 04 Apr 2022 16:21:24 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-197/</guid><description>HTML 举例说明&amp;lt;a&amp;gt;作用 打开链接 当前页面打开 &amp;lt;a href=&amp;quot;https://www.github.com&amp;quot;&amp;gt;test&amp;lt;/a&amp;gt; 新标签页打开 &amp;lt;a target=&amp;quot;_blank&amp;quot; href=&amp;quot;https://www.github.com&amp;quot;&amp;gt;test&amp;lt;/a&amp;gt; 文件下载 &amp;lt;a href=&amp;quot;https://codeload.github.com/vkboo/vue-svg-board/zip/master&amp;quot; download=&amp;quot;vue-board-svg-name&amp;quot;&amp;gt;vue-board-svg&amp;lt;/a&amp;gt; 利用 URL Scheme 打开 app &amp;lt;a href=&amp;quot;imeituan://xxx.xxx.xxx&amp;quot;&amp;gt;&amp;lt;/a&amp;gt; mailto &amp;amp; telto &amp;lt;a href=&amp;quot;mailto:xxx@site.com&amp;quot;&amp;gt;&amp;lt;/a&amp;gt; 锚点 &amp;lt;a href=&amp;quot;#content&amp;quot;&amp;gt;go to content&amp;lt;/a&amp;gt; &amp;lt;section id=&amp;quot;content&amp;quot;&amp;gt;&amp;lt;/section&amp;gt; CSS 段落的首行缩进 text-indent属性 能定义一个块元素首行文本内容之前的缩进量 长度值：px em rem 百分比：取决于包含块的 width 关键字： each-line：文本缩进会影响第一行，以及使用强制断行后的第一行； hanging：该值会对所有的行进行反转缩进：除了第一行之外的所有的行都会被缩进，看起来就像第一行设置了一个负的缩进值。 全局值：inherit initial unset /* &amp;lt;length&amp;gt; 长度值 */ text-indent: 3mm; text-indent: 40px; /* &amp;lt;percentage&amp;gt;百分比值取决于其包含块（containing block）的宽度*/ text-indent: 15%; /* 关键字 */ text-indent: 5em each-line; text-indent: 5em hanging; text-indent: 5em hanging each-line; /* 全局值 */ text-indent: inherit; text-indent: initial; text-indent: unset; JavaScript 找出一段话里面出现频率最多的单词 const mostOftenWord = (para) =&amp;gt; para .</description></item><item><title>毎日のフロントエンド 196</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-196/</link><pubDate>Sun, 03 Apr 2022 14:27:21 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-196/</guid><description>HTML 引用标签 &amp;lt;blockquote&amp;gt;：块级引用元素
&amp;lt;blockquote&amp;gt; 元素（或者 HTML 块级引用元素），代表其中的文字是引用内容。通常在渲染时，这部分的内容会有一定的缩进（注 中说明了如何更改） 若引文来源于网络，则可以将原内容的出处 URL 地址设置到 cite 特性上，若要以文本的形式告知读者引文的出处时，可以通过 &amp;lt;cite&amp;gt; 元素 &amp;lt;q&amp;gt;标签, 短引用
引用标签 (&amp;lt;q&amp;gt;) 表示一个封闭的并且是短的行内引用的文本。这个标签是用来引用短的文本，所以不要引入换行符; 对于长的文本的引用使用 &amp;lt;blockquote&amp;gt; 替代。 cite这个属性的值是 URL，意在指出被引用的文本的源文档或者源信息。这个属性重在解释这个引用的参考或者是上下文。 &amp;lt;p&amp;gt; Everytime Kenny is killed, Stan will announce &amp;lt;q cite=&amp;#34;http://en.wikipedia.org/wiki/Kenny_McCormick#Cultural_impact&amp;#34;&amp;gt; Oh my God, &amp;lt;/q&amp;gt;. &amp;lt;/p&amp;gt; Tips - Yarn Yarn 是一个由 Facebook、Google、Exponent 和 Tilde 构建的新的 JavaScript 包管理器。它的出现是为了解决历史上 npm 的某些不足（比如 npm 对于依赖的完整性和一致性保障，以及 npm 安装速度过慢的问题等），虽然 npm 目前经过版本迭代汲取了 Yarn 一些优势特点（比如一致性安装校验算法等），但依然有必要关注 Yarn 的思想和理念。
当 npm 还处在 v3 时期时，一个叫作 Yarn 的包管理方案横空出世。2016 年，npm 还没有 package-lock.</description></item><item><title>毎日のフロントエンド 195</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-195/</link><pubDate>Sat, 02 Apr 2022 23:46:45 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-195/</guid><description>HTML html 支持的数学符号有哪些 HTML 符号实体参考手册 CSS CSS 的标准发布流程 CSS 的标准化流程由 W3C Cascading Style Sheets Working Group (CSSWG)——W3C 层叠样式列表小组，由浏览器商，大学，大公司（google，IBM 等），以及独立 CSS 专家组成。
W3C 本身并不制定标准，而是作为一个论坛式的平台，接收来自小组成员的提交，并通过会议来商讨制定标准，所有的提交以及讨论都是公开透明的，可以在 W3C 网站上看到会议的记录，标准确定一般有 6 个阶段，其中两个是过渡阶段：
编辑草案 Editor&amp;rsquo;s Draft (ED) 这个是规范的开始阶段，一个 CSS 属性或者选择器被提出来，并在 CSSWG 内部研究。如果小组成员同意这个属性可以正式推出，它就能进入下一阶段。 工作草案 Working Draft (WD) 编辑草案后是工作草案，标准的设计阶段。小组反复处理来自 CSSWG 内部和来自小组外部的反馈，这个阶段有两个结果：一是可能会因为技术困难或者可能会引起其他问题而使新属性被完全拒绝；二是规范会通过这个阶段，并会作为第一次公开工作草案（ First Public Working Draft (FPWD)）发布，后面还会有数个工作草案，会处理来自 CSSWG 内部和小组外部更广泛社会的反馈。 过渡－最后通告工作草案 Transition – Last Call Working Draft (LCWD) 这是第一个过渡阶段，当规范开始考虑从工作草案进入到下一个阶段时，将会对新属性的一些小改动的反馈设置一个截止日期，LCWD 即是日期截至后最后的一次公开草案处理。 最重要的阶段是 ED, WD, and CR，其他阶段不是很重要。 候选推荐标准 Candidate Recommendation (CR) 规范会在这个阶段通过完整的测试，测试人员来自 CSSWG 以及被选为实现这个规范的浏览器生产商(Chrome, Safari, Firefox, Opera, 等等)。为了继续进入下一阶段，CSSWG 会推出两个正确的实现规范。 过渡－建议推荐标准 Transition – Proposed Recommendations (PR) 当到达这个阶段，W3C 全球资源小组：W3C 咨询委员会（W3C Advisory Committee），决定这个规范是否会继续进入下一个阶段。这个阶段一般很少有异议出现，所以也是一个过渡阶段而已。 推荐标准 Recommendation (REC) 如果规范到达这个阶段，说明规范已经考虑完备并可以让浏览器商实现，W3C 和 CSSWG 对这个规范的讨论处理不再活跃，只做一些必要的维护。 Tips 轮播图生成器 Image Slider Maker - Free Generator Tool Reference haizlin/fe-interview</description></item><item><title>毎日のフロントエンド 194</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-194/</link><pubDate>Fri, 01 Apr 2022 21:20:27 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-194/</guid><description>npm npm 内部机制和核心原理 Bring the best of open source to you, your team and your company.
npm 的安装机制 Ruby 的 Gem、Python 的 pip 都是全局安装，但是 npm 的安装机制秉承了不同的设计哲学： npm安装流程图 npm install 执行之后，首先，检查并获取 npm 配置，这里的优先级为： 项目级的 .npmrc 文件 &amp;gt; 用户级的 .npmrc 文件&amp;gt; 全局级的 .npmrc 文件 &amp;gt; npm 内置的 .npmrc 文件 然后检查项目中是否有 package-lock.json 文件 如果有，则检查 package-lock.json 和 package.json 中声明的依赖是否一致： 一致，直接使用 package-lock.json 中的信息，从缓存或网络资源中加载依赖； 不一致，按照 npm 版本进行处理（不同 npm 版本处理会有不同，具体处理方式如图所示） 如果没有，则根据 package.json 递归构建依赖树。然后按照构建好的依赖树下载完整的依赖资源，在下载时就会检查是否存在相关资源缓存： 存在，则将缓存内容解压到 node_modules 中； 否则就先从 npm 远程仓库下载包，校验包的完整性，并添加到缓存，同时解压到 node_modules 最后生成 package-lock.</description></item><item><title>毎日のフロントエンド 193</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-193/</link><pubDate>Thu, 31 Mar 2022 11:01:04 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-193/</guid><description>HTML dl、ul、ol三个标签的区别 dl 标签就是定义列表，英文的单词是 definition list definition title dt 列表的标题 这个标签是必须要的 definition description 列表的列表项，如果不需要它，可以不加 dd dt、dd 只能在 dl 里面；dl 里面只能有 dt、dd。 &amp;lt;dl&amp;gt; &amp;lt;dt&amp;gt;Firefox&amp;lt;/dt&amp;gt; &amp;lt;dd&amp;gt; A free, open source, cross-platform, graphical web browser developed by the Mozilla Corporation and hundreds of volunteers. &amp;lt;/dd&amp;gt; &amp;lt;!-- other terms and definitions --&amp;gt; &amp;lt;/dl&amp;gt; ul标签 无序列表 unordered list
无序列表中的每一项是 li 标签 li：list item，“列表项”的意思 ol标签 有序列表 ol 英文单词：Ordered List
CSS 为什么 css 的 reset 不建议直接这么写：*{ margin:0; padding:0;} *是通配符，需要把所有的标签都遍历一遍，当网站较大时，样式比较多，这样写就大大的加强了网站运行的负载，会使网站加载的时候需要很长一段时间，因此一般大型的网站都有分层次的一套初始化样式 Tips 脚手架工具 Scaffold 准备工作：</description></item><item><title>毎日のフロントエンド 190</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-190/</link><pubDate>Mon, 28 Mar 2022 10:54:51 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-190/</guid><description>CSS 颜色中#F00 的每一位分别表示什么？为什么会有三位和六位的表示 颜色可以使用红-绿-蓝（red-green-blue (RGB)）模式的两种方式被定义： 十六进制符号 #RRGGBB 和 #RGB 三位数的 RGB 符号（#RGB）和 六位数的形式（#RRGGBB）是相等的。 #f03 和 #ff0033 代表同样的颜色 JavaScript 原生 js 实现类似getElementsByClassName的方法，不使用querySelectorAll function getElementsByClassName(className) { const tags = document.getElementsByTagName(&amp;#39;*&amp;#39;); const tempTags = []; for (let i = 0, len = tags.length; i &amp;lt; len; i++) { let tag = tags[i]; tag.classList.contains(className) &amp;amp;&amp;amp; tempTags.push(tag); } return tempTags; } Reference haizlin/fe-interview
Document.getElementsByTagName() - Web API 接口参考 | MDN</description></item><item><title>毎日のフロントエンド 189</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-189/</link><pubDate>Sun, 27 Mar 2022 14:26:42 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-189/</guid><description>JavaScript 将 html 页面生成为图片 niklasvh/html2canvas: Screenshots with JavaScript Tips X-Frame-Options X-Frame-Options HTTP 响应头是用来给浏览器 指示允许一个页面 可否在 &amp;lt;frame&amp;gt;, &amp;lt;iframe&amp;gt;, &amp;lt;embed&amp;gt; 或者 &amp;lt;object&amp;gt; 中展现的标记。 X-Frame-Options: deny X-Frame-Options: sameorigin X-Frame-Options: allow-from https://example.com/ deny表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。 sameorigin 表示该页面可以在相同域名页面的 frame 中展示。 allow-from uri 表示该页面可以在指定来源的 frame 中展示。 Referer Referer 请求头包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。 服务端一般使用 Referer 请求头识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化 Node.js 实现原理 Node.js 的依赖模块
acorn：前面的课程中已经提过，用 JavaScript 编写的轻量级 JavaScript 解析器。 acorn-plugins：acorn 的扩展模块，让 acorn 支持 ES6 特性解析，比如类声明。 brotli：C 语言编写的 Brotli 压缩算法。 cares：应该写为“c-ares”，C 语言编写的用来处理异步 DNS 请求。 histogram：C 语言编写，实现柱状图生成功能。 icu-small：C 语言编写，为 Node.</description></item><item><title>毎日のフロントエンド 188</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-188/</link><pubDate>Sat, 26 Mar 2022 17:20:33 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-188/</guid><description>HTML PNG 格式 什么是 PNG PNG 的全称叫便携式网络图型（Portable Network Graphics）是目前最流行的网络传输和展示的图片格式，原因有如下几点： 无损压缩：PNG 图片采取了基于 LZ77 派生算法对文件进行压缩，使得它压缩比率更高，生成的文件体积更小，并且不损失数据。 体积小：它利用特殊的编码方法标记重复出现的数据，使得同样格式的图片，PNG 图片文件的体积更小。网络通讯中因受带宽制约，在保证图片清晰、逼真的前提下，优先选择 PNG 格式的图片。 支持透明效果：PNG 支持对原图像定义 256 个透明层次，使得图像的边缘能与任何背景平滑融合，这种功能是 GIF 和 JPEG 没有的。 PNG 类型 PNG 8：PNG 8 中的 8，其实指的是 8bits，相当于用 2^8（2 的 8 次方）大小来存储一张图片的颜色种类，2^8 等于 256，也就是说 PNG 8 能存储 256 种颜色，一张图片如果颜色种类很少，将它设置成 PNG 8 得图片类型是非常适合的。
PNG 24：PNG 24 中的 24，相当于 3 乘以 8 等于 24，就是用三个 8bits 分别去表示 R（红）、G（绿）、B（蓝）。R(0~255),G(0~255),B(0~255)，可以表达 256 乘以 256 乘以 256=16777216 种颜色的图片，这样 PNG 24 就能比 PNG 8 表示色彩更丰富的图片。但是所占用的空间相对就更大了。</description></item><item><title>毎日のフロントエンド 187</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-187/</link><pubDate>Fri, 25 Mar 2022 14:19:54 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-187/</guid><description>JavaScript FileReader FileReader 对象允许 Web 应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据 Tips 前端性能指标 首屏绘制（First Paint，FP） 首屏绘制时间是指从开始加载到浏览器首次绘制像素到屏幕上的时间，也就是页面在屏幕上首次发生视觉变化的时间。 首屏绘制不包括默认的背景绘制，但包括非默认的背景绘制。由于首次绘制之前网页呈现默认背景白色，所以也俗称“白屏时间”。 在 HTML5 下可以通过 performance API 来获取首屏绘制时间 performance.getEntriesByType(&amp;#39;paint&amp;#39;)[0]; /* { duration: 0, entryType: &amp;#34;paint&amp;#34;, name: &amp;#34;first-paint&amp;#34;, startTime: 197.58499998715706, } */ 通过 performance.getEntriesByType() 函数返回了一个 PerformanceEntry 实例组成的数组 duration 为该事件的耗时 entryType 为性能指标实例的类型 name 为指标名称 startTime 为指标采集时间。 首屏内容绘制（First Contentful Paint，FCP） 浏览器首次绘制来自 DOM 的内容时间，这个内容可以是文字、图片（也包括背景图片）、非空白的 canvas 和 svg。 performance.getEntriesByType(&amp;#39;paint&amp;#39;)[1]; /* { duration: 0, entryType: &amp;#34;paint&amp;#34;, name: &amp;#34;first-contentful-paint&amp;#34;, startTime: 797.8649999859044 } */ 和获取 FP 值的唯一区别就在于通过 performance.</description></item><item><title>毎日のフロントエンド 186</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-186/</link><pubDate>Thu, 24 Mar 2022 14:22:03 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-186/</guid><description>HTML 如何实现浏览器桌面通知 Websocket Desktop Notification Notification.requestPermission(function (perm) { if (perm == &amp;#34;granted&amp;#34;) { let notification = new Notification(&amp;#34;通知&amp;#34;, { dir: &amp;#34;auto&amp;#34;, lang: &amp;#34;hi&amp;#34;, tag: &amp;#34;testTag&amp;#34;, icon: &amp;#34;https://static.cnblogs.com/images/adminlogo.gif&amp;#34;, body: &amp;#34;content&amp;#34; }); } }) CSS 相邻兄选择器 相邻兄弟选择器 (+) 介于两个选择器之间，当第二个元素紧跟在第一个元素之后，并且两个元素都是属于同一个父元素的子元素，则第二个元素将被选中 /* 图片后面紧跟着的段落将被选中 */ img + p { font-style: bold; } Tips 组件通信 - 状态管理 全局状态 父子组件通信 父组件通过 prop(s) 属性向子组件传参，子组件通过自定义事件来向父组件发送消息 状态管理库 状态管理库具有 3 个特点：可预测、中心化、可调式。 其他组件通信方式 全局上下文 事件监听 代码编译之webpack webpack 有两个执行入口，分别是: 通过命令行调用的 bin/webpack.js 以及直接在代码中引用的 lib/webpack.js // lib/webpack.</description></item><item><title>毎日のフロントエンド 185</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-185/</link><pubDate>Wed, 23 Mar 2022 14:28:43 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-185/</guid><description>Tips onload和domcontentloaded哪个先执行 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完全加载。 onload 需要所有资源全都加载完成才执行 组件就是基于视图的模块 组件的核心任务就是将数据渲染到视图并监听用户在视图上的操作
虚拟 DOM 优化性能 。DOM 操作是比较耗时的，对于大量、频繁的 DOM 操作，如果先在 JavaScript 中模拟进行，然后再通过计算比对，找到真正需要更新的节点，这样就有可能减少不必要的 DOM 操作，从而提升渲染性能。但并不是所有的 DOM 操作都能通过虚拟 DOM 提升性能，比如单次删除某个节点，直接操作 DOM 肯定比虚拟 DOM 计算比对之后再删除要快。总体而言， 虚拟 DOM 提升了 DOM 操作的性能下限，降低了 DOM 操作的性能上限。 所以会看到一些对渲染性能要求比较高的场景，比如在线文档、表格编辑，还是会使用原生 DOM 操作。
跨平台 。由于虚拟 DOM 以 JavaScript 对象为基础，所以可根据不同的运行环境进行代码转换（比如浏览器、服务端、原生应用等），这使得它具有了跨平台的能力。
数据模型(React) React 组件的数据模型 state，其值就是 对象类型。 React 并没有直接采用深拷贝的方式来实现，因为深拷贝操作性能开销太大。 React 组件是通过将 state 设置为不可变对象的方式来实现的，不可变对象指的就是当一个变量被创建后，它的值不可以被修改。 意味着当组件状态发生变化时，不修改 state 属性，而是重新创建新的 state 状态对象。 React 中的不可变对象通过 Structural Sharing（结构共享）的操作，大大减少了性能开销。 操作的原理就是，如果对象中的一个属性发生变化，那么只深拷贝当前属性，然后将对象属性指向这个深拷贝的属性，其他节点仍然进行共享。 渲染 React 组件中的视图更新，并不是像 Vue 中那样自动响应的，而是需要手动调用 setState() 函数来触发。 React 为了提升组件更新时的性能，不仅将状态更新包装成任务放入了异步队列，而且还使用了类似协程的方式来调度这些队列中的更新任务。 任务的执行顺序会根据每个任务的优先级来进行调整，并且任务的执行过程中可能会被中断，但状态会被保存，直到合适的时候会再次读取状态并继续执行任务。 Vue 采取的是响应式的视图更新方式，基于 Object.</description></item><item><title>毎日のフロントエンド 184</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-184/</link><pubDate>Tue, 22 Mar 2022 14:27:44 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-184/</guid><description>HTML 下拉选项进行分组 &amp;lt;select name=&amp;#34;alpha&amp;#34;&amp;gt; &amp;lt;optgroup label=&amp;#34;A&amp;#34;&amp;gt; &amp;lt;option value=&amp;#34;1&amp;#34;&amp;gt;AA&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;2&amp;#34;&amp;gt;BB&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;3&amp;#34;&amp;gt;CC&amp;lt;/option&amp;gt; &amp;lt;/optgroup&amp;gt; &amp;lt;optgroup label=&amp;#34;a&amp;#34;&amp;gt; &amp;lt;option value=&amp;#34;1&amp;#34;&amp;gt;aa&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;2&amp;#34;&amp;gt;bb&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;3&amp;#34;&amp;gt;cc&amp;lt;/option&amp;gt; &amp;lt;/optgroup&amp;gt; &amp;lt;/select&amp;gt; CSS translate() 方法 translate() CSS 函数在水平和/或垂直方向上重新定位元素 transform: translate(x,y,z) 控制元素往三个轴方向平移 x 是屏幕左上角往右的方向 y 是屏幕左上角往下的方向 z 是屏幕到人眼的方向 Tips 前后端沟通 RPC—远程过程调用 RPC（Remote Procedure Call，远程过程调用）常用于后端服务进程之间的通信。 “远程”指的是不同服务器上的进程，“过程调用”里的“过程”可以理解为“函数”，这种接口设计和函数命名很相似，名称为动宾结构短语 GET /getUsers POST /deleteUser POST /createUser RPC 风格和平常编写模块的思路很像，提供了一个函数作为接口，供其他模块调用。是站在后端工程师的视角而设置的：为了像在本地调用一个函数那样调用远程的代码。 紧耦合：当前端工程师需要获取或修改某个数据时，他有可能需要先调用接口 A ，再调用接口 B，这种调用需要对系统非常熟悉，让前端工程师熟悉后端逻辑和代码显然是难以办到的。 冗余：把执行动作写在 URL 上实际是冗余的，因为 HTTP 的 Method 头部可以表示不同的动作行为。 REST—表现层状态转换 表现层 资源指的是一个实体信息，一个文本文件、一段 JSON 数据都可以称为资源。 一个资源可以有不同的呈现形式，比如一份数据可以是 XML 格式，也可以是 JSON 格式，这种呈现形式叫作“表现层（Representation） 状态转移 HTTP 本身是无状态的，因此，如果客户端想要操作服务器，则必须通过某种手段让服务器发生“状态转移（State Transfer）”。而这种转移是建立在表现层之上的，即“表现层状态转移”。 REST 的核心要点有两个，那就是资源和方法。</description></item><item><title>毎日のフロントエンド 183</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-183/</link><pubDate>Mon, 21 Mar 2022 15:15:07 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-183/</guid><description>HTML &amp;lt;output&amp;gt; 标签 &amp;lt;output&amp;gt; 标签表示计算或用户操作的结果。 属性 for其它影响计算结果的标签的 ID，可以多个。 form与当前标签有关联的 form（从属的表单）。该属性的值必须是当前文档内的表单元素的 ID。如果未指明该属性，output 标签必须是一个 form 的后代标签。该属性的用处在于可以让 output 标签脱离 form 标签，存在于一个网页文档的任意位置。 name 属性 &amp;lt;form oninput=&amp;#34;result.value=parseInt(a.value)+parseInt(b.value)&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;range&amp;#34; name=&amp;#34;b&amp;#34; value=&amp;#34;50&amp;#34; /&amp;gt; + &amp;lt;input type=&amp;#34;number&amp;#34; name=&amp;#34;a&amp;#34; value=&amp;#34;10&amp;#34; /&amp;gt; = &amp;lt;output name=&amp;#34;result&amp;#34;&amp;gt;&amp;lt;/output&amp;gt; &amp;lt;/form&amp;gt; CSS 去除图片自带的边距 图片以及所有其他 inline-block 元素之间都会有 4px 的间距，直接在父元素 font-size: 0 去除。 Tips 函数返回多个值方法 函数 return expression, 这个表达式应该是一个具体的值,这个具体的值可以是一个承载多个值的复杂值, 诸如 Array,Object, Map,Set 等方式来实现 AMD、CMD和CommonJS AMD,CMD 和 CommonJs 是 es6 之前推出的模块化方案
CommonJs 用在服务端 AMD,CMD 用在浏览器环境 CommonJs 是由 node 推广使用的</description></item><item><title>毎日のフロントエンド 182</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-182/</link><pubDate>Sun, 20 Mar 2022 14:04:20 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-182/</guid><description>HTML &amp;lt;meter&amp;gt; 标签 &amp;lt;meter&amp;gt;标签是 HTML 5 中的新标签
作用：定义已知范围或分数值内的标量测量。 &amp;lt;p&amp;gt;显示度量值：&amp;lt;/p&amp;gt; &amp;lt;meter value=&amp;#34;3&amp;#34; min=&amp;#34;0&amp;#34; max=&amp;#34;10&amp;#34;&amp;gt;3/10&amp;lt;/meter&amp;gt;&amp;lt;br /&amp;gt; &amp;lt;meter value=&amp;#34;0.6&amp;#34;&amp;gt;60%&amp;lt;/meter&amp;gt; &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;注释：&amp;lt;/b&amp;gt;Internet Explorer 不支持 meter 标签。&amp;lt;/p&amp;gt; CSS 写一个 reset 的文件 CSS reset，又叫做 CSS 重写或者 CSS 重置，用于改写 HTML 标签的默认样式, 尽量抹平个浏览器的样式差异 进行样式重写时，不建议使用 * 选择器进行重写，这样会降低效率，影响性能 JavaScript 为什么说 js 是弱类型语言 静态语言：我们把在使用之前就需要确认其变量数据类型的称为静态语言。 动态语言：我们把在运行过程中需要检查数据类型的语言称为动态语言。 通常把偷偷进行类型转换的操作成为隐式类型转换：
支持因此类型转换的语言称为弱类型语言 不支持隐式类型转换的语言称为强类型语言 编译型语言：通常都会对源代码进行编译，生成可以执行的二进制代码，执行的是编译后的结果。（C/C++、Object-C、swift, rust） 解释型语言:通常不用对源代码进行编译，一般是通过解释器载入脚本后运行。由于每个语句都是执行的时候才进行解释翻译，这样解释性语言每次执行就要翻译一次，效率相对要低。（JavaScript、Python、Erlang、PHP、Perl、Ruby） Javascript属于弱类型、动态、解释型语言 Tips 让浏览器更快地加载网络资源 通过减少响应内容大小
使用 gzip 算法压缩响应体内容 HTTP/2 的压缩头部功能 另一种更通用也更为重要的技术就是使用缓存 Web 缓存按存储位置来区分，包括数据库缓存、服务端缓存、CDN 缓存和浏览器缓存
HTTP 缓存 尽可能地让浏览器从缓存中获取资源，但同时又要保证被使用的缓存与服务端最新的资源保持一致。为了达到这个目的，需要制定合适的缓存过期策略（简称“缓存策略”），HTTP 支持的缓存策略有两种：强制缓存和协商缓存。
强制缓存 强制缓存是在浏览器加载资源的时候，先直接从缓存中查找请求结果，如果不存在该缓存结果，则直接向服务端发起请求。 Expires Cache-Control no-cache，表示使用协商缓存，即每次使用缓存前必须向服务端确认缓存资源是否更新； no-store，禁止浏览器以及所有中间缓存存储响应内容； public，公有缓存，表示可以被代理服务器缓存，可以被多个用户共享； private，私有缓存，不能被代理服务器缓存，不可以被多个用户共享； max-age，以秒为单位的数值，表示缓存的有效时间； must-revalidate，当缓存过期时，需要去服务端校验缓存的有效性。 cache-control: public, max-age=31536000 - 公有缓存，有效期 1 年</description></item><item><title>毎日のフロントエンド 179</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-179/</link><pubDate>Thu, 17 Mar 2022 22:28:57 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-179/</guid><description>Tips 进程（Process）与线程（Thread） 进程是操作系统进行资源分配和调度的基本单位
线程是操作系统进行运算的最小单位
一个程序至少有一个进程，一个进程至少有一个线程 线程需要由进程来启动和管理。 进程是操作系统资源分配的基本单位，这里隐含的意思就是，不同进程之间的资源是独享的，不可以相互访问。
多线程没有分配独立的资源，线程之间数据都是共享的，也就意味着创建线程的成本更小，因为不需要分配额外的存储空间。
多线程更轻量，多进程更安全更稳定
浏览器架构 浏览器进程
浏览器的主进程负责界⾯显⽰（地址栏、导航栏、书签等）、处理用户事件、管理⼦进程等。 GPU 进程
处理来自其他进程的 GPU 任务，比如来自渲染进程或扩展程序进程的 CSS3 动画效果，来自浏览器进程的界面绘制等。 还有一个重要的特性，那就是可以利用 GPU 硬件来加速渲染，包括 Canvas 绘制、CSS3 转换（Transitions）、CSS3 变换（Transforms）、WebGL 等。具体原理就是如果 DOM 元素使用了这些属性，GPU 进程就会在合成层的时候对它进行单独处理，提升到一个独立的层进行绘制，这样就能避免重新布局和重新绘制。 Network Service 进程
负责⻚⾯的⽹络资源加载，比如在地址栏输入一个网页地址，网络进程会将请求后得到的资源交给渲染进程处理。本来只是浏览器主进程的一个模块，现在为了将浏览器进程进行“服务化”，被抽取出来，成了一个单独的进程。 V8 代理解析工具进程
Chrome 支持使用 JavaScript 来写连接代理服务器脚本，称为 pac 代理脚本 由于 pac 代理脚本是用 JavaScript 编写的，要能够解析 pac 代理脚本就必须要用到 JavaScript 脚本引擎，直接在浏览器主进程中引入 JavaScript 引擎并不符合进程“服务化”的设计理念，所以就把这个解析功能独立成一个进程 渲染进程
浏览器会为每个标签页单独启动一个渲染进程，所以它和上述进程不同，并不是唯一的。 渲染进程的任务是将 HTML、CSS 和 JavaScript 转化为⽤户可以与之交互的网页，每个渲染进程都会启动单独的渲染引擎线程和 JavaScript 引擎线程。 除此之外还包括事件触发线程，负责接收事件，并将回调函数放入 JavaScript 引擎线程的事件队列中，以及负责处理定时任务的定时器线程。 这种设计保障了程序与系统的安全性，可以通过操作系统提供的权限机制来为每个渲染进程建立一个沙箱运行环境，从而防止恶意破坏用户系统或影响其他标签页的行为。 保障了渲染进程的稳定性，因为如果某个标签页失去响应，用户可以关掉这个标签页，此时其他标签页依然运行着，可以正常使用。如果所有标签页都运行在同一进程上，那么当某个失去响应，所有标签页都会失去响应 扩展程序进程
主要是负责插件的运⾏，和渲染进程一样，也不是唯一的，浏览器会为每个插件都启动一个进程。这样的设计也是从安全性和稳定性考虑 进程的服务化 Chrome 官方团队在 2016 年 提出了面向服务的设计模型，在系统资源允许的情况下，将浏览器主进程的各种模块拆分成独⽴的服务，每个服务在独立的进程中运行。通过高内聚、低耦合的结构让 Chrome 变得更稳定更安全。 Reference haizlin/fe-interview</description></item><item><title>毎日のフロントエンド 177</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-177/</link><pubDate>Tue, 15 Mar 2022 11:28:16 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-177/</guid><description>HTML 网站首页有大量的图片，加载很慢，怎么优化 小图用 iconfont（svg）代替。 不能替代的用 base64。 去除 gif 图，用 video 代替。 工具压缩图片的大小。 优先使用 webp 格式 骨骼屏+ 懒加载。 CSS preload、preconnect、prefetch Preload: 在 &amp;lt;link&amp;gt; 标签中使用 preload 时，提前请求资源。主要用于获取当前路由中使用的高优先级资源。 元素的 rel 属性的属性值 preload 能够让你在你的 HTML 页面中元素内部书写一些声明式的资源获取请求，可以指明哪些资源是在页面加载完成后即刻需要的。 rel=&amp;quot;preolad&amp;quot;声明这是一个 preload href 指明资源的位置 as 指明资源类型（这是为了让浏览器精确设置优先级，设置正确的 CSP、Accept 头部） crossorigin 指明使用的跨域设置 添加 preload 声明之后，浏览器初次加载的资源变多了，但 preload 并不会阻塞 onload 事件的触发 Preconnect: 解决 DNS 和 TCP 握手问题, 使浏览器能够预先建立一个连接，等真正需要加载资源的时候就能够直接请求了 Prefetch: 提前获取资源将其置于缓存中，使用资源时从缓存中获取而不是发出另一个请求。 Tips debounce (TypeScript) 函数 debounce 添加类型，包括参数类型和返回值类型。参数类型使用泛型变量，在调用函数 debounce 的时候手动指定，泛型变量有 3 个：函数 T 、函数 T 的返回值 U 和 函数 T 的参数 V 变量 timeout ，当定时器存在时它的值为 number，定时器不存在时值为 null const debounce = &amp;lt;T extends Function, U, V extends any[]&amp;gt;(func: T, wait: number = 0) =&amp;gt; { let timeout: number | null = null; let args: V; function debounced(.</description></item><item><title>毎日のフロントエンド 176</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-176/</link><pubDate>Mon, 14 Mar 2022 17:25:38 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-176/</guid><description>JavaScript 模块化 ES6 模块 ES6 模块强制自动采用严格模式，所以说不管有没有“user strict”声明都是一样的，换言之，编写代码的时候不必再刻意声明了； 虽然大部分主流浏览器支持 ES6 模块，但是和引入普通 JS 的方式略有不同，需要在对应 script 标签中将属性 type 值设置为module才能被正确地解析为 ES6 模块； 在 Node.js 下使用 ES6 模块则需要将文件名后缀改为“.mjs”，用来和 Node.js 默认使用的 CommonJS 规范模块作区分 ES6 模块有两个重要特性
值引用 指 export 语句输出的接口，与其对应的值是动态绑定关系。即通过该接口，可以取到模块内部实时的值，可以简单地理解为变量浅拷贝。 静态分析 指不需要执行代码，只从字面量上对代码进行分析。 // 必须首部声明 let a = 1 import { app } from &amp;#39;./app&amp;#39;; // 不允许使用变量或表达式 import { &amp;#39;a&amp;#39; + &amp;#39;p&amp;#39; + &amp;#39;p&amp;#39; } from &amp;#39;./app&amp;#39;; // 不允许被嵌入语句逻辑 if (moduleName === &amp;#39;app&amp;#39;) { import { init } from &amp;#39;.</description></item><item><title>毎日のフロントエンド 175</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-175/</link><pubDate>Sun, 13 Mar 2022 17:19:01 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-175/</guid><description>CSS css 文件过大时， &amp;ldquo;异步加载 CSS&amp;rdquo; 利用媒体查询 &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;./index.css&amp;quot; media=&amp;quot;none&amp;quot; onload=&amp;quot;this.media='all'&amp;quot;&amp;gt;
OR
&amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;./index1.css&amp;#34; media=&amp;#34;screen and (max-width: 800px)&amp;#34; /&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;./index2.css&amp;#34; media=&amp;#34;screen and (min-width: 800px)&amp;#34; /&amp;gt; rel means relationship
提前加载资源 优先级最高，异步加载，不会阻塞 DOM 的渲染，浏览器支持度比较低。
&amp;lt;link rel=&amp;quot;preload&amp;quot; href=&amp;quot;./index.css&amp;quot; as=&amp;quot;style&amp;quot;&amp;gt;
该属性还可以应用于其他资源
当用到这些资源的时候，浏览器会从缓存中取得，不再次发送请求了
Here however, we will use a rel value of preload, which turns &amp;lt;link&amp;gt; into a preloader for any resource we want. You will also need to specify:
The path to the resource in the href attribute.</description></item><item><title>毎日のフロントエンド 173</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-173/</link><pubDate>Fri, 11 Mar 2022 15:40:11 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-173/</guid><description>HTML HTML 的标签区分大小写 DOCTYPE 声明, 不区分大小写
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;!doctype html&amp;gt; &amp;lt;!DOCTYPE HTML&amp;gt; &amp;lt;!Doctype html&amp;gt; HTML 文档中的标签名和属性名都是大小写不敏感的
HTML 中属性的名字是大小写不敏感的，而属性的值则默认是大小写敏感的
下述列表中的属性的值是大小写不敏感的: accept accept-charset align alink axis bgcolor charset checked clear codetype color compact declare defer dir direction disabled enctype face frame hreflang http-equiv lang language link media method multiple nohref noresize noshade nowrap readonly rel rev rules scope scrolling selected shape target text type (视情况而定) valign valuetype vlink XML 文档中的标签名和属性名都是大小写敏感的。
大小写不敏感
meta 标签中的 name meta 标签中的 http-equiv http-equiv=&amp;ldquo;X-UA-Compatible&amp;rdquo; &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt; 或者 &amp;lt;meta http-equiv=&amp;quot;content-type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot;&amp;gt; CSS 字体图标 Font Awesome</description></item><item><title>毎日のフロントエンド 172</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-172/</link><pubDate>Thu, 10 Mar 2022 20:42:49 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-172/</guid><description>Tips 函数为什么是一等公民 据类型与函数是很多高级语言中最重要的两个概念，前者用来存储数据，后者用来存储代码。JavaScript 中的函数相对于数据类型而言更加复杂，它可以有属性，也可以被赋值给一个变量，还可以作为参数被传递&amp;hellip;&amp;hellip;正是这些强大特性让它成了 JavaScript 的“一等公民”
this 关键字 this 指向的应该是一个对象，更具体地说是函数执行的“上下文对象” 这个对象指向的是“调用它”的对象，如果调用它的不是对象或对象不存在，则会指向全局对象（严格模式下为 undefined） function fn() { console.log(this); } function fn2() { fn(); } var obj = { fn2 }; obj.fn2(); // ? 调用函数 fn() 的是函数 fn2() 而不是 obj。虽然 fn2() 作为 obj 的属性调用，但 fn2()中的 this 指向并不会传递给函数 fn()， 所以答案也是 window（Node.js 下是 global） var dx = { arr: [1], }; dx.arr.forEach(function () { console.log(this); }); // ? forEach，它有两个参数，第一个是回调函数，第二个是 this 指向的对象，这里只传入了回调函数，第二个参数没有传入，默认为 undefined，所以正确答案应该是输出全局对象。 类似的，需要传入 this 指向的函数还有：every()、find()、findIndex()、map()、some() class B { fn() { console.</description></item><item><title>毎日のフロントエンド 161</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-161/</link><pubDate>Thu, 24 Feb 2022 16:52:49 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-161/</guid><description>HTML HTML 调用摄像头 window.navigator.getUserMedia()
接收三个参数，第一个是视频或者音频以及分辨率{video:true}第二个是成功回调，第三个是失败回调 window.navigator.mediaDevices.getUserMedia()
也是三个参数，参数格式和上文一样，区别在于这个 api 是基于 promise 实现的 JavaScript Nodejs Process.nextTick process.nextTick(callback[, ...args])
第一个参数是 callback 回调函数，第二个参数是 args 调用 callback 时额外传的参数，是可选参数 Process.nextTick 是微任务 也是异步 API 的一部分
Process.nextTick 的运行逻辑：
Process.nextTick 会将 callback 添加到“next tick queue”； “next tick queue”会在当前 JavaScript stack 执行完成后，下一次 event loop 开始执行前按照 FIFO 出队； 如果递归调用 Process.nextTick 可能会导致一个无限循环，需要去适时终止递归。 根据代码执行顺序，Process.nextTick 是在每一次的事件循环最后执行的。
let bar; function someAsyncApiCall(callback) { process.nextTick(callback); } someAsyncApiCall(() =&amp;gt; { console.log(&amp;#39;bar&amp;#39;, bar); // 1 }); bar = 1;</description></item><item><title>毎日のフロントエンド 160</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-160/</link><pubDate>Wed, 23 Feb 2022 17:07:08 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-160/</guid><description>CSS 第一行和第二行的颜色分别是什么 &amp;lt;style&amp;gt; .red { color: red; } .green { color: green; } &amp;lt;/style&amp;gt; &amp;lt;div class=&amp;#34;red green&amp;#34;&amp;gt;第一行：颜色是什么？&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;green red&amp;#34;&amp;gt;第二行：颜色是什么？&amp;lt;/div&amp;gt; 都是绿色。CSS 的覆盖顺序与标签内 class 定义的顺序无关，只与 style 中的顺序有关，后面的覆盖前面的属性 JavaScript 有些 js 库习惯在代码开头处添加分号有什么作用 js 文件结束 处是 没有 分号的。若几个 js 连在一起时，2 个 js 连接处 会发生语法上的混淆。 开头加; 用于分隔， 可以避免多文件压缩在一起时引起的错误。分号和分号放在一起也没问题，相当于 “空语句”。 可以用void ! + ~ 代替 宏任务和微任务 代码执行顺序 console.log(&amp;#39;begin&amp;#39;); setTimeout(() =&amp;gt; { console.log(&amp;#39;setTimeout&amp;#39;); }, 0); new Promise((resolve) =&amp;gt; { console.log(&amp;#39;promise&amp;#39;); resolve(); }) .then(() =&amp;gt; { console.log(&amp;#39;then1&amp;#39;); }) .</description></item><item><title>毎日のフロントエンド 159</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-159/</link><pubDate>Tue, 22 Feb 2022 23:06:50 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-159/</guid><description>第一百五十九日 HTML html 实现下拉提示 datalist - HTML（超文本标记语言） | MDN &amp;lt;label for=&amp;#34;favorite_team&amp;#34;&amp;gt;Favorite Team:&amp;lt;/label&amp;gt; &amp;lt;!-- 注意input的list属性与datalist的id属性进行绑定 --&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;team&amp;#34; id=&amp;#34;favorite_team&amp;#34; list=&amp;#34;team_list&amp;#34; autocomplete=&amp;#34;off&amp;#34;/&amp;gt; &amp;lt;datalist id=&amp;#34;team_list&amp;#34;&amp;gt; &amp;lt;!-- 指定了value值之后，value和innerHTML类似于标题与副标题之间的关系，选中后input的值是value --&amp;gt; &amp;lt;option value=&amp;#34;A&amp;#34;&amp;gt;Aus Tigers&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;B&amp;#34;&amp;gt;Detroit Lions&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;C&amp;#34;&amp;gt;Detroit Pistons&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;D&amp;#34;&amp;gt;Detroit Red Wings&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;E&amp;#34;&amp;gt;Detroit Tigers&amp;lt;/option&amp;gt; &amp;lt;/datalist&amp;gt; &amp;lt;/datalist&amp;gt; CSS 两端对齐 对于文字，利用 text-align-last:justify; or :before 模拟成多行然后 text-align: justify 子元素的两端对齐，用 float 或 flex 或 grid Tips attribute 和 property 区别 attribute
元素在 HTML 中的键值对 attribute 会始终保持 html 代码中的初始值(除了 href) property</description></item><item><title>毎日のフロントエンド 158</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-158/</link><pubDate>Mon, 21 Feb 2022 21:20:02 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-158/</guid><description>第一百五十八日 Tips V8 引擎 V8 引擎执行 JS 代码都要经过哪些阶段 Parse 阶段：V8 引擎负责将 JS 代码转换成 AST（抽象语法树）； Ignition 阶段：解释器将 AST 转换为字节码，解析执行字节码也会为下一个阶段优化编译提供需要的信息； TurboFan 阶段：编译器利用上个阶段收集的信息，将字节码优化为可以执行的机器码； Orinoco 阶段：垃圾回收阶段，将程序中不再使用的内存空间进行回收。 生成 AST AST 抽象语法树的应用场景
JS 反编译，语法解析； Babel 编译 ES6 语法； 代码高亮； 关键字匹配； 代码压缩。 AST 分为两个阶段
词法分析： 这个阶段会将源代码拆成最小的、不可再分的词法单元，称为 token。比如这行代码 var a =1；通常会被分解成 var 、a、=、2、; 这五个词法单元。另外刚才代码中的空格在 JavaScript 中是直接忽略的。 语法分析 这个过程是将词法单元转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，这个树被称为抽象语法树。 // 第一段代码 var a = 1; // 第二段代码 function sum(a, b) { return a + b; } 分别转换成 AST 抽象语法树之后返回的 JSON 格式如下</description></item><item><title>毎日のフロントエンド 157</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-157/</link><pubDate>Sun, 20 Feb 2022 11:26:21 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-157/</guid><description>第一百五十七日 HTML bdo 标签 将内部的文字反序输出 属性是dir 默认是ltr 需要倒叙就改成rtl CSS 外边距重叠 外边距重叠是什么？
外边距重叠指的是，当两个垂直外边距相遇时，它们将形成一个外边距。 重叠后的外边距的高度等于两个发生重叠的外边距的高度中的较大者。 发生的条件：属于同一个 BFC 的两个相邻元素上下 margin 会重叠。 重叠的结果是什么？
举例 1：当一个元素出现在另一个元素上面时，重叠后的外边距的高度等于两个发生重叠的外边距的高度中的较大者。 举例 2： 当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距也会发生重叠。如果这个外边距遇到另一个元素的外边距，它还会发生重叠。 怎么防止外边距重叠？
浮动元素、inline-block 元素、绝对定位元素的 margin 不会和垂直方向上其他元素的 margin 折叠（注意这里指的是上下相邻的元素） 外层元素 padding 代替 内层元素透明边框 border:1px solid transparent; 用同一方向的 margin，都设置为 top 或者 bottom。 Tips 浏览器的 Eventloop 1.调用堆栈（call stack）负责跟踪所有要执行的代码 每当一个函数执行完成时，就会从堆栈中弹出（pop）该执行完成函数 如果有代码需要进去执行的话，就进行 push 操作 2.事件队列（event queue）负责将新的 function 发送到队列中进行处理 遵循 queue 的数据结构特性，先进先出，在该顺序下发送所有操作以进行执行 3.每当调用事件队列（event queue）中的异步函数时，都会将其发送到浏览器 API 根据从调用堆栈收到的命令，API 开始自己的单线程操作 其中 setTimeout 方法就是一个比较典型的例子，在堆栈中处理 setTimeout 操作时，会将其发送到相应的 API，该 API 一直等到指定的时间将此操作送回进行处理 操作发送到 事件队列（event queue） 4.</description></item><item><title>毎日のフロントエンド 156</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-156/</link><pubDate>Sat, 19 Feb 2022 15:08:08 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-156/</guid><description>第一百五十六日 CSS border:none和border:0px区别 从border: 10px;过渡到border: none;，是不会有动画的 从border: 10px;过渡到border: 0px;，是可以有动画的 Tips JavaScript 的内存管理 基本类型：这些类型在内存中会占据固定的内存空间，它们的值都保存在栈空间中，直接可以通过值来访问这些； 引用类型：由于引用类型值大小不固定（比如上面的对象可以添加属性等），栈内存中存放地址指向堆内存中的对象，是通过引用来访问的 栈内存中的基本类型，可以通过操作系统直接处理；而堆内存中的引用类型，正是由于可以经常变化，大小不固定，因此需要 JavaScript 的引擎通过垃圾回收机制来处理。
Chrome 内存回收机制 Chrome 的 JavaScript 引擎 V8 将堆内存分为两类 新生代的回收机制和老生代的回收机制
内存泄漏与优化 内存泄漏的场景： 过多的缓存未释放 闭包太多未释放 定时器或者回调太多未释放 太多无效的 DOM 未释放 全局变量太多未被发现 减少不必要的全局变量，使用严格模式避免意外创建全局变量 function foo() { // 全局变量=&amp;gt; window.bar this.bar = &amp;#39;默认this指向全局&amp;#39;; // 没有声明变量，实际上是全局变量=&amp;gt;window.bar bar = &amp;#39;全局变量&amp;#39;; } foo(); 在你使用完数据后，及时解除引用（闭包中的变量，DOM 引用，定时器清除） var someResource = getData(); setInterval(function() { var node = document.getElementById(&amp;#39;Node&amp;#39;); if(node) { node.innerHTML = JSON.stringify(someResource)); // 定时器也没有清除，可以清除掉 } // node、someResource 存储了大量数据，无法回收 }, 1000); 组织好代码逻辑，避免死循环等造成浏览器卡顿、崩溃的问题 Reference haizlin/fe-interview</description></item><item><title>毎日のフロントエンド 155</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-155/</link><pubDate>Fri, 18 Feb 2022 10:51:40 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-155/</guid><description>第一百五十五日 HTML HTML5 有哪些存储类型 cookie: 最大 4k, 基本无兼容问题, 所有同源 tab 共享, 每次请求都携带, key-value 存储, value 只存字符串 sessionStorage 无大小限制, 只在当前 tab 有效, tab 关闭即失效, key-value 存储, value 只存字符串 localStorage 最大 5M-10M, 所有同源 tab 共享, 能持久化存储, key-value 存储, value 只存字符串 indexDB key-value 存储,value 可以任意类型, 同源, 支持事务, 最大 250M, 兼容 ie10 webSQL 支持版本,事务,支持 sql 语句, 不兼容 ie CSS CSS Guidelines (2.2.5) – High-level advice and guidelines for writing sane, manageable, scalable CSS
JavaScript 实现一个Promise Promise/A+ 规范</description></item><item><title>毎日のフロントエンド 154</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-154/</link><pubDate>Thu, 17 Feb 2022 16:45:01 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-154/</guid><description>第一百五十四日 JavaScript 并行和并发、同步和异步、阻塞和非阻塞 并发并行是处理任务的方式 并发是在一个时间段可以处理多个任务，但是在相同的时间内只能处理一个任务 并行是同时可以处理多个任务 同步异步是处理运行结果的方式 同步是在上一个返回结果还没返回的时候就不进行下一步的调用 异步是上一个结果还没返回就继续执行下一步，直到有返回结果了再调用对应的异步回调 阻塞和非阻塞是运行时的状态 阻塞是在上一个任务还在执行时，下一个任务处于无法执行的状态，需要继续等待，直到上一个任务执行完毕 非阻塞就是任务的执行状态一直是上一个执行了，下一个就继续执行，没有多余的等待时间 Tips EventEmitter(node) 常用的 EventEmitter 模块的 API addListener 和 removeListener、on 和 off 方法对比 addListener 方法的作用是为指定事件添加一个监听器，其实和 on 方法实现的功能是一样的，on 其实就是 addListener 方法的一个别名。二者实现的作用是一样的 removeListener 方法的作用是为移除某个事件的监听器，同样 off 也是 removeListener 的别名 var events = require(&amp;#39;events&amp;#39;); var emitter = new events.EventEmitter(); function hello1(name) { console.log(&amp;#39;hello 1&amp;#39;, name); } function hello2(name) { console.log(&amp;#39;hello 2&amp;#39;, name); } emitter.addListener(&amp;#39;say&amp;#39;, hello1); emitter.addListener(&amp;#39;say&amp;#39;, hello2); emitter.emit(&amp;#39;say&amp;#39;, &amp;#39;John&amp;#39;); //输出hello 1 John //输出hello 2 John emitter.</description></item><item><title>毎日のフロントエンド 153</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-153/</link><pubDate>Wed, 16 Feb 2022 16:56:17 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-153/</guid><description>第一百五十三日 HTML 单词标志缩写 &amp;lt;abbr&amp;gt; - HTML（超文本标记语言） | MDN CSS 背景裁剪 background-clip`: border-box: 默认,背景延伸至边框外沿,但是在边框的下层 padding-box: 背景延伸至 padding 的外沿 content-box: 背景延伸至内容的外沿 text: 背景剪裁成文字的样式 Tips 异步编程 什么是同步 所谓的同步就是在执行某段代码时，在该代码没有得到返回结果之前，其他代码暂时是无法执行的，但是一旦执行完成拿到返回值之后，就可以执行其他代码了。换句话说，在此段代码执行完未返回结果之前，会阻塞之后的代码执行，这样的情况称为同步。
什么是异步 所谓异步就是当某一代码执行异步过程调用发出后，这段代码不会立刻得到返回结果。而是在异步调用发出之后，一般通过回调函数处理这个调用之后拿到结果。异步调用发出后，不会影响阻塞后面的代码执行，这样的情形称为异步。
Promise function read(url) { return new Promise((resolve, reject) =&amp;gt; { fs.readFile(url, &amp;#39;utf8&amp;#39;, (err, data) =&amp;gt; { if (err) reject(err); resolve(data); }); }); } // 通过 Promise.all 可以实现多个异步并行执行，同一时刻获取最终结果的问题 Promise.all([read(A), read(B), read(C)]) .then((data) =&amp;gt; { console.log(data); }) .catch((err) =&amp;gt; console.log(err)); 简单来说Promise就是一个容器，里面保存着某个未来才会结束的事件（通常是异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息
Promise 内部的状态流转情况：（Promise 对象在被创建出来时是待定的状态）(内部状态改变之后不可逆)</description></item><item><title>毎日のフロントエンド 152</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-152/</link><pubDate>Tue, 15 Feb 2022 17:28:33 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-152/</guid><description>第一百五十二日 HTML small标签 &amp;lt;small&amp;gt;元素將使文本的字体变小一号。(例如从大变成中等，从中等变成小，从小变成超小)。在 HTML5 中，除了它的样式含义，这个元素被重新定义为表示边注释和附属细则，包括版权和法律文本。 JavaScript CORS 预检请求 简单请求 同源策略是一个重要的安全策略，它用于限制一个 origin 的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。 当一个资源从与该资源本身所在的服务器不同的域、协议、端口请求一个资源时，资源会发起一个跨域 HTTP 请求。
出于安全原因，浏览器限制从脚本内发起的跨源 HTTP 请求，XMLHttpRequest 和 Fetch API，只能从加载应用程序的同一个域请求 HTTP 资源，除非使用 CORS 头文件 CORS 概述 跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。
另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。
服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）
cors-flow 简单请求 不会触发 CORS 预检的请求称为简单请求，满足以下所有条件的才会被视为简单请求: 使用GET、POST、HEAD其中一种方法 只使用了如下的安全首部字段，不得人为设置其他首部字段 Accept Accept-Language Content-Language Content-Type 仅限以下三种 text/plain multipart/form-data application/x-www-form-urlencoded HTML 头部 header field 字段：DPR、Download、Save-Data、Viewport-Width、Width 请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload对象可以使用 XMLHttpRequest.</description></item><item><title>毎日のフロントエンド 151</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-151/</link><pubDate>Mon, 14 Feb 2022 10:24:45 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-151/</guid><description>第一百五十一日 HTML Question: 在页面中添加数学公式 KaTeX – The fastest math typesetting library for the web MathJax | Beautiful math in all browsers. Tips 常用的数组方法底层实现 push 方法的底层实现 Array.prototype.push = function (...items) { let O = Object(this); // ecma 中提到的先转换为对象 // &amp;gt;&amp;gt;&amp;gt; 无符号右移 &amp;gt;&amp;gt;&amp;gt; 0 对非负数 取整; // 确保 ensure that the length property is a unsigned 32-bit integer. let len = this.length &amp;gt;&amp;gt;&amp;gt; 0; let argCount = items.length &amp;gt;&amp;gt;&amp;gt; 0; // 2 ^ 53 - 1 为JS能表示的最大正整数 if (len + argCount &amp;gt; 2 ** 53 - 1) { throw new TypeError(&amp;#39;The number of array is over the max value&amp;#39;); } for (let i = 0; i &amp;lt; argCount; i++) { O[len + i] = items[i]; } let newLength = len + argCount; O.</description></item><item><title>毎日のフロントエンド 150</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-150/</link><pubDate>Sun, 13 Feb 2022 15:12:49 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-150/</guid><description>第一百五十日 HTML Question: HTML5 如何使某个页面元素或整个页面可编辑 让某个元素可以编辑，可以使用 contenteditable 属性 让整个页面可编辑可以使用 document.designMode 属性 CSS Question: 什么时候用 transition？什么时候使用 animation transition 相当于是个过度动画，需要又过度效果才会触发。一般用来做元素的放大缩小、平移旋转等简单的操作 transition 只执行一次，当需要执行多次时，一般会利用 :hover 等时机或者使用 javaScript 改变类名进行控制。 animation 需要自己设定关键帧，可以做相对复杂的操作，比如延迟、循环播放等。一般在需要比较复杂的情况才会使用 animation Tips sort排序算法实现原理 arr.sort([compareFunction]) 数组已原地排序，并且不进行复制 compareFunction 用来指定按某种顺序进行排列的函数，如果省略不写，元素按照转换为字符串的各个字符的 Unicode 位点进行排序 const months = [&amp;#39;March&amp;#39;, &amp;#39;Jan&amp;#39;, &amp;#39;Feb&amp;#39;, &amp;#39;Dec&amp;#39;]; months.sort(); console.log(months); // [&amp;#34;Dec&amp;#34;, &amp;#34;Feb&amp;#34;, &amp;#34;Jan&amp;#34;, &amp;#34;March&amp;#34;] const array1 = [1, 30, 4, 21, 100000]; array1.sort(); console.log(array1); // [1, 100000, 21, 30, 4] 如果指明了 compareFunction 参数 ，那么数组会按照调用该函数的返回值排序，即 a 和 b 是两个将要被比较的元素： 如果 compareFunction（a, b)小于 0，那么 a 会被排列到 b 之前； 如果 compareFunction（a, b)等于 0，a 和 b 的相对位置不变； 如果 compareFunction（a, b)大于 0，b 会被排列到 a 之前。 sort 源码分析</description></item><item><title>毎日のフロントエンド 149</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-149/</link><pubDate>Sat, 12 Feb 2022 16:50:12 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-149/</guid><description>第一百四十九日 HTML Question: 整个页面中的内容设置成只读，不可编辑的状态 body { pointer-events: none !important; } Tips 数组排序 比较类排序：通过比较来决定元素间的相对次序，其时间复杂度不能突破 O(nlogn)，因此也称为非线性时间比较类排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 排序的分类 冒泡排序 let a = [1, 3, 6, 3, 23, 76, 1, 34, 222, 6, 456, 221]; function bubbleSort(array) { const len = array.length; if (len &amp;lt; 2) return array; for (let i = 0; i &amp;lt; len; i++) { for (let j = 0; j &amp;lt; i; j++) { if (array[j] &amp;gt; array[i]) { const temp = array[j]; array[j] = array[i]; array[i] = temp; } } } return array; } bubbleSort(a); // [1, 1, 3, 3, 6, 6, 23, 34, 76, 221, 222, 456] 快速排序 最主要的思路是从数列中挑出一个元素，称为 “基准”（pivot）；然后重新排序数列，所有元素比基准值小的摆放在基准前面、比基准值大的摆在基准的后面；在这个区分搞定之后，该基准就处于数列的中间位置；然后把小于基准值元素的子数列（left）和大于基准值元素的子数列（right）递归地调用 quick 方法排序完成。 let a = [1, 3, 6, 3, 23, 76, 1, 34, 222, 6, 456, 221]; function quickSort(array) { let quick = function (arr) { if (arr.</description></item><item><title>毎日のフロントエンド 147</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-147/</link><pubDate>Thu, 10 Feb 2022 12:56:13 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-147/</guid><description>第一百四十六日 HTML Question: 本地存储的生命周期 cookie: expire 和 max-age 都能控制数据的存储时间。expire 是一个绝对的过期时间，max-age 是文档被访问之后的存活时间（是相对时间）。默认是 session (一次会话) sessionStorage: 当会话被关闭后（浏览器、标签页被关闭），就会被清除。与 localStorage 用法一样 localStorage: 除非被主动清除，不然永久储存在浏览器中 IndexedDB: 没有过期时间，除非主动清除 CSS Question: background-attachment属性 background-attachment: fixed / scroll / local： 设置背景图像是否固定或者随着页面的其余部分滚动。 fixed: 背景图片不会随着页面的滚动而滚动 scroll: 背景图片随着页面的滚动而滚动，默认 local: 背景图片会随着元素内容的滚动而滚动 inherit: 指定 background-attachment 的设置应该从父元素继承。 Tips 数组扁平化 数组的扁平化其实就是将一个嵌套多层的数组 array（嵌套可以是任何层数）转换为只有一层的数组。
方法一：普通的递归实现 // 方法1 // 在遍历过程中发现数组元素还是数组的时候进行递归操作， // 把数组的结果通过数组的 concat 方法拼接到最后要返回的 result 数组上，那么最后输出的结果就是扁平化后的数组。 var a = [1, [2, [3, 4, 5]]]; function flatten(arr) { let result = []; for (let i = 0; i &amp;lt; arr.</description></item><item><title>毎日のフロントエンド 146</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-146/</link><pubDate>Wed, 09 Feb 2022 11:17:27 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-146/</guid><description>第一百四十六日 HTML Question: viewport 是什么？在什么时候下使用 viewport 是用户网页的可视区域 多用于移动端，也可以用在支持类似“固定到边缘”等特性的桌面浏览器 移动端的浏览器是把页面放在一个虚拟的&amp;quot;窗口&amp;quot;（viewport）中，通常这个虚拟的&amp;quot;窗口&amp;quot;（viewport）比物理屏幕宽，这样就不用把每个网页挤到很小的窗口中（这样会破坏没有针对手机浏览器优化的网页的布局），用户可以通过平移和缩放来看网页的不同部分 visual viewport 尺寸所对应的并不是指屏幕区域里的物理像素，而是 CSS 像素。并且它所包含的 CSS 像素的数量也是随着用户缩放而有所改变 在 head 加入这行，把默认的 layout viewport 的宽度设为移动设备的屏幕宽度，也就是把当前的 viewport 宽度设置为设备物理屏幕的宽度，实现全屏的效果 &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no&amp;quot;&amp;gt; Tips 类数组 函数里面的参数对象 arguments 用 getElementsByTagName/ClassName/Name 获得的 HTMLCollection 用 querySelector 获得的 NodeList arguments对象 只定义在函数体中 有一个 length 属性 callee 属性(此函数自身) function foo(name, age, sex) { console.log(arguments); // [Arguments] { &amp;#39;0&amp;#39;: &amp;#39;jack&amp;#39;, &amp;#39;1&amp;#39;: &amp;#39;18&amp;#39;, &amp;#39;2&amp;#39;: &amp;#39;male&amp;#39; } console.log(typeof arguments); // object console.</description></item><item><title>毎日のフロントエンド 145</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-145/</link><pubDate>Tue, 08 Feb 2022 20:47:08 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-145/</guid><description>第一百四十五日 HTML Question: 表单属性type=&amp;quot;hidden&amp;quot; &amp;lt;input type=&amp;quot;hidden&amp;quot;&amp;gt; &amp;ldquo;hidden&amp;rdquo; 类型的 &amp;lt;input&amp;gt; 元素允许 Web 开发者存放一些用户不可见、不可改的数据，在用户提交表单时，这些数据会一并发送出。比如，正被请求或编辑的内容的 ID，或是一个唯一的安全令牌。这些隐藏的 &amp;lt;input&amp;gt;元素在渲染完成的页面中完全不可见，而且没有方法可以使它重新变为可见。 隐藏域在页面中对于用户是不可见的，在表单中插入隐藏域的目的在于收集或发送信息，以利于被处理表单的程序所使用。浏览者单击发送按钮发送表单的时候，隐藏域的信息也被一起发送到服务器 有些时候要给用户一信息，在提交表单时一同提交,以确定用户身份，如 sessionkey 等．同样也可以用 cookie 实现，但使用隐藏域就简单的多了．兼容性好，且可以避免被禁用cookies 一个 form 里有多个提交按钮，怎样使程序能够分清楚到底用户是按那一个按钮提交上来的呢？ 这时可以添加隐藏域，然后在每一个按钮处加上 οnclick=&amp;ldquo;document.form.command.value=&amp;ldquo;xx&amp;rdquo;， 然后接到数据后先检查 command 的值就会知道用户是按的那个按钮提交上来的 一个网页中有多个 form，我们知道多个 form 是不能同时提交的，但有时这些 form 确实相互作用，我们就可以在 form 中添加隐藏域来使它们联系起来 JavaScript Question: 原生 Math 的方法有哪些 常用方法
Math.abs(num) // num绝对值 Math.ceil(num) // num向上取整 Math.floor(num) // num向下取整 Math.max(num1, num2 ...) // 取较大值 Math.min(num1, num2 ...) // 取较小值 Math.pow(num1, num2) // num1的num2次幂 Math.random() // 0-1间伪随机数 Math.sqrt(num) // num的平方根 Tips 数组遍历的方法 基于 ES6，不会改变自身的遍历方法一共有 12 个，分别为 forEach、every、some、filter、map、reduce、reduceRight，以及 ES6 新增的方法 entries、find、findIndex、keys、values // forEach方法 var array = [1, 3, 5]; var obj = { name: &amp;#39;cc&amp;#39; }; // callback 参数顺序 1.</description></item></channel></rss>