<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tips on 技術の手帳</title><link>https://youkoucoding.github.io/categories/tips/</link><description>Recent content in Tips on 技術の手帳</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 15 Feb 2022 17:28:33 +0900</lastBuildDate><atom:link href="https://youkoucoding.github.io/categories/tips/index.xml" rel="self" type="application/rss+xml"/><item><title>毎日のフロントエンド 152</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-152/</link><pubDate>Tue, 15 Feb 2022 17:28:33 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-152/</guid><description>第一百五十二日 HTML small标签 &amp;lt;small&amp;gt;元素將使文本的字体变小一号。(例如从大变成中等，从中等变成小，从小变成超小)。在 HTML5 中，除了它的样式含义，这个元素被重新定义为表示边注释和附属细则，包括版权和法律文本。 JavaScript CORS 预检请求 简单请求 同源策略是一个重要的安全策略，它用于限制一个 origin 的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。 当一个资源从与该资源本身所在的服务器不同的域、协议、端口请求一个资源时，资源会发起一个跨域 HTTP 请求。
出于安全原因，浏览器限制从脚本内发起的跨源 HTTP 请求，XMLHttpRequest 和 Fetch API，只能从加载应用程序的同一个域请求 HTTP 资源，除非使用 CORS 头文件 CORS 概述 跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。
另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。
服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）
cors-flow
简单请求 不会触发 CORS 预检的请求称为简单请求，满足以下所有条件的才会被视为简单请求: 使用GET、POST、HEAD其中一种方法 只使用了如下的安全首部字段，不得人为设置其他首部字段 Accept Accept-Language Content-Language Content-Type 仅限以下三种 text/plain multipart/form-data application/x-www-form-urlencoded HTML 头部 header field 字段：DPR、Download、Save-Data、Viewport-Width、Width 请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload对象可以使用 XMLHttpRequest.</description></item><item><title>毎日のフロントエンド 151</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-151/</link><pubDate>Mon, 14 Feb 2022 10:24:45 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-151/</guid><description>第一百五十一日 HTML Question: 在页面中添加数学公式 KaTeX – The fastest math typesetting library for the web MathJax | Beautiful math in all browsers. Tips 常用的数组方法底层实现 push 方法的底层实现 Array.prototype.push = function (...items) { let O = Object(this); // ecma 中提到的先转换为对象 // &amp;gt;&amp;gt;&amp;gt; 无符号右移 &amp;gt;&amp;gt;&amp;gt; 0 对非负数 取整; // 确保 ensure that the length property is a unsigned 32-bit integer. let len = this.length &amp;gt;&amp;gt;&amp;gt; 0; let argCount = items.</description></item><item><title>毎日のフロントエンド 150</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-150/</link><pubDate>Sun, 13 Feb 2022 15:12:49 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-150/</guid><description>第一百五十日 HTML Question: HTML5 如何使某个页面元素或整个页面可编辑 让某个元素可以编辑，可以使用 contenteditable 属性 让整个页面可编辑可以使用 document.designMode 属性 CSS Question: 什么时候用 transition？什么时候使用 animation transition 相当于是个过度动画，需要又过度效果才会触发。一般用来做元素的放大缩小、平移旋转等简单的操作 transition 只执行一次，当需要执行多次时，一般会利用 :hover 等时机或者使用 javaScript 改变类名进行控制。 animation 需要自己设定关键帧，可以做相对复杂的操作，比如延迟、循环播放等。一般在需要比较复杂的情况才会使用 animation Tips sort排序算法实现原理 arr.sort([compareFunction]) 数组已原地排序，并且不进行复制 compareFunction 用来指定按某种顺序进行排列的函数，如果省略不写，元素按照转换为字符串的各个字符的 Unicode 位点进行排序 const months = [&amp;#39;March&amp;#39;, &amp;#39;Jan&amp;#39;, &amp;#39;Feb&amp;#39;, &amp;#39;Dec&amp;#39;]; months.sort(); console.log(months); // [&amp;#34;Dec&amp;#34;, &amp;#34;Feb&amp;#34;, &amp;#34;Jan&amp;#34;, &amp;#34;March&amp;#34;] const array1 = [1, 30, 4, 21, 100000]; array1.sort(); console.log(array1); // [1, 100000, 21, 30, 4] 如果指明了 compareFunction 参数 ，那么数组会按照调用该函数的返回值排序，即 a 和 b 是两个将要被比较的元素： 如果 compareFunction（a, b)小于 0，那么 a 会被排列到 b 之前； 如果 compareFunction（a, b)等于 0，a 和 b 的相对位置不变； 如果 compareFunction（a, b)大于 0，b 会被排列到 a 之前。 sort 源码分析</description></item><item><title>毎日のフロントエンド 149</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-149/</link><pubDate>Sat, 12 Feb 2022 16:50:12 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-149/</guid><description>第一百四十九日 HTML Question: 整个页面中的内容设置成只读，不可编辑的状态 body { pointer-events: none !important; } Tips 数组排序 比较类排序：通过比较来决定元素间的相对次序，其时间复杂度不能突破 O(nlogn)，因此也称为非线性时间比较类排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 排序的分类
冒泡排序 let a = [1, 3, 6, 3, 23, 76, 1, 34, 222, 6, 456, 221]; function bubbleSort(array) { const len = array.length; if (len &amp;lt; 2) return array; for (let i = 0; i &amp;lt; len; i++) { for (let j = 0; j &amp;lt; i; j++) { if (array[j] &amp;gt; array[i]) { const temp = array[j]; array[j] = array[i]; array[i] = temp; } } } return array; } bubbleSort(a); // [1, 1, 3, 3, 6, 6, 23, 34, 76, 221, 222, 456] 快速排序 最主要的思路是从数列中挑出一个元素，称为 “基准”（pivot）；然后重新排序数列，所有元素比基准值小的摆放在基准前面、比基准值大的摆在基准的后面；在这个区分搞定之后，该基准就处于数列的中间位置；然后把小于基准值元素的子数列（left）和大于基准值元素的子数列（right）递归地调用 quick 方法排序完成。 let a = [1, 3, 6, 3, 23, 76, 1, 34, 222, 6, 456, 221]; function quickSort(array) { let quick = function (arr) { if (arr.</description></item><item><title>毎日のフロントエンド 147</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-147/</link><pubDate>Thu, 10 Feb 2022 12:56:13 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-147/</guid><description>第一百四十六日 HTML Question: 本地存储的生命周期 cookie: expire 和 max-age 都能控制数据的存储时间。expire 是一个绝对的过期时间，max-age 是文档被访问之后的存活时间（是相对时间）。默认是 session (一次会话) sessionStorage: 当会话被关闭后（浏览器、标签页被关闭），就会被清除。与 localStorage 用法一样 localStorage: 除非被主动清除，不然永久储存在浏览器中 IndexedDB: 没有过期时间，除非主动清除 CSS Question: background-attachment属性 background-attachment: fixed / scroll / local： 设置背景图像是否固定或者随着页面的其余部分滚动。 fixed: 背景图片不会随着页面的滚动而滚动 scroll: 背景图片随着页面的滚动而滚动，默认 local: 背景图片会随着元素内容的滚动而滚动 inherit: 指定 background-attachment 的设置应该从父元素继承。 Tips 数组扁平化 数组的扁平化其实就是将一个嵌套多层的数组 array（嵌套可以是任何层数）转换为只有一层的数组。
方法一：普通的递归实现 // 方法1 // 在遍历过程中发现数组元素还是数组的时候进行递归操作， // 把数组的结果通过数组的 concat 方法拼接到最后要返回的 result 数组上，那么最后输出的结果就是扁平化后的数组。 var a = [1, [2, [3, 4, 5]]]; function flatten(arr) { let result = []; for (let i = 0; i &amp;lt; arr.</description></item><item><title>毎日のフロントエンド 146</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-146/</link><pubDate>Wed, 09 Feb 2022 11:17:27 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-146/</guid><description>第一百四十六日 HTML Question: viewport 是什么？在什么时候下使用 viewport 是用户网页的可视区域 多用于移动端，也可以用在支持类似“固定到边缘”等特性的桌面浏览器 移动端的浏览器是把页面放在一个虚拟的&amp;quot;窗口&amp;quot;（viewport）中，通常这个虚拟的&amp;quot;窗口&amp;quot;（viewport）比物理屏幕宽，这样就不用把每个网页挤到很小的窗口中（这样会破坏没有针对手机浏览器优化的网页的布局），用户可以通过平移和缩放来看网页的不同部分 visual viewport 尺寸所对应的并不是指屏幕区域里的物理像素，而是 CSS 像素。并且它所包含的 CSS 像素的数量也是随着用户缩放而有所改变 在 head 加入这行，把默认的 layout viewport 的宽度设为移动设备的屏幕宽度，也就是把当前的 viewport 宽度设置为设备物理屏幕的宽度，实现全屏的效果 &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no&amp;quot;&amp;gt; Tips 类数组 函数里面的参数对象 arguments 用 getElementsByTagName/ClassName/Name 获得的 HTMLCollection 用 querySelector 获得的 NodeList arguments对象 只定义在函数体中 有一个 length 属性 callee 属性(此函数自身) function foo(name, age, sex) { console.log(arguments); // [Arguments] { &amp;#39;0&amp;#39;: &amp;#39;jack&amp;#39;, &amp;#39;1&amp;#39;: &amp;#39;18&amp;#39;, &amp;#39;2&amp;#39;: &amp;#39;male&amp;#39; } console.</description></item><item><title>毎日のフロントエンド 145</title><link>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-145/</link><pubDate>Tue, 08 Feb 2022 20:47:08 +0900</pubDate><guid>https://youkoucoding.github.io/p/%E6%AF%8E%E6%97%A5%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89-145/</guid><description>第一百四十五日 HTML Question: 表单属性type=&amp;quot;hidden&amp;quot; &amp;lt;input type=&amp;quot;hidden&amp;quot;&amp;gt; &amp;ldquo;hidden&amp;rdquo; 类型的 &amp;lt;input&amp;gt; 元素允许 Web 开发者存放一些用户不可见、不可改的数据，在用户提交表单时，这些数据会一并发送出。比如，正被请求或编辑的内容的 ID，或是一个唯一的安全令牌。这些隐藏的 &amp;lt;input&amp;gt;元素在渲染完成的页面中完全不可见，而且没有方法可以使它重新变为可见。 隐藏域在页面中对于用户是不可见的，在表单中插入隐藏域的目的在于收集或发送信息，以利于被处理表单的程序所使用。浏览者单击发送按钮发送表单的时候，隐藏域的信息也被一起发送到服务器 有些时候要给用户一信息，在提交表单时一同提交,以确定用户身份，如 sessionkey 等．同样也可以用 cookie 实现，但使用隐藏域就简单的多了．兼容性好，且可以避免被禁用cookies 一个 form 里有多个提交按钮，怎样使程序能够分清楚到底用户是按那一个按钮提交上来的呢？ 这时可以添加隐藏域，然后在每一个按钮处加上 οnclick=&amp;ldquo;document.form.command.value=&amp;ldquo;xx&amp;rdquo;， 然后接到数据后先检查 command 的值就会知道用户是按的那个按钮提交上来的 一个网页中有多个 form，我们知道多个 form 是不能同时提交的，但有时这些 form 确实相互作用，我们就可以在 form 中添加隐藏域来使它们联系起来 JavaScript Question: 原生 Math 的方法有哪些 常用方法
Math.abs(num) // num绝对值 Math.ceil(num) // num向上取整 Math.floor(num) // num向下取整 Math.max(num1, num2 ...) // 取较大值 Math.min(num1, num2 ...) // 取较小值 Math.pow(num1, num2) // num1的num2次幂 Math.</description></item></channel></rss>